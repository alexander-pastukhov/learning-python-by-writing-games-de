[{"path":"index.html","id":"intro","chapter":"Kapitel 1 Einleitung","heading":"Kapitel 1 Einleitung","text":"Dieses Buch wird dich das Programmieren lehren. Hoffentlich auf eine spaßige Art und Weise, denn wenn es etwas Befriedigenderes gibt als ein Videospiel zu spielen, dann ist es, eines zu erstellen. Obwohl es für den Kurs “Python für soziale und experimentelle Psychologie” geschrieben wurde, ist mein Hauptziel nicht, dir Python sich beizubringen. Python ist ein fantastisches Werkzeug (mehr dazu später), aber es ist nur eine von vielen existierenden Programmiersprachen. Mein ultimatives Ziel ist es, dir dabei zu helfen, allgemeine Programmierfähigkeiten zu entwickeln, die nicht von einer spezifischen Programmiersprache abhängen, und sicherzustellen, dass du gute Gewohnheiten entwickelst, die deinen Code klar, leicht lesbar und leicht zu warten machen. Dieser letzte Teil ist entscheidend. Programmieren geht nicht nur darum, Code zu schreiben, der funktioniert. Das muss natürlich gegeben sein, ist aber nur die Mindestanforderung. Programmieren geht darum, einen klaren und leicht lesbaren Code zu schreiben, den andere und, noch wichtiger, du selbst zwei Wochen später verstehen kannst.","code":""},{"path":"index.html","id":"ziel-des-buches","chapter":"Kapitel 1 Einleitung","heading":"1.1 Ziel des Buches","text":"Das Ziel ist, dass du der Lage bist, ein anspruchsvolles Experiment zu programmieren, das mehrere Blöcke und Versuche, verschiedene Bedingungen, komplizierte visuelle Darstellungen, automatische Datenaufzeichnung und Fehlerbehandlung haben kann. Wenn das ambitioniert klingt, dann ist es das auch, aber wir werden kleinen Schritten vorgehen und im Prozess wirst du lernen.Kernkonzepte von Python einschließlich\nVariablen und Konstanten\nunveränderliche Datentypen wie Ganzzahlen, Fließkommazahlen, Zeichenketten, logische Werte und Tupel\nveränderliche Typen wie Listen und Dictionaries\nFunktionen\nSteuerungsstrukturen wie -else-Bedingungen und Schleifen\nobjektorientierte Programmierung einschließlich Konzepte des Vererbung, (optional) Duck-Typing und Mischung\nAusnahmen\nDateioperationen\nVariablen und Konstantenunveränderliche Datentypen wie Ganzzahlen, Fließkommazahlen, Zeichenketten, logische Werte und Tupelveränderliche Typen wie Listen und DictionariesFunktionenSteuerungsstrukturen wie -else-Bedingungen und Schleifenobjektorientierte Programmierung einschließlich Konzepte des Vererbung, (optional) Duck-Typing und MischungAusnahmenDateioperationenPsychoPy: Dies ist nicht Kern-Python, aber es ist eine erstklassige Bibliothek für psychophysische Experimente und du wirst die Schlüsselwerkzeuge lernen, die für die Programmierung eines Experiments erforderlich sind.Guter Programmierstil einschließlich\nKlaren Code iterativer Weise schreiben\nLesen (deines eigenen) Codes\nDokumentieren deines Codes\nDebuggen deines Programms VS Code\nKlaren Code iterativer Weise schreibenLesen (deines eigenen) CodesDokumentieren deines CodesDebuggen deines Programms VS CodeIch habe versucht, Konzepte dem Kontext zu präsentieren, der sie erfordert und daher besten erklärt und ihre typischen Anwendungsszenarien darstellt. Das bedeutet, dass das Material rund um verteilt ist und auf Bedarfsbasis präsentiert wird. Zum Beispiel wird das Konzept der Listen zuerst präsentiert, aber Operationen daran werden einem späteren Kapitel vorgestellt, sowohl weil wir dies erst später benötigen als auch um dein Gefühl, überwältigt zu sein, einem vernünftigen Rahmen zu halten. Dies macht es schwieriger, dieses Buch als Referenz zu verwenden (es gibt ausgezeichnete Referenzen da draußen, angefangen mit der offiziellen Python-Dokumentation), aber die Hoffnung ist, dass es dir durch die Bereitstellung von mundgerechten Informationsbrocken leichter fallen wird, das Material zu verstehen und es mit dem zu integrieren, du bereits weißt.Die gleiche “verteilte” Logik gilt für Übungen. Anstatt Ende jedes Kapitels aufgelistet zu sein, sind sie den Text eingebettet und du solltest sie zu diesem Zeitpunkt erledigen. Viele von ihnen dienen dazu, Konzepte zu verdeutlichen, die zuvor anhand von anschaulichen Beispielen präsentiert wurden, daher wäre es hilfreich, sie sofort durchzuführen. Gleiches gilt für die Programmierübung, obwohl du diesem Fall das gesamte Material lesen kannst, um eine “Vogelperspektive” auf das gesamte Programm zu bekommen und dann den Text erneut zu lesen und die Programmierübung durchzuführen.","code":""},{"path":"index.html","id":"voraussetzungen","chapter":"Kapitel 1 Einleitung","heading":"1.2 Voraussetzungen","text":"Dieses Material setzt keine Vorkenntnisse Python oder Programmierung beim Leser voraus. Sein Ziel ist es, dein Wissen schrittweise aufzubauen und dir zu ermöglichen, immer komplexere Spiele zu erstellen.","code":""},{"path":"index.html","id":"warum-spiele","chapter":"Kapitel 1 Einleitung","heading":"1.3 Warum Spiele?","text":"Der eigentliche Zweck dieses Kurses ist es, Psychologie- und Sozialwissenschaftsstudenten beizubringen, wie man Experimente programmiert. Das ist es, worum es der echten Forschung geht. Allerdings gibt es zwischen den beiden praktisch wenig Unterschied. Die grundlegenden Zutaten sind die gleichen und, man könnte sagen, Experimente sind einfach nur langweilige Spiele. Und sei versichert, wenn du ein Spiel programmieren kannst, kannst du sicherlich auch ein Experiment programmieren.","code":""},{"path":"index.html","id":"warum-sollte-ein-psychologe-programmieren-lernen","chapter":"Kapitel 1 Einleitung","heading":"1.4 Warum sollte ein Psychologe Programmieren lernen?","text":"Warum sollte ein Psychologe, der Menschen interessiert ist, lernen, wie man Computer programmiert? Die offensichtlichste Antwort ist, dass dies eine nützliche Fähigkeit ist. Wenn du programmieren kannst, hast du die Freiheit, ein Experiment zu erstellen, das deine Forschungsfrage beantwortet, und nicht ein Experiment, das aufgrund der Beschränkungen deiner Software implementiert werden kann.Noch wichtiger, zumindest aus meiner Sicht, ist, dass das Erlernen des Programmierens die Art und Weise, wie du im Allgemeinen denkst, verändert. Menschen sind klug, aber Computer sind dumm1. Wenn du dein Experiment oder deine Reisepläne jemandem erklärst, kannst du ziemlich vage sein, einen kleinen Fehler machen, sogar bestimmte Teile überspringen. Menschen sind klug, daher werden sie die fehlenden Informationen mit ihrem Wissen ergänzen, einen Fehler finden und korrigieren, dich nach mehr Informationen fragen und selbst improvisieren können, sobald sie auf etwas stoßen, das du nicht abgedeckt hast. Computer sind dumm, also musst du präzise sein, du kannst keine Grauzonen haben, du kannst nichts dem “es wird herausfinden, wenn es passiert” (es wird es nicht) überlassen. Meine persönliche Erfahrung, die von Psychologen bestätigt wurde, die das Programmieren gelernt haben, ist, dass es dir bewusst macht, wie vage und ungenau Menschen sein können, ohne es zu merken (und ohne dass du es merkst). Programmieren zwingt dich dazu, präzise und gründlich zu sein, für alle Eventualitäten zu planen, die es geben könnte. Und das ist sich eine sehr nützliche Fähigkeit, da sie auf alle Aktivitäten angewendet werden kann, die Planung erfordern, sei es ein experimentelles Design oder Reisevorkehrungen.","code":""},{"path":"index.html","id":"warum-python","chapter":"Kapitel 1 Einleitung","heading":"1.5 Warum Python?","text":"Es gibt viele Möglichkeiten, ein Experiment für psychologische Forschung zu erstellen. Du kannst Drag--Drop-Systeme verwenden, entweder kommerzielle wie Presentation, Experiment Builder oder kostenlose wie PsychoPy Builder Interface. Sie haben eine viel flachere Lernkurve, sodass du schneller mit dem Erstellen und Durchführen deiner Experimente beginnen kannst. Ihre einfache Handhabung hat jedoch einen Preis: Sie sind recht begrenzt, welche Reize du verwenden kannst und wie du die Präsentation, Bedingungen, Feedback etc. steuern kannst. der Regel erlauben sie dir, sie zu erweitern, indem du das gewünschte Verhalten programmierst, aber du musst wissen, wie man das macht (Python-Kenntnisse bereichern deine PsychoPy-Experimente). Daher denke ich, dass diese Systeme, insbesondere PsychoPy, großartige Werkzeuge sind, um schnell ein einfaches Experiment zusammenzusetzen. Sie sind jedoch nützlichsten, wenn du verstehst, wie sie den zugrunde liegenden Code erstellen und wie du ihn selbst programmieren würdest. Dann wirst du nicht durch die Software eingeschränkt, da du weißt, dass du etwas programmieren kannst, der Standard-Drag--Drop nicht zulässt. Gleichzeitig kannst du dich immer dafür entscheiden, wenn Drag--Drop ausreichend, aber schneller ist, oder du kannst eine Kombination aus beiden Ansätzen verwenden. Ende geht es darum, Optionen und kreative Freiheit zu haben, ein Experiment zu programmieren, das deine Forschungsfrage beantwortet, und nicht nur ein Experiment, das deine Software erlaubt zu programmieren.Wir werden das Programmieren Python lernen, eine großartige Sprache, die eine einfache und klare Syntax mit der Kraft und Fähigkeit kombiniert, fast jedes Problem zu bewältigen. diesem Seminar konzentrieren wir uns auf Desktop-Experimente, aber Sie können es für Online-Experimente (oTree und PsychoPy), wissenschaftliche Programmierung (NumPy und SciPy), Datenanalyse (pandas), Maschinelles Lernen (scikit-learn), Deep Learning (keras), Website-Programmierung (django), Computer Vision (OpenCV) usw. verwenden. Daher ist Python eines der vielseitigsten Programmierwerkzeuge, die Sie für alle Phasen Ihrer Forschung oder Arbeit verwenden können. Und Python ist kostenlos, dass Sie sich keine Sorgen machen müssen, ob Sie oder Ihr zukünftiger Arbeitgeber die Lizenzgebühren bezahlen können (ein sehr reales Problem, wenn Sie Matlab verwenden).","code":""},{"path":"index.html","id":"seminar-spezifische-informationen","chapter":"Kapitel 1 Einleitung","heading":"1.6 Seminar-spezifische Informationen","text":"Dies ist ein Material für das Seminar Python für Sozial- und Experimentelle Psychologie, wie ich es der Universität Bamberg lehre. Jedes Kapitel behandelt ein einzelnes Spiel und führt die notwendigen Ideen ein und wird von Übungen begleitet, die Sie absolvieren und einreichen müssen. Um das Seminar zu bestehen, müssen Sie alle Aufgaben absolvieren, d.h., alle Spiele schreiben. Sie müssen nicht alle Übungen abschließen oder korrekte Lösungen für alle Übungen liefern, um den Kurs zu bestehen und Informationen darüber, wie die Punkte für Übungen eine tatsächliche Note (falls Sie eine benötigen) oder “Bestanden” umgerechnet werden, werden während des Seminars verfügbar sein.Das Material ist strukturiert, dass jedes Kapitel oder Kapitelabschnitt typischerweise einer einzelnen Sitzung entspricht, außer für die abschließenden Kapitel, die auf komplexeren Spielen basieren und daher mehr Zeit Anspruch nehmen. Wir sind jedoch alle verschieden, also arbeiten Sie Ihrem eigenen Tempo, lesen Sie das Material und reichen Sie Aufgaben eigenständig ein. Ich werde für jede Aufgabe detailliertes Feedback geben und Ihnen die Möglichkeit bieten, Probleme anzugehen und erneut einzureichen, ohne Punkte zu verlieren. Beachten Sie, dass mein Feedback nicht nur die tatsächlichen Probleme mit dem Code abdeckt, sondern auch die Art und Weise, wie Sie die Lösung implementiert haben und wie sauber und gut dokumentiert Ihr Code ist. Denken Sie daran, unsere Aufgabe ist es nicht nur, zu lernen, wie man ein funktionierendes Spiel programmiert, sondern wie man einen schönen, klaren, leicht zu lesenden und zu wartenden Code schreibt2.Sehr wichtig: Zögern Sie nicht, Fragen zu stellen. Wenn ich das Gefühl habe, dass Sie die Informationen im Material übersehen haben, werde ich Sie auf die genaue Stelle hinweisen. Wenn Sie verwirrt sind, werde ich Sie sanft mit Fragen dazu anregen, Ihr eigenes Problem zu lösen. Wenn Sie mehr Informationen benötigen, werde ich diese liefern. Wenn Sie einfach mehr wissen wollen, fragen Sie und ich werde erklären, warum die Dinge sind, wie sie sind, oder vorschlagen, Sie lesen sollten. Wenn ich das Gefühl habe, dass Sie das Problem ohne meine Hilfe lösen können, werde ich Ihnen das sagen (obwohl ich wahrscheinlich trotzdem noch ein paar andeutende Fragen stellen würde).","code":""},{"path":"index.html","id":"über-das-material","chapter":"Kapitel 1 Einleitung","heading":"1.7 Über das Material","text":"Dieses Material ist kostenlos zu nutzen und steht unter der Lizenz Creative Commons Namensnennung-NichtKommerziell-KeineBearbeitung V4.0 International Lizenz.","code":""},{"path":"Software.html","id":"Software","chapter":"Kapitel 2 Software","heading":"Kapitel 2 Software","text":"Für dieses Buch und das Seminar müssen wir installierenPsychoPy.IDE Ihrer Wahl. Meine Anleitungen werden für Visual Studio Code sein, das eine sehr gute Python-Unterstützung bietet.Jupyter Notebook zum Ausprobieren kleiner Code-Snippets.Ich werde keine detaillierten Anleitungen zur Installation der notwendigen Software geben, sondern Sie eher auf die offiziellen Handbücher verweisen. Dies macht diesen Text zukunftssicherer, da sich spezifische Details leicht ändern könnten3.","code":""},{"path":"Software.html","id":"install-psychopy","chapter":"Kapitel 2 Software","heading":"2.1 PsychoPy","text":"Wenn Sie Windows verwenden, laden Sie die Standalone PsychoPy Version herunter und installieren Sie diese. Verwenden Sie die neueste (und beste) Ihnen vorgeschlagene PsychoPy-Version (PsychoPy 2023.2.2 mit Python 3.8 zum Zeitpunkt des Schreibens) und folgen Sie den Anweisungen.Wenn Sie Mac oder Linux verwenden, sind die Installation von PsychoPy über pip oder Anaconda Ihre Optionen. Bitte folgen Sie den aktuellen Anweisungen.","code":""},{"path":"Software.html","id":"install-vs-code","chapter":"Kapitel 2 Software","heading":"2.2 VS Code","text":"Visual Studio Code ist ein kostenloser, leichtgewichtiger Open-Source-Editor mit starker Unterstützung für Python. Laden Sie den Installer für Ihre Plattform herunter und folgen Sie den Anweisungen.Befolgen Sie als nächstes das Tutorial Getting Started Python VS Code. Wenn Sie Windows und die Standalone-Installation von PsychoPy verwenden, überspringen Sie den Abschnitt Install Python interpreter, da Sie bereits eine Python-Installation haben, die mit PsychoPy gebündelt ist. Dies ist der Interpreter, den Sie im Abschnitt Select Python interpreter verwenden sollten. meinem Fall ist der Pfad C:\\Program Files\\PsychoPy3\\python.exe.Installieren und aktivieren Sie einen Linter, eine Software, die syntaxtische und stilistische Probleme Ihrem Python-Quellcode hervorhebt. Folgen Sie dem Handbuch auf der Webseite von VS Code.","code":""},{"path":"Software.html","id":"jupyter-notebooks","chapter":"Kapitel 2 Software","heading":"2.3 Jupyter Notebooks","text":"Jupyter Notebooks bieten eine sehr bequeme Möglichkeit, Text, Bilder und Code einem einzigen Dokument zu mischen. Sie erleichtern auch das Ausprobieren verschiedener kleiner Code-Snippets parallel ohne das Ausführen von Skripten. Wir werden uns für unser erstes Kapitel und gelegentliche Übungen oder Code-Tests später darauf verlassen. Es gibt zwei Möglichkeiten, wie Sie sie verwenden können: 1) VS Code mit der Jupyter-Erweiterung, 2) Ihrem Browser mit der klassischen Oberfläche.","code":""},{"path":"Software.html","id":"jupyter-notebooks-in-vs-code","chapter":"Kapitel 2 Software","heading":"2.3.1 Jupyter Notebooks in VS Code","text":"Folgen Sie der Anleitung, wie Sie das Jupyter-Paket installieren und Notebooks VS Code verwenden.","code":""},{"path":"Software.html","id":"jupyter-notebooks-in-anaconda","chapter":"Kapitel 2 Software","heading":"2.3.2 Jupyter Notebooks in Anaconda","text":"Die einfachste Möglichkeit, Jupyter Notebooks zusammen mit vielen anderen nützlichen Data-Science-Tools zu verwenden, ist über das Anaconda Toolkit. Beachten Sie jedoch, dass dies eine zweite Python-Distribution Ihrem System installiert. Dies könnte wiederum zu Verwirrung führen, wenn Sie mit Skripten VS Code arbeiten und versehentlich den Anaconda-Interpreter statt den PsychoPy-Interpreter aktiv haben. Keine Panik, folgen Sie den Select Python interpreter Anweisungen und stellen Sie sicher, dass Sie den PsychoPy-Interpreter als den aktiven haben.Ansonsten laden Sie Anaconda herunter und installieren Sie es. Die Website hat einen ausgezeichneten Getting started Abschnitt.","code":""},{"path":"Software.html","id":"files-folder","chapter":"Kapitel 2 Software","heading":"2.4 Ordnung halten","text":"Bevor wir anfangen, schlage ich vor, dass Sie einen Ordner namens games--python (oder ähnlich) erstellen. Wenn Sie sich dafür entschieden haben, Jupyter Notebooks über Anaconda zu nutzen, sollten Sie diesen Ordner Ihrem Benutzerordner erstellen, da Anaconda dort die Dateien erwartet. Dann erstellen Sie einen neuen Unterordner für jedes Kapitel / Spiel. Für das Seminar müssten Sie einen Ordner mit allen Dateien zippen und hochladen.","code":""},{"path":"programming-tips.html","id":"programming-tips","chapter":"Kapitel 3 Programmier-Tipps und -Tricks","heading":"Kapitel 3 Programmier-Tipps und -Tricks","text":"Bevor Sie Ihren ersten Code schreiben, müssen wir über die Kunst des Programmierens sprechen. Wie ich bereits erwähnt habe, geht es nicht nur darum, dass der Code funktioniert, sondern darum, dass er leicht zu verstehen ist. Korrekt funktionierender Code ist ein schönes Plus, aber wenn ich zwischen einem Spaghetti-Code, der momentan korrekt funktioniert, und einem klar geschriebenen und dokumentierten Code, der noch repariert werden muss, wählen muss, werde ich immer Letzteren bevorzugen. Ich kann Dinge reparieren, die ich verstehe, ich kann nur hoffen, wenn ich das nicht tue.Unten sind einige Tipps zum Schreiben und Lesen von Code. Einige mögen beim ersten Lesen kryptisch klingen (sie werden klar, sobald wir das notwendige Material behandeln). Einige werden sich für die einfachen Projekte, die wir umsetzen werden, als Overkill anfühlen. Ich schlage vor, dass Sie diesen Abschnitt beim ersten Mal ungezwungen lesen, aber oft darauf zurückkommen, sobald wir ernsthaft mit Programmieren beginnen. Leider werden diese Tricks nicht funktionieren, wenn Sie sie nicht benutzen! Daher sollten Sie sie immer benutzen und sie sollten Ihre guten Gewohnheiten werden, wie das Anlegen eines Sicherheitsgurtes. Der Sicherheitsgurt ist den meisten (hoffentlich allen) Tagen nicht nützlich, aber Sie tragen ihn, weil er plötzlich und sehr dringend extrem nützlich werden könnte und Sie nie sicher sein können, wann das passieren wird. Gleiches gilt für das Programmieren. Oft werden Sie versucht sein, einen “quick-n-dirty” Code zu schreiben, weil es sich nur um einen “einfachen Test”, eine temporäre Lösung, einen Prototyp, ein Pilotexperiment, usw. handelt. Aber wie man schön sagt: “Es gibt nichts Beständigeres als eine provisorische Lösung”. Häufiger als nicht werden Sie feststellen, dass Ihr Spielzeugcode zu einem ausgewachsenen Experiment herangewachsen ist und es ein Durcheinander ist. Oder Sie möchten zu dem Pilotexperiment zurückkehren, das Sie vor ein paar Monaten durchgeführt haben, aber Sie stellen fest, dass es einfacher ist, von vorne zu beginnen, als zu verstehen, wie dieses Monster funktioniert4. Widerstehen Sie also der Versuchung! Bilden Sie gute Gewohnheiten und Ihr zukünftiges Ich wird sehr dankbar sein!","code":""},{"path":"programming-tips.html","id":"schreibtipps","chapter":"Kapitel 3 Programmier-Tipps und -Tricks","heading":"3.1 Den Code schreiben","text":"","code":""},{"path":"programming-tips.html","id":"verwende-einen-linter","chapter":"Kapitel 3 Programmier-Tipps und -Tricks","heading":"3.1.1 Verwende einen Linter","text":"Ein Linter ist ein Programm, das deinen Code-Stil analysiert und highlightet Probleme, die es findet: unnötige Leerzeichen, fehlende Leerzeichen, falsche Namen, übermäßig lange Zeilen, usw. Diese haben keinen Einflluss darauf, wie der Code ausgeführt wird, aber das Befolgen der Linter-Ratschläge führt zu einem konsistenten Standard, wenn auch langweiligen[^ “Langweilig ist gut!”, siehe den Film “Hitman’s Bodyguard.”] Python Code. Versuche, alle Probleme zu beheben, die der Linter aufgeworfen hat. Verwende jedoch dein besseres Urteilsvermögen, denn manchmal sind Zeilen, die länger sind als der Linter es bevorzugen würde, lesbarer als zwei kürzere. Ebenso kann ein “schlechter” Variablenname nach den Standards des Linters für einen Psychologen eine aussagekräftige Bezeichnung sein. Denke daran, dein Code ist für Menschen, nicht für den Linter.","code":""},{"path":"programming-tips.html","id":"dokumentiere-deinen-code","chapter":"Kapitel 3 Programmier-Tipps und -Tricks","heading":"3.1.2 Dokumentiere deinen Code","text":"Jedes Mal, wenn du eine neue Datei erstellst: dokumentiere sie und aktualisiere die Dokumentation, wann immer du neue Funktionen oder Klassen hinzufügst/änderst/löschst. Jedes Mal, wenn du eine neue Funktion erstellst: dokumentiere sie. Neue Klasse: dokumentiere sie. Neue Konstante: es sei denn, es ist alleine aus dem Namen klar, dokumentiere sie. Du wirst eine NumPy Methode der Dokumentation dem Buch lernen.Ich kann nicht genug betonen, wie wichtig es ist, deinen Code zu dokumentieren. VS Code (ein Editor, den wir verwenden werden) ist intelligent genug, um NumPy Docstrings zu parsen, also wird es dir diese Hilfe anzeigen, wann immer du deine eigenen Funktionen verwendest (hilft dir, dir selbst zu helfen!). Noch wichtiger ist, dass das Schreiben von Dokumentationen dich dazu zwingt, menschlicher Sprache zu denken und zu formulieren, die Funktion oder Klasse macht, welchen Typ die Argumente / Attribute / Methoden haben, der Bereich der gültigen Werte ist, die Standards sind, eine Funktion zurückgeben sollte usw. Mehr als oft nicht, wirst du feststellen, dass du ein wichtiges Detail übersehen hast, das aus dem Code selbst nicht ersichtlich ist.","code":""},{"path":"programming-tips.html","id":"füge-etwas-luft-hinzu","chapter":"Kapitel 3 Programmier-Tipps und -Tricks","heading":"3.1.3 Füge etwas Luft hinzu","text":"Trenne Codeblöcke durch einige leere Zeilen. Denke Absätze im normalen Text. Du würdest nicht wollen, dass dein Buch ein einziger Absatz-Alptraum ist? Platziere vor jedem Codeblock einen Kommentar, der erklärt, er macht, aber nicht wie er es macht. Zum Beispiel wird es unserem typischen PsychoPy-basierten Spiel einen Punkt geben, dem wir alle Reize zeichnen und das Fenster aktualisieren. Das ist ein schöner selbstständiger Codeblock, der als # Zeichnen aller Reize beschrieben werden kann. Der Code liefert Details darüber, genau gezeichnet wird, die Zeichenreihenfolge ist, usw. Aber dieser einzelne Kommentar hilft dir zu verstehen, worum es diesem Codeblock geht und ob er für dich momentan relevant ist.\nDas Gleiche gilt für # Verarbeitung von Tastendrücken oder # Überprüfung der Spielende-Bedingungen, usw. Aber sei vorsichtig und stelle sicher, dass der Kommentar den Code korrekt beschreibt. Wenn der Kommentar zum Beispiel # Zeichnen aller Reize sagt, sollte es nirgendwo anders einen Code zum Zeichnen von Reizen geben und keinen weiteren Code, der etwas anderes tut!","code":""},{"path":"programming-tips.html","id":"schreibe-deinen-code-schritt-für-schritt","chapter":"Kapitel 3 Programmier-Tipps und -Tricks","heading":"3.1.4 Schreibe deinen Code Schritt für Schritt","text":"Dein Motto sollte “langsam aber stetig” lauten. Auf diese Weise werde ich dich durch die Spiele führen. Beginne immer mit etwas extrem Einfachem wie einem statischen Rechteck oder Bild. Stelle sicher, dass es funktioniert. Füge eine kleinere Funktionalität hinzu: Farbwechsel, Positionsänderung, ein weiteres Rechteck, speichere es als Attribut, usw. Stelle sicher, dass es funktioniert. Gehe niemals zum nächsten Schritt, es sei denn, du verstehst vollständig, dein aktueller Code macht und du bist dir zu 100% sicher, dass er sich verhält, wie er sollte. Und ich meine 100% ernst! Wenn du auch nur den Schatten eines Zweifels hast, überprüfe es erneut. Andernfalls wird dieser Schatten wachsen und dich zunehmend unsicher über deinen Code machen. Dieser Ansatz Schildkrötengeschwindigkeit mag albern und übermäßig langsam erscheinen, ist aber immer noch schneller, als einen großen Codeblock zu schreiben und dann zu versuchen, ihn zum Laufen zu bringen. Es ist viel einfacher, einfache Probleme einzeln zu lösen, als viele auf einmal.","code":""},{"path":"programming-tips.html","id":"es-ist-nichts-falsches-an-stackoverflow","chapter":"Kapitel 3 Programmier-Tipps und -Tricks","heading":"3.1.5 Es ist nichts Falsches an StackOverflow","text":"Ja, man kann immer versuchen, eine Lösung für sein Problem auf StackOverflow zu finden5. Ich mache das die ganze Zeit! Sie sollten die bereitgestellte Lösung jedoch nur verwenden, wenn Sie sie verstehen! Kopieren Sie nicht einfach den Code, der ein Problem wie Ihres zu lösen scheint. Wenn Sie das tun und Sie haben Glück, könnte es funktionieren. Oder, wieder wenn Sie Glück haben, funktioniert es auf eine offensichtliche Weise nicht. Aber wenn Sie nicht viel Glück haben, wird es (manchmal) subtil falsch funktionieren. Und da Sie nicht wirklich wussten, der Code tat, als Sie ihn einfügten, werden Sie noch mehr verwirrt sein. Nutzen Sie also StackOverflow als eine Quelle des Wissens, nicht als eine Quelle zum Kopieren und Einfügen von Code!","code":""},{"path":"programming-tips.html","id":"reading-tips","chapter":"Kapitel 3 Programmier-Tipps und -Tricks","heading":"3.2 Den Code lesen","text":"Das Lesen von Code ist einfach, weil Computer dumm sind und Sie schlau sind. Das bedeutet, dass die Anweisungen, die Sie dem Computer geben, notwendigerweise sehr einfach sind und daher für einen Menschen sehr leicht zu verstehen sind. Das Lesen von Code ist jedoch auch schwierig, weil Computer dumm sind und Sie schlau sind. Sie sind schlau, dass Sie nicht einmal den gesamten Code lesen müssen, um zu verstehen, er tut. Sie lesen nur die Schlüsselstellen und füllen die Lücken aus. Leider neigen Sie dazu, Fehler zu überlesen. Dies ist nicht nur beim Programmieren der Fall, wenn Sie jemals einen Text Korrektur gelesen haben, wissen Sie, wie schwierig es ist, Tippfehler zu finden. Ihr Gehirn korrigiert sie Echtzeit mit Hilfe des Kontexts und Sie lesen das Wort , wie es sein sollte, nicht , wie es tatsächlich geschrieben ist6.Meine Erfahrung mit Programmierung im Allgemeinen und im Besonderen auf diesem Seminar ist, dass die meisten Probleme, bei denen Sie stecken bleiben, im Nachhinein einfach bis dumm und offensichtlich sind7. Verzweifeln Sie nicht! Es liegt nicht Ihnen, sondern ist lediglich eine Folge davon, wie wunderbar Ihr Gehirn für die Mustererkennung verdrahtet ist. Im Folgenden finden Sie einige Vorschläge, die Ihnen helfen könnten, das Lesen von Code robuster zu gestalten.","code":""},{"path":"programming-tips.html","id":"denken-sie-wie-ein-computer","chapter":"Kapitel 3 Programmier-Tipps und -Tricks","heading":"3.2.1 Denken Sie wie ein Computer","text":"Lesen Sie den Code Zeile für Zeile und “führen Sie ihn aus”, wie es der Computer tun würde. Verwenden Sie Stift und Papier, um den Überblick über die Variablen zu behalten. Verfolgen Sie, welche Codeblöcke wann erreicht werden können. Verlangsamen Sie sich und stellen Sie sicher, dass Sie jede Zeile verstehen und der Lage sind, den Überblick über die Variablen zu behalten. Sobald Sie das tun, wird es einfach sein, einen Fehler zu erkennen.","code":""},{"path":"programming-tips.html","id":"tun-sie-so-als-hätten-sie-diesen-code-in-ihrem-leben-noch-nie-gesehen","chapter":"Kapitel 3 Programmier-Tipps und -Tricks","heading":"3.2.2 Tun Sie so, als hätten Sie diesen Code in Ihrem Leben noch nie gesehen","text":"Nehmen Sie , Sie haben keine Ahnung, der Code tut. Wie ich schrieb, sehen Sie oft wörtlich einen Fehler nicht, weil Ihr Gehirn Details auffüllt und die Realität biegt, dass sie Ihren Erwartungen entspricht8. Sie wissen, dieser Codeblock tun sollte, also lesen Sie ihn statt dessen nur flüchtig und nehmen , dass er tut, er soll, es sei denn, es sieht offensichtlich schrecklich falsch aus. Es ist schwer, Ihre Erwartungen auszuschalten, aber es ist immens hilfreich.","code":""},{"path":"programming-tips.html","id":"suchen-sie-nicht-nur-unter-der-straßenlampe","chapter":"Kapitel 3 Programmier-Tipps und -Tricks","heading":"3.2.3 Suchen Sie nicht nur unter der Straßenlampe","text":"Immer wenn Sie neuen Code verwenden oder etwas implementieren müssen, das kompliziert erscheint, und Ihr Code nicht funktioniert, wie er sollte, neigen Sie dazu, anzunehmen, dass das Problem beim neuen, ausgefallenen Code liegt. Einfach, weil er neu, ausgefallen und kompliziert ist. Meiner Erfahrung nach versteckt sich der Fehler jedoch typischerweise der einfacheren “trivialen” Codezeile der Nähe, die Sie nie richtig anschauen, weil sie einfach und trivial ist. Überprüfen Sie alles, nicht nur die Stellen, denen Sie einen Fehler vermuten.","code":""},{"path":"programming-tips.html","id":"nutzen-sie-den-debugger","chapter":"Kapitel 3 Programmier-Tipps und -Tricks","heading":"3.2.4 Nutzen Sie den Debugger","text":"Im Buch werden Sie lernen, wie Sie die Ausführung Ihres Spiels anhalten können, um seinen Zustand zu untersuchen. Nutzen Sie dieses Wissen! Setzen Sie Haltepunkte und führen Sie den Code Schritt für Schritt aus. Überprüfen Sie die Werte von Variablen im Tab “Watch”. Verwenden Sie die Debug-Konsole, um zu überprüfen, ob Funktionen die Ergebnisse liefern, die sie sollten. Teilen Sie komplexe Bedingungen oder mathematische Formeln kleine Teile auf, kopieren und führen Sie diese Teile der Debug-Konsole aus und überprüfen Sie, ob die Zahlen zusammenpassen. Stellen Sie sicher, dass ein Codeblock Ordnung ist und analysieren Sie dann den nächsten. Das Debuggen ist besonders hilfreich, um den Code zu identifizieren, der nicht erreicht wird oder zum falschen Zeitpunkt erreicht wird.","code":""},{"path":"programming-tips.html","id":"zen-von-python","chapter":"Kapitel 3 Programmier-Tipps und -Tricks","heading":"3.3 Zen von Python","text":"Ich fand den Zen von Python als gute Inspiration, um die Programmierung anzugehen.","code":""},{"path":"python-grundlagen.html","id":"python-grundlagen","chapter":"Kapitel 4 Python Grundlagen","heading":"Kapitel 4 Python Grundlagen","text":"Hoffentlich hast du bereits einen speziellen Ordner für dieses Buch erstellt. Lade das Übungs-Notebook herunter (Alt+Klick sollte es eher herunterladen als öffnen), lege es den Ordner des Kapitels und öffne es, siehe die relevanten Anweisungen. Du musst zwischen den Erklärungen hier und den Übungen im Notizbuch hin und wechseln, also halte sie beide offen.","code":""},{"path":"python-grundlagen.html","id":"konzepte-des-kapitels","chapter":"Kapitel 4 Python Grundlagen","heading":"4.1 Konzepte des Kapitels","text":"Variablen.Konstanten.Grundlegende Werttypen.Dinge ausdrucken.Werte Zeichenketten einfügen.","code":""},{"path":"python-grundlagen.html","id":"variablen","chapter":"Kapitel 4 Python Grundlagen","heading":"4.2 Variablen","text":"Das erste grundlegende Konzept, mit dem wir uns vertraut machen müssen, ist die Variable. Variablen werden verwendet, um Informationen zu speichern, und du kannst sie dir als eine Kiste mit einem Namensschild vorstellen, die du etwas hineinlegen kannst. Das Namensschild auf dieser Kiste ist der Name der Variable und ihr Wert ist das, du darin speicherst. Zum Beispiel können wir eine Variable erstellen, die die Anzahl der Beine speichert, die ein Spielfigur hat. Wir beginnen mit einer für einen Menschen typischen Zahl.Python würdest du schreibenDie obige Zuweisungsanweisung hat eine sehr einfache Struktur:Der Variablenname (das Namensschild auf der Kiste) sollte aussagekräftig sein, er kann mit Buchstaben oder _ beginnen und kann Buchstaben, Zahlen und das Symbol _ enthalten, aber keine Leerzeichen, Tabs, Sonderzeichen usw. Python empfiehlt9 dass du die snake_case Schreibweise (alles Kleinbuchstaben, Unterstrich für Leerzeichen) verwendest, um deine Variablennamen zu formatieren. Der <Wert> auf der rechten Seite ist eine komplexere Geschichte, da er fest codiert sein kann (wie im obigen Beispiel), berechnet werden kann, indem andere Variablen oder dieselbe Variable, zurückgegeben von einer Funktion, usw. verwendet werden.Die Verwendung von Variablen bedeutet, dass du dich auf die Bedeutung der entsprechenden Werte konzentrieren kannst, anstatt dir Sorgen darüber zu machen, diese Werte sind. Beispielsweise kannst du das nächste Mal, wenn du etwas auf Grundlage der Anzahl der Beine eines Charakters berechnen musst (z.B., wie viele Paar Schuhe benötigt ein Charakter), dies auf Grundlage des aktuellen Wertes der Variablen anzahl_der_beine berechnen, anstatt anzunehmen, dass es 1 ist.Variablen geben dir auch Flexibilität. Ihre Werte können sich während des Programmablaufs ändern: Der Punktestand des Spielers steigt, die Anzahl der Leben nimmt ab, die Anzahl der Zauber, die er wirken kann, steigt oder fällt je nach ihrem Einsatz, usw. Dennoch kannst du immer den Wert der Variablen verwenden, um die notwendigen Berechnungen durchzuführen. Hier ist zum Beispiel ein leicht erweitertes Beispiel für anzahl_der_schuhe.Wie bereits erwähnt, kannst du eine Variable als eine beschriftete Kiste betrachten, die du etwas hineinlegen kannst. Das bedeutet, dass du immer den alten Wert “wegwerfen” und etwas Neues hineinlegen kannst. Im Falle von Variablen geschieht der “Wegwerf”-Teil automatisch, da ein neuer Wert den alten überschreibt. Überprüfe selbst, welcher der endgültige Wert der Variable im unten stehenden Code ist?Mache Übung #1.Beachte, dass eine Variable (eine “Kiste mit Namensschild”) erst existiert, nachdem du ihr etwas zugewiesen hast. Der folgende Code erzeugt also einen NameError, die Python-art zu sagen, dass sie noch nie von der Variable anzahl_der_haende gehört hat.Du kannst jedoch eine Variable erstellen, die keinen spezifischen Wert hat, indem du ihr None zuweist. None wurde speziell für die Bedeutung kein Wert oder nichts zur Sprache hinzugefügt.Wie du bereits gesehen hast, kannst du einen Wert berechnen, anstatt ihn anzugeben. wäre die Antwort hier?Mache Übung #2.","code":"anzahl_der_beine = 2<variablen-name> = <wert># SCHLECHT: Warum 1? Ist es, weil der Character zwei Beine hat oder\n# weil wir jedem Character ein Paar Schuhe geben, unabhängig von\n# seiner tatsächlichen Anzahl von Beinen?\npaar_schuhe = 1\n\n# BESSER (aber was, wenn unser Charakter nur ein Bein hat?)\npaar_schuhe = anzahl_der_beine / 2anzahl_der_beine = 2\n\n# ...\n# etwas passiert und unser Charakter wird in einen Tintenfisch verwandelt\nanzahl_der_beine = 8\n# ...\n\n# der gleiche Code funktioniert immer noch und wir können immer noch die richtige Anzahl an Schuhpaaren berechnen\npaar_schuhe = anzahl_der_beine / 2anzahl_der_beine = 2\nanzahl_der_beine = 5\nanzahl_der_beine = 1\nanzahl_der_beineanzahl_der_beine = 2\nanzahl_der_handschuhe = anzahl_der_haende / 2anzahl_der_haende = None # Die Variable existiert jetzt, hat aber keinen speziellen Wert.anzahl_der_beine = 2 * 2\nanzahl_der_beine = 7 - 2\nanzahl_der_beine"},{"path":"python-grundlagen.html","id":"zuweisungen-sind-keine-gleichungen","chapter":"Kapitel 4 Python Grundlagen","heading":"4.3 Zuweisungen sind keine Gleichungen!","text":"Sehr wichtig: obwohl Zuweisungen wie mathematische Gleichungen aussehen, sind sie keine Gleichungen! Sie folgen einer sehr wichtigen Regel, die Sie im Kopf behalten müssen, wenn Sie Zuweisungen verstehen: die rechte Seite eines Ausdrucks wird zuerst ausgewertet, bis der Endwert berechnet ist. Erst dann wird dieser Endwert der auf der linken Seite angegebenen Variable zugewiesen (also die Kiste gelegt). Das bedeutet, dass Sie die gleiche Variable auf beiden Seiten verwenden können! Sehen wir uns diesen Code :passiert, wenn der Computer die letzte Zeile auswertet? Zunächst nimmt er die aktuellen Werte aller Variablen (2 für x und 5 für y) und setzt sie den Ausdruck. Nach diesem internen Schritt sieht der Ausdruck aus:Dann berechnet er den Ausdruck auf der rechten Seite und speichert, sobald die Berechnung abgeschlossen ist, diesen neuen Wert xMachen Sie die Übung #3, um sicherzugehen, dass Sie dies verstanden haben.","code":"x = 2\ny = 5\nx = x + y - 4x = 2 + 5 - 4x = 3"},{"path":"python-grundlagen.html","id":"constants","chapter":"Kapitel 4 Python Grundlagen","heading":"4.4 Konstanten","text":"Obwohl die eigentliche Stärke von Variablen darin besteht, dass Sie ihren Wert ändern können, sollten Sie sie auch dann verwenden, wenn der Wert im gesamten Programm konstant bleibt. Python gibt es keine echten Konstanten, sondern die Übereinkunft, dass ihre Namen vollständig GROSSGESCHRIEBEN sein sollten. Entsprechend wissen Sie, wenn Sie SOLCH_EINE_VARIABLE sehen, dass Sie ihren Wert nicht ändern sollten. Technisch gesehen ist das nur eine Empfehlung, denn niemand kann Sie davon abhalten, den Wert einer KONSTANTE zu ändern. Aber ein großer Teil der Benutzerfreundlichkeit von Python resultiert aus solchen Übereinkünften (wie der snake_case Konvention oben). Wir werden später mehr von solchen Übereinkünften treffen, zum Beispiel beim Lernen über Objekte.Unter Berücksichtigung dessen, wenn die Anzahl der Beine im Spiel konstant bleibt, sollten Sie diese Konstanz betonen und schreibenIch empfehle dringend die Verwendung von Konstanten und vermeide das Hardcoding von Werten. Erstens, wenn Sie mehrere identische Werte haben, die verschiedene Dinge bedeuten (2 Beine, 2 Augen, 2 Ohren, 2 Fahrzeuge pro Figur, etc.), wird Ihnen eine 2 im Code nicht verraten, diese 2 bedeutet (die Beine? Die Ohren? Der Punktemultiplikator?). Sie können das natürlich herausfinden, basierend auf dem Code, der diese Nummer verwendet, aber Sie könnten sich diese zusätzliche Mühe ersparen und stattdessen eine ordnungsgemäß benannte Konstante verwenden. Dann lesen Sie einfach ihren Namen und die Bedeutung des Wertes wird offensichtlich, und es ist die Bedeutung und nicht der tatsächliche Wert, der Sie hauptsächlich interessiert. Zweitens, wenn Sie entscheiden, diesen Wert dauerhaft zu ändern (sagen wir, unsere Hauptfigur ist jetzt ein Dreifuß), bedeutet die Verwendung einer Konstante, dass Sie sich nur einer Stelle Sorgen machen müssen, der Rest des Codes bleibt unverändert. Wenn Sie diese Zahl hart codiert haben, erwartet Sie eine aufregende 10 und definitiv lange Suche und Ersetzung im gesamten Code.Machen Sie die Übung #4.","code":"ANZAHL_DER_BEINE = 2"},{"path":"python-grundlagen.html","id":"value-types","chapter":"Kapitel 4 Python Grundlagen","heading":"4.5 Datentypen","text":"Bisher haben wir nur ganzzahlige numerische Werte verwendet (1, 2, 5, 1000…). Obwohl Python viele verschiedene Datentypen unterstützt, konzentrieren wir uns zunächst auf eine kleine Auswahl davon:Ganze Zahlen, die wir bereits verwendet haben, z.B. -1, 100000, 42.Fließkommazahlen, die jeden realen Wert annehmen können, z.B. 42.0, 3.14159265359, 2.71828.Zeichenketten, die Text speichern können. Der Text ist zwischen entweder gepaarten Anführungszeichen \"einiger Text\" oder Apostrophen 'einiger Text' eingeschlossen. Das bedeutet, dass Sie Anführungszeichen oder Apostrophe innerhalb der Zeichenkette verwenden können, solange sie von der Alternative umschlossen ist. Z.B., \"Schüleraufgaben\" (eingeschlossen \", Apostroph ' innen) oder '\"Alle Verallgemeinerungen sind falsch, auch diese.\" Mark Twain' (Zitat von Apostrophen eingeschlossen). Es gibt noch viel mehr zu Zeichenketten und wir werden dieses Material im Laufe des Kurses behandeln.Logische / boolesche Werte, die entweder True oder False sind.Bei der Verwendung einer Variable ist es wichtig, dass Sie wissen, welchen Datentyp sie speichert, und das liegt meist bei Ihnen. einigen Fällen wird Python einen Fehler ausgeben, wenn Sie versuchen, eine Rechnung mit inkompatiblen Datentypen durchzuführen. anderen Fällen wird Python Werte automatisch zwischen bestimmten Typen konvertieren, z.B. ist jeder Ganzzahlwert auch ein Realwert, dass die Konvertierung von 1 zu 1.0 meist trivial und automatisch ist. anderen Fällen müssen Sie jedoch möglicherweise eine explizite Konvertierung verwenden. Gehen Sie zur Übung #5 und versuchen Sie zu erraten, welcher Code laufen wird und welcher einen Fehler wegen inkompatiblen Typen werfen wird?Mache Übung #5.Überrascht vom letzten? Das liegt daran, dass intern True auch 1 und False 0 ist!Sie können explizit von einem Typ einen anderen umwandeln, indem Sie spezielle Funktionen verwenden. Beispielsweise können Sie eine Zahl oder einen logischen Wert einen String umwandeln, indem Sie einfach str(<value>) schreiben. wäre das Ergebnis den untenstehenden Beispielen?Mache Übung #6.Ähnlich können Sie mit der Funktion bool(<value>) eine logische/boolesche Variable umwandeln. Die Regeln sind einfach, für numerische Werte ist 0 gleich False, jeder andere Nicht-Null-Wert wird True umgewandelt. Für Zeichenketten wird eine leere Zeichenkette '' als False bewertet und eine nicht leere Zeichenkette wird True umgewandelt. wäre die Ausgabe den untenstehenden Beispielen?Mache Übung #7.Die Umwandlung Ganzzahlen oder Fließkommazahlen mit int(<value>) bzw. float(<value>) ist komplizierter. Der einfachste Fall ist von logisch auf Ganzzahl/Fließkommazahl, da True Ihnen int(True) ist 1 und float(True) ist 1.0 gibt und False gibt Ihnen 0/0.0. Beim Umwandeln von Fließkommazahl auf Ganzzahl lässt Python einfach den Bruchteilteil fallen (es rundet nicht richtig!). Bei der Umwandlung einer Zeichenkette muss es sich um eine gültige Zahl des entsprechenden Typs handeln, sonst wird ein Fehler erzeugt. Sie können z. B. eine Zeichenkette wie \"123\" eine Ganzzahl oder eine Fließkommazahl umwandeln, aber das funktioniert nicht für \"a123\". Darüber hinaus können Sie \"123.4\" eine Fließkommazahl umwandeln, aber nicht eine Ganzzahl, da sie einen Bruchteil enthält. Angesichts dessen, welche Zellen würden funktionieren und welche Ausgabe würden sie erzeugen?Mache Übung #8.","code":"5 + 2.0\n'5' + 2\n'5' + '2'\n'5' + True\n5 + Truestr(10 / 2)\nstr(2.5 + True)\nstr(True)bool(-10)\nbool(0.0)\n\nsecret_message = ''\nbool(secret_message)\n\nbool('False')float(False)\nint(-3.3)\nfloat(\"67.8\")\nint(\"123+3\")"},{"path":"python-grundlagen.html","id":"print","chapter":"Kapitel 4 Python Grundlagen","heading":"4.6 Ausgabe drucken","text":"Um den Wert auszudrucken, müssen Sie die Funktion print() verwenden (wir werden später allgemein über Funktionen sprechen). Im einfachsten Fall übergeben Sie den Wert und er wird ausgegeben.oderNatürlich wissen Sie bereits über die Variablen Bescheid, also statt den Wert direkt einzugeben, können Sie stattdessen eine Variable übergeben und ihr Wert wird ausgegeben.oderSie können auch mehr als einen Wert/Variablen die Druckfunktion übergeben und alle Werte werden nacheinander gedruckt. Wenn wir dem Benutzer zum Beispiel sagen wollen, ich zum Frühstück hatte, können wir das tunWas wird von dem untenstehenden Code gedruckt?Mache Übung #9.Allerdings möchten Sie wahrscheinlich expliziter sein, wenn Sie die Informationen ausdrucken. Stellen Sie sich zum Beispiel vor, Sie haben diese drei Variablen:Sie könnten natürlich print(mahlzeit, gericht, anzahl) machen, aber es wäre schöner, “Ich hatte 10 Pfannkuchen zum Frühstück” zu drucken, wobei die Fettschrift gedruckten Elemente die eingefügten Variablenwerte wären. Dafür müssen wir die Formatierung von Zeichenketten verwenden. Bitte beachten Sie, dass die Formatierung von Zeichenketten nicht spezifisch für das Drucken ist, Sie können einen neuen Zeichenkettenwert über die Formatierung erstellen und ihn einer Variable speichern, ohne ihn auszudrucken, oder ihn ausdrucken, ohne ihn zu speichern.","code":"print(5)\n#> 5print(\"fünf\")\n#> fünfanzahl_der_pfannkuchen = 10\nprint(anzahl_der_pfannkuchen)\n#> 10frühstück = \"pfannkuchen\"\nprint(frühstück)\n#> pfannkuchenfrühstück = \"pfannkuchen\"\nanzahl_der_artikel = 10\nprint(frühstück, anzahl_der_artikel)\n#> pfannkuchen 10abendessen = \"steak\"\nzähler = 4\nnachtisch = \"muffins\"\n\nprint(zähler, abendessen, zähler, nachtisch)mahlzeit = \"Frühstück\"\ngericht = \"Pfannkuchen\"\nanzahl = 10"},{"path":"python-grundlagen.html","id":"string-formatting","chapter":"Kapitel 4 Python Grundlagen","heading":"4.7 Formatierung von Zeichenketten","text":"Eine großartige Ressource zur Formatierung von Zeichenketten Python ist pyformat.info. Da sich Python ständig weiterentwickelt, gibt es nun mehr als eine Art, Zeichenketten zu formatieren. Im Folgenden werde ich das “alte” Format vorstellen, das auf der klassischen Formatierung von Zeichenketten basiert, die der Funktion sprintf C, Matlab, R und vielen anderen Programmiersprachen verwendet wird. Es ist etwas weniger flexibel als neuere, aber für einfache Aufgaben ist der Unterschied vernachlässigbar. Das Wissen über das alte Format ist nützlich wegen seiner Allgemeinheit. Wenn Sie Alternativen lernen möchten, lesen Sie unter dem oben angegebenen Link.Der allgemeine Aufruf lautet \"ein String mit Formatierung\"%(Tupel von Werten, die während der Formatierung verwendet werden). Sie werden später mehr über Tupel lernen. Gehen Sie im Moment davon aus, dass es sich einfach um eine durch Kommas getrennte Liste von Werten handelt, die runden Klammern eingeschlossen sind: (1, 2, 3).\"ein String mit Formatierung\", geben Sie , wo Sie den Wert mit dem Zeichen % einfügen möchten, das von einer optionalen Formatierungsinformation und dem erforderlichen Symbol, das den Typ des Wertes definiert, gefolgt wird. Die Typsymbole sinds für Zeichenketted für eine Ganzzahlf für einen Fließkommawertg für einen “optimal” gedruckten Fließkommawert, dass für große Werte die wissenschaftliche Notation verwendet wird (z.B., 10e5 statt 100000).Hier ist ein Beispiel, wie man einen String mit einer Ganzzahl formatiert:Sie sind nicht darauf beschränkt, einen einzigen Wert einen String einzufügen. Sie können weitere Positionen über % angeben, müssen jedoch sicherstellen, dass Sie die richtige Anzahl von Werten der richtigen Reihenfolge übergeben. Können Sie vor dem Ausführen herausfinden, welcher Aufruf tatsächlich funktioniert (und die Ausgabe sein wird) und welcher einen Fehler verursacht?Machen Sie Übung #10.Wie oben erwähnt, haben Sie im Falle von echten Werten zwei Möglichkeiten: %f und %g. Letzterer verwendet die wissenschaftliche Notation (z.B. 1e10 für 10000000000), um eine Darstellung kompakter zu machen.Machen Sie Übung #11, um ein besseres Gefühl für den Unterschied zu bekommen.Es gibt noch viel mehr zur Formatierung und Sie können auf pyformat.info darüber lesen. Diese Grundlagen sind jedoch ausreichend, um dem nächsten Kapitel mit der Programmierung unseres ersten Spiels zu beginnen.","code":"print(\"Ich hatte %d Pfannkuchen zum Frühstück\"%(10))\n#> Ich hatte 10 Pfannkuchen zum Frühstückprint('Ich hatte %d Pfannkuchen und entweder %d oder %d Steaks zum Abendessen'%(2))\nprint('Ich hatte %d Pfannkuchen und %d Steaks zum Abendessen'%(7, 10))\nprint('Ich hatte %d Pfannkuchen und %d Steaks zum Abendessen'%(1, 7, 10))"},{"path":"guess-the-number-single-round.html","id":"guess-the-number-single-round","chapter":"Kapitel 5 Errate die Zahl: eine einzelne Runden Edition","heading":"Kapitel 5 Errate die Zahl: eine einzelne Runden Edition","text":"Das vorherige Kapitel deckte die Grundlagen von Python ab, sodass Du nun bereit bist, Dein erstes Spiel zu entwickeln! Wir werden es Schritt für Schritt aufbauen, da es viel zu lernen gibt über Eingaben, Bibliotheken, bedingte Aussagen und Einrückungen.Bevor Du anfängst, erstelle einen neuen Ordner (innerhalb Deines Kursordners), benenne ihn zum Beispiel “guess--number”, lade das Übungsnotizbuch herunter, kopiere es den neu erstellten Ordner und öffne es Jupyter Notebook. Wie im vorherigen Kapitel wird es Übungen zum Lesen und Verstehen des Codes enthalten.Wir werden jedoch VS Code verwenden, um Skripte mit dem eigentlichen Spiel zu programmieren. Du musst für jede Code-Praxis eine separate Datei erstellen11 (z.B., code01.py12, code02.py, etc.) Dies ist nicht die effizienteste Implementierung einer Versionskontrolle und wird sicherlich den Ordner überladen. Aber es würde mir ermöglichen, Deine Lösungen für jeden Schritt zu sehen, es mir leichter machen würde, Feedback zu geben. Zum Einreichen der Aufgabe, zippe einfach den Ordner und reiche die Zip-Datei ein.","code":""},{"path":"guess-the-number-single-round.html","id":"konzepte-des-kapitels-1","chapter":"Kapitel 5 Errate die Zahl: eine einzelne Runden Edition","heading":"5.1 Konzepte des Kapitels","text":"Dokumentation des Codes.Debuggen von Code.Eingabe einer Eingabe von einem Benutzer.Verwendung von Vergleichen bedingten Aussagen.Verwendung von Einrückungen, um Aussagen zu gruppieren.Verwendung von Python Bibliotheken.Generieren von Zufallszahlen.","code":""},{"path":"guess-the-number-single-round.html","id":"das-spiel","chapter":"Kapitel 5 Errate die Zahl: eine einzelne Runden Edition","heading":"5.2 Das Spiel","text":"Wir werden ein Spiel programmieren, bei dem ein Teilnehmer (Computer) eine Zahl innerhalb eines bestimmten Bereichs auswählt (sagen wir, zwischen 1 und 10) und der andere Teilnehmer (menschlicher Spieler) versucht, diese zu erraten. Nach jedem Versuch des Menschen antwortet der Computer, ob die tatsächliche Zahl niedriger als die Vermutung ist, höher als die Vermutung ist oder mit ihr übereinstimmt. Das Spiel ist vorbei, wenn der Spieler die Zahl richtig errät oder (der späteren Version des Spiels) keine Versuche mehr hat.Unsere erste Version wird nur einen Versuch zulassen und der Gesamtspielalgorithmus wird folgendermaßen aussehen:der Computer generiert eine Zufallszahl zwischen 1 und 10druckt sie aus für Debugging-Zweckefordert den Benutzer auf, eine Vermutung einzugebenvergleicht die beiden Zahlen und gibt das Ergebnis aus: “Meine Zahl ist niedriger”, “Meine Zahl ist höher” oder “Genau richtig!”","code":""},{"path":"guess-the-number-single-round.html","id":"lass-uns-eine-zahl-auswählen","chapter":"Kapitel 5 Errate die Zahl: eine einzelne Runden Edition","heading":"5.3 Lass uns eine Zahl auswählen","text":"Beginnen wir damit, nur die ersten zwei Schritte des Programms zu implementieren. Erstelle zuerst eine Variable, die eine Zahl enthält, die der Computer “ausgesucht” hat. Wir nennen sie number_picked (Du kannst auch einen anderen aussagekräftigen Namen verwenden, aber es könnte einfacher sein, wenn wir alle den gleichen Namen verwenden). Um die Dinge Anfang einfacher zu machen, codieren wir eine beliebige Zahl zwischen 1 und 10 hart (wähle die, die Dir gefällt). Dann lass uns diese ausdrucken, dass wir die Zahl selbst kennen13. Verwende die Zeichenkettenformatierung, um die Dinge benutzerfreundlich zu gestalten, z. B. drucke etwas aus wie “Die Zahl, die ich ausgewählt habe, ist …”. Du solltest der Lage sein, dies mit dem Wissen aus dem vorherigen Kapitel zu tun. Dein Code sollte aus zwei Zeilen bestehen:Probiere diesen Zweizeiler einem Jupyter Notebook aus (erstelle ein leeres Notebook nur dafür). Wenn Du damit zufrieden bist, kopiere-den Code code01.py und lies weiter, um zu erfahren, wie Du es dokumentieren und ausführen kannst.Füge Deinen Code code01.py ein.","code":"# 1. erstelle Variable und setze ihren Wert\n# 2. gebe den Wert aus"},{"path":"guess-the-number-single-round.html","id":"dokumentiere-deinen-code-1","chapter":"Kapitel 5 Errate die Zahl: eine einzelne Runden Edition","heading":"5.4 Dokumentiere Deinen Code","text":"Jetzt, wo Du Deine erste Datei mit einem Python-Programm hast, solltest Du es dokumentieren. Die Dokumentation eines zwei Zeilen langen und einfachen Programms mag albern erscheinen, aber es sollte etwas Automatisches sein. Später wirst Du mehrere Zeilen Kommentare verwenden, um eine einzelne Zeilenfunktion zu dokumentieren. Noch einmal, es geht nicht um den Code, der funktioniert, es geht um den Code, den Du verstehen kannst. gewisser Weise ist es besser, ein sauberes, gut dokumentiertes Programm zu haben, das momentan nicht korrekt funktioniert, als einen undokumentierten Spaghetti-Code, der funktioniert. Du kannst das Erstere korrigieren und aktualisieren, das Letztere zu warten oder zu aktualisieren…Python hast Du zwei Möglichkeiten, Kommentare zu schreiben: mehrzeilig und einzeiligVerwende mehrzeilige Kommentare, um die Dokumentation für einzelne Dateien, Funktionen, Klassen, Methoden usw. zu schreiben. Du wirst lernen, wie Du diese Dokumentation im Numpy-Docstring-Stil formatierst, sobald Du Funktionen kennst. unserem Fall solltest Du Deine code01.py-Datei mit einem mehrzeiligen Kommentar beginnen, der kurz beschreibt, welches Programm sie enthält. Mindestens solltest Du schreiben, dass dies ein Guess Number-Spiel ist. Wahrscheinlich ist es eine gute Idee, zu skizzieren, worum es dem Spiel geht.Verwende einzeilige Kommentare, um zu erklären, einem bestimmten Codeblock passiert. Du musst nicht jede Zeile kommentieren und Du solltest den Code nicht menschlicher Sprache replizieren. Ein Kommentar sollte darüber sein, passiert, nicht wie. Du hast bereits einen Block Code, also dokumentiere ihn mit einem einzelnen Satz.Dokumentiere die code01.py.","code":"'''Ein \nmehrzeiliger \nKommentar\n'''\n\n#  Ein einzeiliger Kommentar."},{"path":"guess-the-number-single-round.html","id":"debugging","chapter":"Kapitel 5 Errate die Zahl: eine einzelne Runden Edition","heading":"5.5 Ausführen und Debuggen deines Spiels in VS Code","text":"Jetzt, da wir ein zwei Zeilen langes Programm haben, können wir es ausführen und schon anfangen zu lernen, wie man es debuggt. Ja, unser aktuelles Programm ist wahrscheinlich zu einfach, um ein tatsächliches Debugging zu benötigen, aber es ist auch einfach genug, um das Verständnis des Debuggings zu erleichtern. Und das Debuggen ist eine entscheidende Fähigkeit, die ein laufendes Programm von einer Blackbox etwas transparentes und leichtes14 zu verstehen verwandelt. Weiter unten werde ich beschreiben, wie man VS Code debuggt, aber du könntest ein offizielles Handbuch zu Rate ziehen, falls sich der Zwischenzeit etwas geändert hat.Es gibt zwei Möglichkeiten, ein Python-Programm VS Code auszuführen. Zuerst kannst Du den “Run Python File Terminal” Abspielknopf auf der rechten Seite verwenden. Dies führt dein Programm ohne Debugger aus, dass Du es nur für die tatsächlichen Läufe des finalisierten Codes verwenden solltest. Trotzdem kannst Du versuchen, es auszuführen und zu sehen, ob es das ausgibt, es sollte.\nDie Alternative ist der Debugging-Reiter, der eine kleine Wanze auf dem Run-Knopf hat. Wenn Du ihn auswählst, wird “Run Debug” angezeigt. Klicke auf den Knopf und es werden verschiedene Optionen für verschiedene Arten von Python-Projekten und -Frameworks angeboten. Für unsere Absichten und Zwecke benötigen wir nur “Python File: Debug currently active Python file”. Klicke darauf und es wird Deinen Code ausführen (sollte genau laufen wie mit dem anderen Knopf).Du willst wahrscheinlich nicht die ganze Zeit durch Debugging-Tab → Run Debug-Knopf → Konfiguration auswählen klicken. Ein besserer Weg ist es, es einmal für alle zu konfigurieren und dann die F5-Taste zu verwenden, um Deinen Code auszuführen. Klicke zunächst auf “Erstelle eine launch.json-Datei” und wähle erneut “Python File: Debug currently active Python file” aus. Du wirst sehen, dass eine neue launch.json Datei im Editor erscheint, die aussehen sollte:Das war’s! VS Code hat für Dich eine Konfiguration erstellt. Jetzt kannst Du die launch.json-Datei schließen und Dein Programm durch einfaches Drücken der F5-Taste ausführen. Versuch es! Wieder einmal sollte es genauso funktionieren wie zuvor, aber warum sind wir dann durch diese Mühe gegangen? Weil der Debugger die Ausführung Deines Codes pausiert, wann immer er auf ein Problem trifft und Dir die Chance gibt, Variablen zu untersuchen, Code-Snippets auszuführen usw. Im Gegensatz dazu wird das Ausführen der Python-Datei im Terminal (die erste Option) nur eine Fehlermeldung ausgeben und das Programm beenden. Außerdem kannst Du Breakpoints verwenden, um das Programm jeder Zeile anzuhalten, Dir die Möglichkeit gibt, Deinen Code jeder Stelle, die Du benötigst, zu untersuchen.Du aktivierst Breakpoints, indem Du links von der Zeilennummer, die Dich interessiert, klickst. Hier habe ich auf Zeile 6 geklickt und Du kannst einen roten Punkt sehen, der einen aktiven Breakpoint anzeigtWenn ich jetzt den Code über F5 ausführe, hält das Programm dieser Zeile bevor es sie ausführt.Das gibt mir die Möglichkeit zu sehen, welchen Wert meine Variable number_picked hat. Sie ist bereits den lokalen Variablen aufgeführt (oben links). Aber ich habe sie auch zur Liste der beobachteten Variablen (Watch, links der Mitte) hinzugefügt und mir ihren Wert der Debug Console (unten) angesehen, die es mir ermöglicht, beliebigen Python-Code auszuführen, während mein Programm angehalten ist. Mach das Gleiche und erkunde selbst diese unterschiedlichen Möglichkeiten. Sieh zum Beispiel, wie du number_picked + 1 oder number_picked * number_picked im Watch Tab und der Debug Console berechnen kannst.Sobald du fertig bist, den aktuellen Zustand des Programms zu untersuchen, hast du sechs Buttons oben zur Verfügung, um zu entscheiden, als nächstes zu tun ist (fahre mit der Maus darüber, um Hinweise zu sehen). Sie sind, von links nach rechtsFortfahren (F5): Setze das Programm fort.Step (F10): Führt den Code aus, ohne Funktionen zu gehen (diese und die beiden folgenden Optionen werden klarer, sobald du lernst, Funktionen zu schreiben).den Code hineinsteigen (F11)Aus dem Code heraussteigen (Shift+F11).Das Programm neu starten (Ctrl+Shift+F5).Das Programm stoppen (Shift+F5).Um besser zu verstehen, wie das funktioniert, stoppe das Programm (Shift+F5) und setze einen zusätzlichen Haltepunkt die erste Zeile deines Codes (Zeile #5 meinem Programm, die anderen Zeilen sind Kommentare oder leer). Führe das Programm wieder über F5 aus und es wird dieser ersten Zeile pausieren. Kannst du jetzt den Wert der Variable number_picked ermitteln?Die Antwort lautet “nein”, weil diese Variable noch nicht existiert. Denke daran, das Programm pausiert vor dem Ausführen der Zeile. Benutze F10, um Schritt für Schritt durch den Code zu gehen und zu sehen, wie die Variable erscheint und die Information ausgegeben wird.Diese Debugging-Übung war vielleicht nicht notwendig, um Probleme mit deinem aktuellen Code zu lösen, aber sie hat gezeigt, wie das der Zukunft funktioniert. Zögere nicht, einen Haltepunkt zu setzen, um das Programm zu pausieren und zu überprüfen, ob die Realität (d.h. die tatsächlichen Werte der Variablen) deinen Erwartungen entspricht. Nutze das Durchlaufen des Codes, um die Dinge zu verlangsamen und zu beobachten und zu überlegen.","code":""},{"path":"guess-the-number-single-round.html","id":"input-function","chapter":"Kapitel 5 Errate die Zahl: eine einzelne Runden Edition","heading":"5.6 Einen Spieler nach einer Vermutung fragen","text":"Um das Spiel Guess Number zu spielen, braucht es zwei. Der Computer hat seinen Teil erledigt, indem er eine Zahl ausgewählt hat, jetzt müssen wir einen Spieler bitten, seine Vermutung einzugeben. Dafür verwenden wir die input() Funktion.Eine Funktion ist ein isolierter Code, der (optionale) Eingaben akzeptiert, eine Aktion ausführt und optional einen Wert (Ausgabe) zurückgibt. Dies ermöglicht einerseits, den Code kleinere Blöcke zu unterteilen, die einfacher zu warten sind und andererseits, den gleichen Code wiederzuverwenden. Du hast bereits die print() Funktion verwendet, um Dinge auszudrucken, und die str(), bool(), int() und float() Funktionen, um Werte zu konvertieren. Bei der print() Funktion ist die Eingabe eine beliebige Anzahl von Werten (sogar keine, probiere das Jupiter Notebook aus!), ihre Aktion ist es, Dinge auszudrucken, aber sie gibt nichts zurück (keine Ausgabe). Die float() Funktion nimmt (etwas überraschend) null oder einen Wert als Eingabe (versuche, ihr keinen oder mehr als einen Jupiter Notebook zu geben und sieh den Unterschied), versucht, den gegebenen Wert float zu konvertieren (wirft einen Fehler, wenn sie das nicht kann), und gibt einen float-Wert als Ausgabe zurück.Ein ähnliches Eingabe → Aktion → Ausgabe Schema gilt für die input(prompt) Funktion. Sie akzeptiert optional einen prompt String als Eingabe. Dann druckt sie die prompt Nachricht aus und wartet darauf, dass ein Benutzer einen String eingibt, bis dieser Enter drückt. Dann gibt sie diesen String-Wert zurück. Dieser letzte Punkt über den String ist wichtig, denn unserem Spiel müssen die Spieler eine ganze Zahl und keinen String eingeben. Gehen wir für einen Moment davon aus, dass die Eingabe immer eine gültige Ganzzahl ist, also gib nur gültige Ganzzahlen ein, wenn du das Programm testest! Auf diese Weise können wir sie ohne zusätzliche Prüfungen (die wir der Zukunft hinzufügen werden) eine Ganzzahl umwandeln und dieser Wert einer neuen Variable namens guess zuweisen. Du musst also eine einzelne Zuweisungsanweisung mit der guess Variablen auf der linken Seite und dem Aufruf der input() Funktion auf der rechten Seite hinzufügen (denke eine schöne Aufforderungsnachricht), eingehüllt (innerhalb) der Typumwandlung eine Ganzzahl über int(). Teste diesen Code, aber gib wieder nur gültige Ganzzahlen ein, damit die Umwandlung ohne Fehler funktioniert.Aktualisiere deine code01.py","code":""},{"path":"guess-the-number-single-round.html","id":"if-statement","chapter":"Kapitel 5 Errate die Zahl: eine einzelne Runden Edition","heading":"5.7 Bedingte if-Anweisung","text":"Jetzt haben wir zwei Zahlen: Eine, die der Computer ausgewählt hat (number_picked), und eine, die der Spieler eingegeben hat (guess). Wir müssen sie vergleichen, um die korrekte Ausgabemeldung zu liefern. Dafür verwenden wir die bedingte -Anweisung:Nur der -Teil ist erforderlich, während elif (kurz für “else, ”) und else optional sind. kannst du etwas tun, nur wenn eine Bedingung wahr ist:Bevor wir bedingte Anweisungen unserem Spiel verwenden können, musst du (1) die Bedingungen selbst und (2) die Verwendung von Einrückungen als Mittel zur Gruppierung von Anweisungen verstehen.","code":"if eine_Bedingung_ist_wahr:\n    # Tu etwas\nelif eine_andere_Bedingung_ist_wahr:\n    # Tu etwas anderes\nelif noch_eine_andere_Bedingung_ist_wahr:\n    # Tu noch etwas anderes\nelse:\n    # Tu etwas nur, wenn alle Bedingungen oben falsch sind.if eine_Bedingung_ist_wahr:\n    # Tu etwas, aber ANSONSTEN TU NICHTS \n    # und fahre mit der Codeausführung fort\n  \n# Einige Codezeilen, die nach der if-Anweisung ausgeführt werden,\n# unabhängig davon, ob die Bedingung wahr war oder nicht."},{"path":"guess-the-number-single-round.html","id":"comparisons","chapter":"Kapitel 5 Errate die Zahl: eine einzelne Runden Edition","heading":"5.8 Bedingungen und Vergleiche","text":"Eine Bedingung ist jeder Ausdruck, der überprüft werden kann, um zu sehen, ob er True oder False ist. Ein einfaches Beispiel für einen solchen Ausdruck sind Vergleiche, die menschlicher Sprache ausgedrückt werden als: Ist heute Donnerstag? Ist die Antwort (gleich) 42? Regnet es und habe ich einen Regenschirm? Wir werden uns für einen Moment auf solche Vergleiche konzentrieren, aber später wirst Du sehen, dass Python jeder Ausdruck entweder True oder False ist, auch wenn er nicht wie ein Vergleich aussieht15.Für den Vergleich kannst Du die folgenden Operatoren verwenden:“ist gleich B” wird geschrieben als == B.“ist nicht gleich B” wird geschrieben als != B.“ist größer als B” und “ist kleiner als B” sind entsprechend > B und < B.“ist größer als oder gleich B” und “ist kleiner als oder gleich B” sind entsprechend >= B und <= B (bitte beachte die Reihenfolge der Symbole, da => und =< einen Fehler erzeugen werden).Löse einige Vergleiche Übung #1.Beachte, dass Python auch einen Operator hat, der identisch mit == aussehen kann (z.B. sieht x == 2 äquivalent zu x 2 aus). Darüber hinaus funktioniert er einigen Fällen auch auf die gleiche Weise. Es gibt jedoch einen subtilen Unterschied: == überprüft, ob Werte identisch sind, während überprüft, ob Objekte (die “Werte halten”) identisch sind. Du musst Klassen und Objekte verstehen, bevor Du diesen Unterschied schätzen kannst, also behalte vorerst im Hinterkopf, dass Du nur == verwenden solltest (ich werde explizit erwähnen, wann benötigt wird).Du kannst den logischen Wert mit dem Operator invertieren, da True False und False True ist. Das bedeutet, dass != B dasselbe ist wie == B und entsprechend ist == B != B. Um zu sehen, wie das funktioniert, betrachte beide Fälle, wenn tatsächlich gleich B ist und wenn es nicht ist.Wenn gleich B ist, dann ergibt == B True. Das != B ist dann False, also != B → False → True.Wenn nicht gleich B ist, dann ergibt == B False. Das != B ist dann True, also != B → True → False.Überprüfe diese Inversion selbst Übung #2.Du kannst auch mehrere Vergleiche mit den Operatoren und/oder16 kombinieren. Wie der menschlichen Sprache bedeutet , dass beide Teile wahr sein müssen: True True → True, aber True False → False, False True → False, und False False → False. Dasselbe gilt, wenn Du mehr als zwei Bedingungen/Vergleiche über verknüpfst: Alle müssen wahr sein. Im Fall von muss nur eine der Aussagen wahr sein, z.B. True True → True, True False → True, False True → True, aber False False → False. Auch hier gilt für mehr als zwei Vergleiche/Bedingungen, dass mindestens eine von ihnen wahr sein sollte, damit der gesamte Ausdruck wahr ist.Mache die Übungen #3 und #4.Ein subtiler, aber wichtiger Punkt: Bedingungen werden von links nach rechts ausgewertet, bis der gesamte Ausdruck auf die eine oder andere Weise aufgelöst ist. Das bedeutet, dass wenn der erste Ausdruck einem False ist, der zweite (der Rest von ihnen) nie ausgewertet wird. D.h., wenn sowohl erster als auch zweiter Ausdruck True sein müssen und Du weißt, dass erster Ausdruck bereits False ist, ist der gesamte Ausdruck jedem Fall False. Das bedeutet, dass es im folgenden Code keinen Fehler geben wird, obwohl die Auswertung von int(\"e123\") allein einen ValueError auslösen würde.Umkehrst Du jedoch die Reihenfolge, dass int(\"e123\") == 123 zuerst ausgewertet werden muss, erhältst Du eine FehlermeldungÄhnlich verhält es sich, wenn bei irgendein Ausdruck True ist, musst Du den Rest nicht überprüfen.Ist die erste Bedingung jedoch False, müssen wir fortfahren (und stolpern dabei über einen Fehler):Mache Übung #5.Schließlich kannst Du, wie der einfachen Arithmetik, Klammern () verwenden, um Bedingungen zu gruppieren. kann die Aussage “Ich esse immer Schokolade, aber ich esse Spinat nur, wenn ich hungrig bin” wie folgt geschrieben werden: food == \"chocolate\" (food == \"spinach\" hungry). Hier werden food == \"chocolate\" und food == \"spinach\" hungry unabhängig voneinander ausgewertet, ihre Werte werden ihrer Stelle eingesetzt und dann wird die -Bedingung ausgewertet.Mache Übung #6.Ein letzter Gedanke zu Vergleichen: Zögere nicht, sie Jupyter Notebook mit verschiedenen Kombinationen von Werten zu testen oder das Programm der Bedingung über einen Haltepunkt anzuhalten und einen Vergleich Watch oder Debug Console auszuwerten.","code":"2 * 2 == 5 and int(\"e123\") == 123\n#> Falseint(\"e123\") == 123 and 2 * 2 == 4\n#> invalid literal for int() with base 10: 'e123'2 * 2 == 4 or int(\"e123\") == 123\n#> True2 * 2 == 5 or int(\"e123\") == 123\n#> invalid literal for int() with base 10: 'e123'"},{"path":"guess-the-number-single-round.html","id":"indentation","chapter":"Kapitel 5 Errate die Zahl: eine einzelne Runden Edition","heading":"5.9 Gruppieren von Anweisungen über Einrückungen","text":"Lass uns zu einer bedingten -Anweisung zurückkehren. Sieh dir das folgende Codebeispiel (und beachte ein : Ende von some_condition_is_true:), dem Anweisung #1 nur ausgeführt wird, wenn eine Bedingung wahr ist, während Anweisung #2 danach ausgeführt wird, unabhängig von der Bedingung.Beide Aussagen #1 und #2 folgen nach der -Anweisung. Aber wie erkennt Python, dass die erste nur ausgeführt wird, wenn die Bedingung wahr ist, und die andere immer ausgeführt wird? Die Antwort ist Einrückung: Die 4 (vier!) Leerzeichen, die automatisch hinzugefügt werden, wenn du VS Code auf Tab drückst und entfernt werden, wenn du auf Shift+Tab drückst. Die Einrückung platziert Anweisung #1 innerhalb der -Anweisung. Daher zeigt die Einrückung , ob Anweisungen zur gleichen Gruppe gehören und nacheinander ausgeführt werden müssen (gleiche Einrückungsebene für und Anweisung #2) oder sich innerhalb einer bedingten Anweisung, Schleife, Funktion, Klasse usw. befinden (Anweisung #1). Für komplexeren Code, der zum Beispiel eine -Anweisung innerhalb einer -Anweisung innerhalb einer Schleife haben wird, drückst du dies aus, indem du weitere Ebenen der Einrückung hinzufügst. Zum Beispiel:Achte sehr genau auf die Einrückung, denn sie bestimmt, welche Anweisungen zusammen ausgeführt werden! Ein falscher Einrückungsgrad ist leider ein sehr häufiger Fehler.Mache Übung #7.Die und ifelse Anweisungen werden lange ausgewertet, bis eine von ihnen sich als True herausstellt. Danach werden alle folgenden ifelse und else Anweisungen einfach ignoriert.Mache Übung #8.","code":"if some_condition_is_true:\n    Anweisung #1\nAnweisung #2 # einige Anweisungen außerhalb der Schleife (0 Einrückung)\nwhile Spiel_ist_nicht_vorbei: # (0 Einrückung)\n    # Anweisungen innerhalb der Schleife\n    if Taste_gedrückt: # (Einrückung von 4)\n        # innerhalb der Schleife und if-Anweisung\n        if Taste == \"Space\": # (Einrückung von 8)\n            # innerhalb der Schleife, if-Anweisung und einer weiteren if-Anweisung\n            springen() # (Einrückung von 12)\n        else: # (Einrückung von 4)\n            # innerhalb der Schleife, if-Anweisung und im sonst-Teil einer weiteren if-Anweisung\n            stehen() # (Einrückung von 12)\n\n    # Anweisungen innerhalb der Schleife, aber außerhalb der äußersten if-Anweisung\n    drucke(Taste) # (Einrückung von 4)\n\n# einige Anweisungen außerhalb der Schleife (0 Einrückung)"},{"path":"guess-the-number-single-round.html","id":"überprüfung-der-antwort","chapter":"Kapitel 5 Errate die Zahl: eine einzelne Runden Edition","heading":"5.10 Überprüfung der Antwort","text":"Jetzt hast du alle notwendigen Werkzeuge, um die erste Version unseres Spiels zu beenden. Füge deinem code01.py bedingte Anweisungen hinzu, dasswenn die Computerwahl kleiner als die Vermutung des Spielers ist, druckt es \"Meine Zahl ist niedriger!\"wenn die Computerwahl größer als die Vermutung des Spielers ist, druckt es \"Meine Zahl ist höher!\"wenn die beiden Zahlen identisch sind, druckt es \"Volltreffer!\"Speichere zunächst eine Kopie deines ursprünglichen Codes code02.py und füge dann den Vergleich und das Drucken hinzu.\n::: {.program}\nErweitere dein Programm mit dem Vergleich code02.py\n:::Teste, ob dein Code funktioniert. Nutze wieder Breakpoints, wenn du den Kontrollfluss besser verstehen und überprüfen möchtest, ob die Vergleiche funktionieren, wie du es erwartest.","code":""},{"path":"guess-the-number-single-round.html","id":"using-libraries","chapter":"Kapitel 5 Errate die Zahl: eine einzelne Runden Edition","heading":"5.11 Verwenden von Bibliotheken","text":"Unser Spiel ist “funktionsvollständig”: der Computer wählt eine Zahl, der Spieler macht eine Vermutung, der Computer reagiert entsprechend. Derzeit spielen wir jedoch für beide Seiten. Lass uns den Computer selbst eine zufällige Zahl auswählen. Dafür müssen wir die Funktion randint(, b) verwenden. Sie ist Teil jeder Python-Distribution, dass du sie auch hättest, wenn du eine einfache Python-Distribution installierst, anstatt eine von PsychoPy zu verwenden. Du kannst sie jedoch nicht sofort verwenden, wie du es mit print() oder input() getan hast. Gib randint(1, 3) dein Jupyter Notebook ein und beobachte den NameError: name ‘randint’ defined.Der Grund dafür ist, dass Python unglaublich viele Funktionen hat und das Laden aller gleichzeitig den Speicher mit Dingen verstopfen würde, die du nie zu verwenden beabsichtigt hast. Stattdessen sind sie Bibliotheken verpackt, dass du nur die Funktionen (oder Bibliotheken) importieren kannst, die du tatsächlich für dein Programm benötigst. Du importierst sie über eine import-Anweisung, die den Anfang deiner Datei gehört (aber unter dem Kommentar zum Inhalt der Datei). Es gibt mehrere Möglichkeiten, wie du Bibliotheken importieren kannst. Erstens kannst du eine gesamte Bibliothek importieren (wie zum Beispiel die random Bibliothek, die die Funktion randint() hat, die wir benötigen) und dann ihre Funktionen als <Bibliothek>.<Funktion> verwenden. Für randint wäre dasIch würde dies als bevorzugte Art der Verwendung von Bibliotheken empfehlen, da es dich zwingt, den Namen der Bibliothek explizit zu erwähnen, wenn du eine Funktion aufrufst, d.h. random.randint() statt nur randint(). Dies mag nicht wichtig erscheinen, wenn nur eine Bibliothek importiert wird, aber selbst einem moderat großen Projekt wirst du viele Bibliotheken importieren, dass es schwierig wird herauszufinden, zu welcher Bibliothek die Funktion gehört. Noch wichtiger ist, dass verschiedene Bibliotheken Funktionen mit demselben Namen haben können. diesem Fall stammt die Funktion, die du verwendest, aus der letzten Bibliothek, die du importiert hast. Aber du wirst das vielleicht nicht bemerken und dies ist eine Art von Fehler, der wirklich schwer aufzuspüren ist. Importiere also immer die gesamte Bibliothek und verwende die Bibliothek. Notation, es sei denn, du hast einen sehr guten Grund, etwas anderes zu tun!Eine weitere und weniger explizite Option besteht darin, nur einige Funktionen zu importieren und sie ohne den library. Präfix zu verwenden. Du kannst mehr als eine Funktion importieren, indem du sie alle auflistest.Du kannst auch eine Bibliothek oder eine Funktion beim Importieren über umbenennen. Kurz gesagt, solltest du dies nicht tun, da die Verwendung eines anderen Namens für eine Bibliothek oder eine Funktion es anderen (und sogar dem zukünftigen Du) erschweren würde, deinen Code zu verstehen. Es gibt jedoch einige “standardmäßige” Umbenennungsmuster, die universell verwendet werden und auf die du wahrscheinlich stoßen wirst.Zum Schluss gibt es noch eine sehr schlechte Möglichkeit, Funktionen aus einer Bibliothek zu importieren: random import *. Das Sternchen bedeutet, dass du alle Funktionen aus der Bibliothek importieren möchtest und sie ohne random. Präfix aufrufen möchtest. Tu das niemals, niemals, niemals17! Dadurch wird deine Umgebung mit Funktionen gefüllt, von denen du vielleicht nichts weißt, die möglicherweise andere Funktionen überschreiben, Konflikte verursachen etc. Niemals! Ich zeige dir das nur, weil du irgendwann einen Code sehen wirst, der diesen Ansatz verwendet, und du könntest denken, dass das eine gute Idee ist. Es ist eine schreckliche Idee! Importiere die Bibliothek, nicht die Funktionen, damit du explizit zeigen kannst, auf welche Bibliothek du dich verlässt, wenn du eine Funktion aufrufst. Denke immer den Zen Python: “Explizit ist besser als implizit.”","code":"import random\n\ncomputer_wahl = random.randint(1, 5)from random import randint, randrange\n\ncomputer_wahl = randint(1, 5)# dies ist die übliche Art, diese zwei Bibliotheken zu importieren\nimport numpy as np\nimport pandas as pd\n\nnp.abs(-1)\n\n# du kannst auch einzelne Funktionen umbenennen, wenn du unbedingt musst (aber bitte nicht!)\nfrom random import randint as zufalls_zahl\n\ncomputer_wahl = zufalls_zahl(1, 5)"},{"path":"guess-the-number-single-round.html","id":"eine-zufallszahl-auswählen","chapter":"Kapitel 5 Errate die Zahl: eine einzelne Runden Edition","heading":"5.12 Eine Zufallszahl auswählen","text":"Jetzt wo du weißt, wie man eine Bibliothek importiert, können wir die Funktion randint() verwenden. Speichere dafür eine Kopie deines vorherigen Codes code03.py. Importiere die Bibliothek und verwende randint(), um eine Zufallszahl zwischen 1 und 10 zu generieren. Lese die Dokumentation zu randint(), um zu verstehen, wie man es verwendet. Das Lesen von Handbüchern ist ein notwendiger Teil des Programmierens, also ist dies ein guter Zeitpunkt, um das Üben zu beginnen.Sobald du dies code02.py implementiert hast, führe es mehrmals aus, um zu überprüfen, dass der Computer tatsächlich unterschiedliche Zufallswerte auswählt. Verwende erneut Breakpoints, wenn du genau überprüfen möchtest, passiert.Gib deinen Code code03.py ein.Herzlichen Glückwunsch, du hast gerade dein erstes Computerspiel programmiert! Ja, es ist sehr einfach, aber es hat die Schlüsselzutaten: eine zufällige Entscheidung des Computers, Benutzereingabe und Feedback. Beim nächsten Mal wirst du über Schleifen lernen, um mehrere Versuche zu ermöglichen, und wirst damit beginnen, Funktionen zu schreiben, um deinen Code modular und zuverlässig zu machen. der Zwischenzeit vertiefen wir dein Wissen, indem wir noch ein Spiel programmieren!","code":""},{"path":"guess-the-number-single-round.html","id":"einarmiger-bandit-einzelrundenedition","chapter":"Kapitel 5 Errate die Zahl: eine einzelne Runden Edition","heading":"5.13 Einarmiger Bandit (Einzelrundenedition)","text":"Du weißt alles, du brauchst, um eine einfache Version eines “Einarmigen Banditen”-Spiels zu programmieren. Hier ist die Spiellogik:Importiere die Zufallsbibliothek, damit du die Funktion randint verwenden kannst.Generiere drei zufällige Ganzzahlen (sagen wir, zwischen 1 und 5) und speichere sie drei Variablen slot1, slot2 und slot3.Drucke die Zahlen aus, verwende die String-Formatierung, um sie schön aussehen zu lassen.Zusätzlich,\nwenn alle drei Werte gleich sind, drucke \"Dreierpasch!\".\nWenn nur zwei Zahlen übereinstimmen, drucke \"Paar!\".\nDrucke nichts, wenn alle Zahlen unterschiedlich sind.\nwenn alle drei Werte gleich sind, drucke \"Dreierpasch!\".Wenn nur zwei Zahlen übereinstimmen, drucke \"Paar!\".Drucke nichts, wenn alle Zahlen unterschiedlich sind.Vergiss nicht, die neue Datei code03.py zu dokumentieren und verwende Breakpoints, um sie zu debuggen, wenn du möchtest.Gib deinen Code code04.py ein.","code":""},{"path":"guess-the-number-single-round.html","id":"abgabe-für-das-seminar","chapter":"Kapitel 5 Errate die Zahl: eine einzelne Runden Edition","heading":"5.14 Abgabe für das Seminar","text":"Für das Seminar gib einen gezippten Ordner mit dem Übungs-Notebook und allen vier Programmen ab.","code":""},{"path":"guess-the-number-multi-round.html","id":"guess-the-number-multi-round","chapter":"Kapitel 6 Errate die Zahl: Eine Mehr-Runden-Ausgabe","heading":"Kapitel 6 Errate die Zahl: Eine Mehr-Runden-Ausgabe","text":"Im vorherigen Kapitel hast Du ein “Guess Number”-Spiel programmiert, das nur einen einzigen Versuch erlaubt. Jetzt werden wir es erweitern, um mehrere Versuche zu ermöglichen und werden andere Extras hinzufügen, um es noch spannender zu machen. Erstelle einen neuen Unterordner und lade das Übungs-Notebook herunter, bevor wir beginnen!","code":""},{"path":"guess-the-number-multi-round.html","id":"konzepte-des-kapitels-2","chapter":"Kapitel 6 Errate die Zahl: Eine Mehr-Runden-Ausgabe","heading":"6.1 Konzepte des Kapitels","text":"Wiederholen von Code mit Schleife.Machen Notausgang aus einer Schleife.","code":""},{"path":"guess-the-number-multi-round.html","id":"while-loop","chapter":"Kapitel 6 Errate die Zahl: Eine Mehr-Runden-Ausgabe","heading":"6.2 While-Schleife","text":"Wenn Du etwas wiederholen möchtest, musst Du Schleifen verwenden. Es gibt zwei Arten von Schleifen: die Schleife, welche wiederholt wird, während eine Bedingung wahr ist, und die Schleife, die über Elemente iteriert (wir werden sie später verwenden).Die grundlegende Struktur einer -Schleife istDie <Bedingung> hier ist ein Ausdruck, der entweder True oder False ergibt, genau wie einer ...elif...else Bedingungsanweisung. Auch gelten dieselben Einrückungsregeln, die bestimmen, welcher Code innerhalb der Schleife und welcher außerhalb ist.Mache Übung #1.Lass uns die -Schleife verwenden, um dem Spieler zu erlauben, weiter zu raten, bis er es endlich richtig hat. Du kannst den Code, den Du während des letzten Seminars programmiert hast, kopieren und einfügen oder Du kannst ihn von Grund auf neu erstellen (ich würde Dir dringend empfehlen, Letzteres zu tun!). Die allgemeine Programmstruktur sollte folgende seinSpeichere deinen Code code01.py.Vergiss nicht, die Datei zu dokumentieren und Breakpoints und Step overs zu verwenden, um den Programmfluss zu erkunden.","code":"# Anweisungen vor der Schleife\n\nwhile <Bedingung>:\n    # die inneren Anweisungen werden\n    # so lange ausgeführt, wie\n    # die Bedingung wahr ist\n    \n# Anweisungen nach der Schleife# importiere die Zufallsbibliothek, damit du die randint Funktion verwenden kannst\n\n# generiere eine zufällige Zahl und speichere sie in der Variablen number_picked\n# hole die Eingabe des Spielers, konvertiere sie in eine Ganzzahl und speichere sie in der Variablen guess\n\n# während die Vermutung des Spielers nicht gleich dem Wert ist, den der Computer ausgewählt hat:\n    # gib \"meine Zahl ist kleiner\" oder \"meine Zahl ist größer\" aus, indem Du die if-else Anweisung verwendest\n    # hole die Eingabe des Spielers, konvertiere sie in eine Ganzzahl und speichere sie in der Variablen guess\n    \n# gib \"Ganz genau!\" aus \n# (denn wenn wir hier angekommen sind, bedeutet das, dass die Vermutung gleich der Wahl des Computers ist)"},{"path":"guess-the-number-multi-round.html","id":"versuche-zählen","chapter":"Kapitel 6 Errate die Zahl: Eine Mehr-Runden-Ausgabe","heading":"6.3 Versuche zählen","text":"Jetzt fügen wir eine Variable hinzu, die die Gesamtzahl der Versuche des Spielers zählt. Dazu erstelle eine neue Variable (nennen wir sie attempts oder ähnliches) vor der Schleife und initialisiere sie mit 1 (weil der erste Versuch vor dem Betreten der Schleife vom Spieler gemacht wird). Füge jedes Mal, wenn der Spieler eine Vermutung eingibt, 1 hinzu. Erweitern Sie nach der Schleife die Nachricht \"Ganz genau!\" um Informationen über die Anzahl der Versuche. Nutze String-Formatierung, um alles schön aussehen zu lassen, z.B.: \"Ganz genau und du hast nur 5 Versuche gebraucht!\". Überprüfe, ob die Anzahl der benötigten Versuche mit der Anzahl der vom Programm gemeldeten Versuche übereinstimmt!Speichere deinen Code code02.py.","code":""},{"path":"guess-the-number-multi-round.html","id":"break","chapter":"Kapitel 6 Errate die Zahl: Eine Mehr-Runden-Ausgabe","heading":"6.4 Abbruch (und Ausstieg)","text":"Der Code innerhalb der -Schleife wird wiederholt ausgeführt, während die Bedingung True ist und, wichtig ist, der gesamte Code innerhalb wird ausgeführt, bevor die Bedingung erneut bewertet wird. Manchmal musst du jedoch früher abbrechen, ohne den verbleibenden Code auszuführen. Dafür hat Python eine break Anweisung, die dazu führt, dass das Programm die Schleife sofort verlässt, ohne den Rest des Codes innerhalb der Schleife auszuführen, dass das Programm mit dem Code nach der Schleife fortfährt.Mache Übung #2, um dein Verständnis zu vertiefen.","code":"# dieser Code wird vor der Schleife ausgeführt\n\nwhile <irgendeine_Bedingung>:\n  # dieser Code wird bei jeder Iteration ausgeführt\n  \n    if <irgendeine_andere_Bedingung>:\n        break\n  \n  # dieser Code wird bei jeder Iteration ausgeführt, aber nicht, wenn du aus der Schleife herausbrichst\n\n# dieser Code wird nach der Schleife ausgeführt"},{"path":"guess-the-number-multi-round.html","id":"begrenzung-der-anzahl-der-versuche-mittels-break","chapter":"Kapitel 6 Errate die Zahl: Eine Mehr-Runden-Ausgabe","heading":"6.5 Begrenzung der Anzahl der Versuche mittels Break","text":"Setzen wir den Spieler unter Druck! Entscheide dich für eine maximale Anzahl Versuchen, die du erlaubst, und speichere sie als KONSTANTE. Wähle einen passenden Namen (z.B. MAX_ATTEMPTS) und BEACHTE, GROßBUCHSTABEN für den Namen einer Konstanten! Nun nutze break um die -Schleife zu verlassen, wenn die aktuelle Versuchszahl größer als MAX_ATTEMPTS ist. Überlege, wann (innerhalb des Codes innerhalb der Schleife) du dies prüfen solltest.Speichere deinen Code code03.py.","code":""},{"path":"guess-the-number-multi-round.html","id":"korrekte-end-of-game-nachricht","chapter":"Kapitel 6 Errate die Zahl: Eine Mehr-Runden-Ausgabe","heading":"6.6 Korrekte End-of-Game-Nachricht","text":"Aktualisieren wir die finale Nachricht. Im Moment steht dort “Ganz genau…”, weil wir davon ausgegangen sind, dass das Programm die Schleife nur dann verlässt, wenn der Spieler die richtige Antwort gegeben hat. Bei begrenzten Versuchen ist das nicht unbedingt der Fall. Es gibt jetzt zwei Gründe, warum es die -Schleife verlassen hat:Der Spieler hat die richtige Antwort gegeben.Dem Spieler sind die Versuche ausgegangen.Verwende die -else Bedingungsanweisung, um eine passende Nachricht auszugeben. Zum Beispiel drucke \"Viel Glück beim nächsten Mal!\", wenn der Spieler verloren hat (die Versuche ausgegangen sind).Speichere deinen Code code04.py.","code":""},{"path":"guess-the-number-multi-round.html","id":"begrenzung-der-anzahl-der-versuche-ohne-break","chapter":"Kapitel 6 Errate die Zahl: Eine Mehr-Runden-Ausgabe","heading":"6.7 Begrenzung der Anzahl der Versuche ohne Break","text":"Obwohl es meine Idee war, die break Anweisung hinzuzufügen, solltest du sie sparsam verwenden. Ohne break gibt es eine einzige Stelle im Code, die du überprüfen musst, um zu verstehen, wann das Programm die Schleife verlassen wird: die Bedingung. Wenn du jedoch ein break hinzufügst, hast du jetzt zwei Stellen, die geprüft werden müssen. Und jedes zusätzliche break fügt weitere hinzu. Das bedeutet aber nicht, dass du sie um jeden Preis vermeiden solltest! Du solltest sie verwenden, wenn dadurch der Code leichter zu verstehen ist. Aber überprüfe immer, ob eine modifizierte Bedingung auch den Trick tun könnte.Probieren wir genau das aus. Ändere deinen Code ab, dass er ohne die break Anweisung funktioniert. Du brauchst eine kompliziertere Bedingung für deine -Schleife, dass sie sich wiederholt, solange die Vermutung des Spielers falsch ist und die Anzahl der Versuche noch kleiner ist als die maximal erlaubte. Teste, ob dein Code sowohl funktioniert, wenn du gewinnst als auch wenn du verlierst.Speichere deinen Code code05.py.","code":""},{"path":"guess-the-number-multi-round.html","id":"verbleibende-versuche-anzeigen","chapter":"Kapitel 6 Errate die Zahl: Eine Mehr-Runden-Ausgabe","heading":"6.8 Verbleibende Versuche anzeigen","text":"Es geht alles um die Benutzeroberfläche! Ändere die Eingabeaufforderung , dass sie die Anzahl der verbleibenden Versuche enthält. Z.B. \"Bitte gebe eine Vermutung ein, du hast noch X Versuche übrig\".Speichere deinen Code code06.py.","code":""},{"path":"guess-the-number-multi-round.html","id":"guess-the-number-repeat-game","chapter":"Kapitel 6 Errate die Zahl: Eine Mehr-Runden-Ausgabe","heading":"6.9 Wiederholung des Spiels","text":"Lass uns dem Spieler die Option geben, noch einmal zu spielen. Das bedeutet, dass wir allen aktuellen Code eine weitere -Schleife packen (das nennt man verschachtelte Schleifen), die lange wiederholt wird, wie der Spieler weiterspielen möchte. Der Code sollte folgendermaßen aussehen:Achte besonders auf die Einrückungen, um den Code richtig zu gruppieren!Setze deinen Code code07.py.","code":"# importiere die random Bibliothek, damit du die Funktion randint verwenden kannst\n\n# definiere MAX_ATTEMPTS\n\n# definiere eine Variable namens \"want_to_play\" und setze sie auf True\n# solange der Spieler noch spielen möchte\n  \n  # dein aktueller funktionierender Spielcode kommt hierher\n  \n  # frage den Benutzer mit der input-Funktion, z.B. \"Möchtest du nochmal spielen? J/N\"\n  # want_to_play sollte True sein, wenn die Benutzereingabe gleich \"J\" oder \"j\" ist\n  \n# allerletzte Nachricht, zum Beispiel \"Vielen Dank fürs Spielen!\""},{"path":"guess-the-number-multi-round.html","id":"du-benötigst-keinen-vergleich-wenn-du-bereits-den-wert-hast","chapter":"Kapitel 6 Errate die Zahl: Eine Mehr-Runden-Ausgabe","heading":"6.10 Du benötigst keinen Vergleich, wenn du bereits den Wert hast","text":"deinem aktualisierten Code hast du eine Variable want_to_play, die entweder True oder False ist. Sie wird der Schleife verwendet, die sich wiederholt, solange ihr Wert True ist. Manchmal schreiben Leute want_to_play == True, um das auszudrücken. Obwohl es technisch korrekt und mit Sicherheit korrekt funktionieren wird, ist es auch redundant. Da want_to_play nur True oder False sein kann, verwandelt sich dieser Vergleich True == True (natürlich True ist) oder False == True (False ist). Das Vergleichen eines jeden Werts mit True ergibt genau denselben Wert. Daher kannst du einfach want_to_play: schreiben und den logischen Wert direkt verwenden.","code":""},{"path":"guess-the-number-multi-round.html","id":"bestes-ergebnis","chapter":"Kapitel 6 Errate die Zahl: Eine Mehr-Runden-Ausgabe","heading":"6.11 Bestes Ergebnis","text":"Ein “richtiges” Spiel behält normalerweise die Leistung der Spieler im Auge. Lass uns die geringste Anzahl von Versuchen aufzeichnen, die der Spieler benötigt hat, um die Zahl zu erraten. Dazu erstellst du eine neue Variable fewest_attempts und setzt sie auf MAX_ATTEMPTS (das ist schlecht, wie der Spieler sein kann). Überlege, wo du sie erstellen musst. Du solltest sie nach jeder Spielrunde aktualisieren. Füge die Information über “Bisher das Beste” die finale Rundennachricht ein.Setze deinen Code code08.py.","code":""},{"path":"guess-the-number-multi-round.html","id":"zählen-der-spielrunden","chapter":"Kapitel 6 Errate die Zahl: Eine Mehr-Runden-Ausgabe","heading":"6.12 Zählen der Spielrunden","text":"Lass uns zählen, wie oft der Spieler das Spiel gespielt hat. Die Idee und Umsetzung ist dieselbe wie beim Zählen der Versuche. Erstelle eine neue Variable, initialisiere sie auf 0, erhöhe sie um 1, wann immer eine neue Runde beginnt. Füge die Gesamtanzahl der gespielten Spiele die allerletzte Nachricht ein, z.B. “Danke, dass du das Spiel X Mal gespielt hast!”Setze deinen Code code09.py.","code":""},{"path":"guess-the-number-multi-round.html","id":"einarmiger-bandit-mit-mehreren-runden","chapter":"Kapitel 6 Errate die Zahl: Eine Mehr-Runden-Ausgabe","heading":"6.13 Einarmiger Bandit mit mehreren Runden","text":"Ende des vorherigen Kapitels hast du ein einarmiger Banditen-Spiel mit einer einzigen Runde programmiert. Du weißt bereits alles, du brauchst, um eine Version mit mehreren Runden zu implementieren, und ihre Struktur ähnelt der des Mehr-Runden-Zahlenraten-Spiels, das du gerade implementiert hast, ist aber einfacher.Lass den Spieler mit einem Anfangspot Geld starten, sagen wir 10 Münzen. Jede Runde kostet 1 Münze, bei drei gleichen bekommt man 10 Münzen ausgezahlt, während man bei einem Paar 2 Münzen ausgezahlt bekommt (du kannst die Auszahlungen nach Belieben ändern). jeder Runde:Nimm eine Münze aus dem Topf (Preis für das Spiel).Würfle die Würfel (das hast du bereits implementiert).Informiere den Spieler über das Ergebnis (das hast du auch schon implementiert).Füge Münzen zum Topf hinzu, falls nötig.Drucke die Anzahl der im Topf verbliebenen Münzen aus.Frage den Spieler, ob er weitermachen möchte.Sonderfall: Wenn dem Spieler die Münzen ausgehen, ist das Spiel definitiv vorbei.Setze deinen Code code10.py.","code":""},{"path":"guess-the-number-multi-round.html","id":"abschluss","chapter":"Kapitel 6 Errate die Zahl: Eine Mehr-Runden-Ausgabe","heading":"6.14 Abschluss","text":"Sehr gut, du hast jetzt zwei richtige funktionierende Computerspiele mit Spielrunden, begrenzten Versuchen, Bestleistung und vielem mehr! Pack den Ordner eine Zip-Datei und reiche sie ein.","code":""},{"path":"guess-the-number-ai.html","id":"guess-the-number-ai","chapter":"Kapitel 7 Guess the Number: KI ist dran","heading":"Kapitel 7 Guess the Number: KI ist dran","text":"Lass uns das Spiel Rate die Zahl noch einmal programmieren18 aber die Rollen umkehren. Jetzt wählst du eine Zahl und der Computer wird versuchen, sie zu erraten. Denke über den Algorithmus nach, den ein Computer dafür verwenden könnte, bevor du den nächsten Absatz liest19.Der optimale Weg, dies zu tun, besteht darin, die Mitte des Intervalls für eine Vermutung zu verwenden. Auf diese Weise schließt du die Hälfte der Zahlen aus, die entweder größer oder kleiner sind als deine Vermutung (oder du errätst die Zahl korrekt, natürlich). Wenn du also weißt, dass die Zahl zwischen 1 und 10 liegt, solltest du die Dinge der Mitte teilen, also 5 oder 6 wählen, da du nicht 5,5 wählen kannst (wir gehen davon aus, dass du nur ganze Zahlen verwenden kannst). Wenn dein Gegner dir sagt, dass seine Zahl größer ist als deine Wahl, weißt du, dass sie irgendwo zwischen deiner Vermutung und der ursprünglichen Obergrenze liegen muss, z. B. zwischen 5 und 10. Umgekehrt, wenn der Gegner “niedriger” antwortet, liegt die Zahl zwischen der unteren Grenze und deiner Vermutung, z. B. zwischen 1 und 5. Bei deinem nächsten Versuch teilst du das neue Intervall und wiederholst dies, bis du entweder die richtige Zahl errätst oder nur noch ein Intervall mit nur einer Zahl übrig hast. Dann musst du nicht mehr raten.Um dieses Programm zu implementieren, musst du Funktionen kennen lernen, wie man sie dokumentiert und wie man eigene Bibliotheken verwendet. Hol dir das Übungsnotebook, bevor wir anfangen!","code":""},{"path":"guess-the-number-ai.html","id":"konzepte-des-kapitels.","chapter":"Kapitel 7 Guess the Number: KI ist dran","heading":"7.1 Konzepte des Kapitels.","text":"Schreiben deiner eigenen Funktionen.Verstehen von variablen Bereichen.Annahme von standardisierten Wegen, um deinen Code zu dokumentieren.Verwendung deiner eigenen Bibliotheken.","code":""},{"path":"guess-the-number-ai.html","id":"guess-the-number-players-response","chapter":"Kapitel 7 Guess the Number: KI ist dran","heading":"7.2 Spielerantwort","text":"Lass uns warm werden, indem wir einen Code schreiben, der es einem Spieler ermöglicht, auf den Tipp des Computers zu reagieren. Denke daran, es gibt nur drei Möglichkeiten: deine Zahl ist größer, kleiner oder gleich der Vermutung des Computers. Ich würde vorschlagen, die Symbole >, < und = zu verwenden, um dies zu kommunizieren. Du musst den Code schreiben, der den Spieler auffordert, seine Antwort einzugeben, bis er eines dieser Symbole eingibt. D.h., die Aufforderung zur Eingabe sollte wiederholt werden, wenn sie etwas anderes eingeben. Du musst also definitiv die input([prompt]) und eine Schleife verwenden. Überlege dir eine nützliche und informative Aufforderungsnachricht dafür. Teste, ob es funktioniert. Breakpoints können hier sehr hilfreich sein.Füge deinen Code code01.py ein.","code":""},{"path":"guess-the-number-ai.html","id":"function","chapter":"Kapitel 7 Guess the Number: KI ist dran","heading":"7.3 Funktionen","text":"Du weißt bereits, wie man Funktionen verwendet, jetzt ist es der Zeit, mehr darüber zu lernen, warum du dich darum kümmern solltest. Der Zweck einer Funktion besteht darin, bestimmten Code, der eine einzige Berechnung durchführt, zu isolieren und ihn somit testbar und wiederverwendbar zu machen. Lass uns den letzten Satz Stück für Stück anhand von Beispielen durchgehen.","code":""},{"path":"guess-the-number-ai.html","id":"eine-funktion-führt-eine-einzige-berechnung-durch","chapter":"Kapitel 7 Guess the Number: KI ist dran","heading":"7.3.1 Eine Funktion führt eine einzige Berechnung durch","text":"Ich habe dir bereits erzählt, dass das Lesen von Code einfach ist, weil jede Aktion für Computer auf einfache und klare Weise ausgedrückt werden muss. Allerdings können viele einfache Dinge sehr überwältigend und verwirrend sein. Denke den finalen Code vom letzten Seminar: Wir hatten zwei Schleifen mit bedingten Anweisungen, die darin verschachtelt waren. Füge ein paar mehr hinzu und du hast viele Zweige zu verfolgen, dass du nie ganz sicher sein kannst, passieren wird. Das liegt daran, dass unsere Wahrnehmung und unser Arbeitsgedächtnis, die du benutzt, um alle Zweige zu verfolgen, auf nur etwa vier Elemente beschränkt sind20.Daher sollte eine Funktion eine Berechnung / Aktion durchführen, die konzeptionell klar ist und deren Zweck direkt aus ihrem Namen oder höchstens aus einem einzelnen Satz, der sie beschreibt, verstanden werden sollte21. Der Name einer Funktion sollte typischerweise ein Verb sein, denn es geht darum, eine Aktion auszuführen. Wenn du mehr als einen Satz brauchst, um zu erklären, die Funktion tut, solltest du erwägen, den Code weiter aufzuteilen. Das bedeutet nicht, dass die gesamte Beschreibung/Dokumentation einen einzigen Satz passen muss. Die vollständige Beschreibung kann lang sein, insbesondere wenn die zugrunde liegende Berechnung komplex ist und es viele Parameter zu berücksichtigen gibt. Dies sind jedoch optionale Details, die dem Leser sagen, wie die Funktion ihre Aufgabe erledigt oder wie ihr Verhalten verändert werden kann. Trotzdem sollten sie der Lage sein, zu verstehen, die Aufgabe ist, nur aus dem Namen oder aus einem einzigen Satz. Ich wiederhole mich und betone dies sehr, weil konzeptionell einfache Funktionen, die nur eine Aufgabe erfüllen, die Grundlage für einen klaren, robusten, wiederverwendbaren Code sind. Und das zukünftige Du wird sehr dankbar sein, dass es mit dem einfach zu verstehenden, isolierten, zuverlässigen Code arbeiten muss, den du geschrieben hast.","code":""},{"path":"guess-the-number-ai.html","id":"funktion-isoliert-code-vom-rest-des-programms","chapter":"Kapitel 7 Guess the Number: KI ist dran","heading":"7.3.2 Funktion isoliert Code vom Rest des Programms","text":"Isolierung bedeutet, dass dein Code einem separaten Bereich ausgeführt wird, dem nur Funktionselemente (begrenzte Anzahl von Werten, die du von außen mit fester Bedeutung übergibst) und lokale Variablen, die du innerhalb der Funktion definierst, existieren. Du hast keinen Zugriff auf Variablen, die im außenstehenden Skript definiert sind22 oder auf Variablen, die anderen Funktionen definiert sind. Umgekehrt haben weder das globale Skript noch andere Funktionen Zugriff auf Variablen und Werte, die du innen verwendest. Das bedeutet, dass du nur den Code innerhalb der Funktion studieren musst, um zu verstehen, wie sie funktioniert. Entsprechend sollte der Code, den du schreibst, unabhängig von jedem globalen Kontext sein, dem die Funktion verwendet werden kann. Die Isolierung ist sowohl praktisch (kein Zugriff auf Variablen von außen während der Laufzeit bedeutet weniger Chancen, dass Dinge schrecklich schief gehen) als auch konzeptionell (kein weiterer Kontext ist erforderlich, um den Code zu verstehen).","code":""},{"path":"guess-the-number-ai.html","id":"funktion-macht-code-einfacher-zu-testen","chapter":"Kapitel 7 Guess the Number: KI ist dran","heading":"7.3.3 Funktion macht Code einfacher zu testen","text":"Du kannst sogar mäßig komplexe Programme nur dann erstellen, wenn du sicher sein kannst, individuelle Codeabschnitte unter jeder möglichen Bedingung tun. Erzeugen sie die richtigen Ergebnisse? Scheitern sie deutlich und heben sie einen richtigen Fehler hervor, wenn die Eingaben falsch sind? Verwenden sie bei Bedarf Standardwerte? Wenn du jedoch alle Teile zusammen testest, bedeutet das eine extreme Anzahl von Durchläufen, da du alle möglichen Kombinationen von Bedingungen für einen Teil testen musst, gegeben alle möglichen Bedingungen für einen anderen Teil usw. Funktionen machen dein Leben viel einfacher. Da sie einen einzigen Einstiegspunkt, eine feste Anzahl von Parametern, einen einzigen Rückgabewert und Isolation (siehe oben) haben, kannst du sie unabhängig von anderen Funktionen und dem Rest des Codes einzeln testen. Dies nennt man Unit Testing und es ist ein intensiver Einsatz von automatischem Unit Testing23 das sicherstellt, dass der Code für die absolute Mehrheit der Programme und Apps, die du verwendest, zuverlässig ist24.","code":""},{"path":"guess-the-number-ai.html","id":"funktion-macht-code-wiederverwendbar","chapter":"Kapitel 7 Guess the Number: KI ist dran","heading":"7.3.4 Funktion macht Code wiederverwendbar","text":"Manchmal wird dies als Hauptgrund angegeben, Funktionen zu verwenden. Wenn du den Code eine Funktion umwandelst, bedeutet das, dass du die Funktion aufrufen kannst, anstatt den Code zu kopieren und einzufügen. Der letztere Ansatz ist eine schreckliche Idee, da es bedeutet, dass du denselben Code vielen Stellen pflegen musst und du vielleicht nicht einmal sicher bist, wie vielen. Das ist ein Problem, selbst wenn der Code extrem einfach ist. Hier definieren wir einen standardisierten Weg, ein Initial zu berechnen, indem wir das erste Symbol aus einer Zeichenkette nehmen (du wirst später mehr über Indexierung und Slicing erfahren). Der Code ist einfach wie möglich.Stell dir vor, du hast beschlossen, es zu ändern und die ersten zwei Symbole zu verwenden. Wiederum ist die Berechnung nicht kompliziert, verwende einfach [0] ersetzen mit [:2]. Du musst es aber für allen Code tun, der diese Berechnung durchführt. Und du kannst die Option Alles Ersetzen nicht verwenden, weil du manchmal das erste Element für andere Zwecke verwenden könntest. Und wenn du den Code bearbeitest, wirst du zwangsläufig einige Stellen vergessen (ich mache das die ganze Zeit), die Dinge noch inkonsistenter und verwirrender macht. Code eine Funktion zu verwandeln bedeutet, dass du nur einer Stelle ändern und testen musst. Hier ist der ursprüngliche Code, der über eine Funktion implementiert wurde.“alternative” initial computation. Note code uses function stays \nund hier ist die “alternative” Initialberechnung. Beachte, dass der Code, der die Funktion verwendet, gleich bleibtDaher ist es besonders nützlich, Code eine Funktion umzuwandeln, wenn der wiederverwendete Code komplex ist, aber es zahlt sich sogar aus, wenn die Berechnung einfach und trivial ist wie im obigen Beispiel. Mit einer Funktion musst du dir nur um einen einzigen Codeblock Gedanken machen und du kannst sicher sein, dass die gleiche Berechnung immer dann ausgeführt wird, wenn du die Funktion aufrufst (und dass dies nicht mehrere Kopien des Codes sind, die möglicherweise identisch sind oder nicht).Beachte, dass ich den wiederverwendbaren Code als den letzten und den wenigsten wichtigen Grund zur Verwendung von Funktionen putze. Dies liegt daran, dass die anderen drei Gründe weitaus wichtiger sind. Konzeptuell klaren, isolierten und testbaren Code zu haben, ist vorteilhaft, selbst wenn du diese Funktion nur einmal aufrufst. Es erleichert das Verständnis und das Testen des Codes und hilft dir, seine Komplexität zu reduzieren, indem du Codeblöcke durch deren Bedeutung ersetzt. Sieh dir das folgende Beispiel . Der erste Code nimmt das erste Symbol, aber diese Aktion (das erste Symbol nehmen) bedeutet sich nichts, es ist nur eine mechanische Berechnung. Es ist nur der ursprüngliche Kontext initial_for_file = filename[0] oder zusätzliche Kommentare, die ihm seine Bedeutung geben. Im Gegensatz dazu sagt dir das Aufrufen einer Funktion namens compute_initial passiert, da es den Zweck eindeutig macht. Ich vermute, dass der zukünftige Du sehr pro-Eindeutigkeit und anti-Verwirrung ist.","code":"...\ninitial = \"test\"[0]\n...\ninitial_for_file = filename[0]\n...\ninitial_for_website = first_name[0]\n...def generate_initial(full_string):\n    \"\"\"Erzeugt ein Initial mit dem ersten Symbol.\n    \n    Parameter\n    ----------\n    full_string : str\n    \n    Gibt zurück\n    ----------\n    str : einzelnes Symbol\n    \"\"\"\n    return full_string[0]\n\n...\ninitial = generate_initial(\"test\")\n...\ninitial_for_file = generate_initial(filename)\n...\ninitial_for_website = generate_initial(first_name)\n...def generate_initial(full_string):\n    \"\"\"Erzeugt ein Initial mit den ersten ZWEI Symbolen.\n    \n    Parameter\n    ----------\n    full_string : str\n    \n    Gibt zurück\n    ----------\n    str : zwei Symbole lang\n    \"\"\"\n    return full_string[:2]\n\n...\ninitial = generate_initial(\"test\")\n...\ninitial_for_file = generate_initial(filename)\n...\ninitial_for_website = generate_initial(first_name)\n...if filename[0] == \"A\":\n    ...\n    \nif compute_initial(filename) == \"A\":\n    ..."},{"path":"guess-the-number-ai.html","id":"funktionen-in-python","chapter":"Kapitel 7 Guess the Number: KI ist dran","heading":"7.4 Funktionen in Python","text":"","code":""},{"path":"guess-the-number-ai.html","id":"definieren-einer-funktion-in-python","chapter":"Kapitel 7 Guess the Number: KI ist dran","heading":"7.4.1 Definieren einer Funktion in Python","text":"Eine Funktion Python sieht aus (beachte die Einrückung und : Ende der ersten Zeile)Die Parameter sind optional, ebenso der Rückgabewert. Die minimalste Funktion wäre daherDu musst deine Funktion (einmal!) definieren, bevor du sie aufrufst (ein- oder mehrmals). Du solltest also Funktionen vor dem Code erstellen, der sie verwendet.Mache Übung #1.Du musst auch im Hinterkopf behalten, dass das erneute Definieren einer Funktion (oder das Definieren einer technisch anderen Funktion, die den gleichen Namen hat) die ursprüngliche Definition überschreibt, dass nur die neueste Version davon beibehalten und verwendet werden kann.Mache Übung #2.Obwohl das Beispiel der Übung das Problem leicht erkennen lässt, kann es einem großen Code, der sich über mehrere Dateien erstreckt und verschiedene Bibliotheken verwendet, nicht einfach sein, das gleiche Problem zu lösen!","code":"def <funktionsname>(param1, param2, ...):\n    einige interne Berechnung\n    if bedingung:\n        return ein Wert\n    return ein anderer Wertdef minimal_function():\n    pass # pass bedeutet \"mache nichts\"def do_something():\n    \"\"\"\n    Das ist eine Funktion namens \"do_something\". Sie macht eigentlich nichts.\n    Sie benötigt keine Eingabe und gibt keinen Wert zurück.\n    \"\"\"\n    return\n    \ndef another_function():\n    ...\n    # Wir rufen sie in einer anderen Funktion auf.\n    do_something()\n    ...\n\n# Das ist ein Funktionsaufruf (wir verwenden diese Funktion)\ndo_something()\n\n# Und wir verwenden sie noch einmal!\ndo_something()\n\n# Und wieder, aber durch einen another_function Aufruf\nanother_function()"},{"path":"guess-the-number-ai.html","id":"funktionsargumente","chapter":"Kapitel 7 Guess the Number: KI ist dran","heading":"7.4.2 Funktionsargumente","text":"Einige Funktionen benötigen möglicherweise keine Argumente (auch Parameter genannt), da sie eine feste Aktion ausführen:Du musst jedoch möglicherweise Informationen die Funktion über Argumente weitergeben, um zu beeinflussen, wie die Funktion ihre Aktion ausführt. Python listest du einfach Argumente innerhalb der runden Klammern nach dem Funktionsnamen auf (es gibt noch mehr Optionen und Funktionen, aber wir halten es zunächst einfach). Beispielsweise könnten wir eine Funktion schreiben, die das Alter einer Person berechnet und ausgibt, basierend auf zwei Parametern 1) ihrem Geburtsjahr, 2) dem aktuellen Jahr:Es ist eine sehr gute Idee, Funktionen, Parametern und Variablen aussagekräftige Namen zu geben. Der folgende Code wird genau das gleiche Ergebnis liefern, aber das Verständnis warum und wofür es das tut, es tut, wäre viel schwieriger (also benutze immer aussagekräftige Namen!):Wenn du eine Funktion aufrufst, musst du die korrekte Anzahl von Parametern übergeben und sie der richtigen Reihenfolge übergeben, ein weiterer Grund für Funktionen Argumente, aussagekräftige Namen zu haben25.Mache Übung #3.Wenn du eine Funktion aufrufst, werden die Werte, die du die Funktion übermittelst, den Parametern zugewiesen und sie werden als lokale Variablen verwendet (mehr darüber später). Es spielt jedoch keine Rolle, wie du diese Werte erlangt hast, ob sie einer Variable waren, hart codiert wurden oder von einer anderen Funktion zurückgegeben wurden. Wenn du numerische, logische oder Zeichenkettenwerte (unveränderliche Typen) verwendest, kannst du davon ausgehen, dass jede Verbindung zur ursprünglichen Variablen oder Funktion, die sie erzeugt hat, verschwunden ist (wir werden uns später um veränderliche Typen wie Listen kümmern). Wenn du also eine Funktion schreibst oder ihren Code liest, gehst du einfach davon aus, dass sie bei dem Aufruf auf einen bestimmten Wert gesetzt wurde und du kannst den Kontext, dem dieser Aufruf gemacht wurde, ignorieren.","code":"def ping():\n    \"\"\"\n    Maschine, die \"ping!\" macht.\n    \"\"\"\n    print(\"ping!\")def print_age(birth_year, current_year):\n    \"\"\"\n    Gibt das Alter aus, gegeben das Geburtsjahr und das aktuelle Jahr.\n    \n    Parameter\n    ----------\n    birth_year : int\n    current_year : int\n    \"\"\"\n    print(current_year - birth_year)def x(a, b):\n    print(b - a)# hart codiert\nprint_age(1976, 2020)\n\n# mit Werten aus Variablen\ni_was_born = 1976\ntoday_is = 2023\nprint_age(i_was_born, today_is)\n\n# mit Wert aus einer Funktion\ndef get_current_year():\n    return 2023\n\nprint_age(1976, get_current_year())"},{"path":"guess-the-number-ai.html","id":"rückgabewert-der-funktionen-ausgabe","chapter":"Kapitel 7 Guess the Number: KI ist dran","heading":"7.4.3 Rückgabewert der Funktionen (Ausgabe)","text":"Deine Funktion kann eine Aktion ausführen, ohne einen Wert den Aufrufer zurückzugeben (das ist es, unsere Funktion print_age getan hat). Du könntest jedoch den Wert stattdessen zurückgeben müssen. Um die Dinge allgemeiner zu gestalten, möchten wir vielleicht eine neue Funktion namens compute_age schreiben, die das Alter zurückgibt, anstatt es zu drucken (wir können es immer selbst drucken).Beachte, dass selbst wenn eine Funktion den Wert zurückgibt, dieser nur beibehalten wird, wenn er tatsächlich verwendet wird (einer Variablen gespeichert, als Wert verwendet etc.). Ein einfacher Aufruf speichert den zurückgegebenen Wert also nicht irgendwo!Mache Übung #4.","code":"def compute_age(birth_year, current_year):\n    \"\"\"\n    Berechnet das Alter, gegeben das Geburtsjahr und das aktuelle Jahr.\n\n    Parameter\n    ----------\n    birth_year : int\n    current_year : int\n    \n    Gibt zurück\n    ----------\n    int : age\n    \"\"\"\n    return current_year - birth_year"},{"path":"guess-the-number-ai.html","id":"anwendungsbereiche-für-unveränderbare-werte","chapter":"Kapitel 7 Guess the Number: KI ist dran","heading":"7.4.4 Anwendungsbereiche (für unveränderbare Werte)","text":"Wie wir oben besprochen haben, isoliert das Umwandeln von Code eine Funktion ihn, sodass er seinem eigenen Anwendungsbereich läuft. Python existiert jede Variable dem Anwendungsbereich, dem sie definiert wurde. Wenn sie im globalen Skript definiert wurde, existiert sie diesem globalen Anwendungsbereich als globale Variable. Sie ist jedoch nicht zugänglich (zumindest nicht ohne besondere Anstrengungen über einen global Operator) innerhalb einer Funktion. Umgekehrt existieren die Parameter einer Funktion und alle innerhalb einer Funktion definierten Variablen nur innerhalb dieser Funktion. Sie sind für die Außenwelt vollkommen unsichtbar und können nicht von einem globalen Skript oder von einer anderen Funktion aus abgerufen werden. Ebenso haben alle Änderungen, die du Funktionsparameter oder der lokalen Variable vornimmst, keinerlei Auswirkungen auf die Außenwelt.Der Zweck von Anwendungsbereichen besteht darin, einzelne Codeabschnitte voneinander zu isolieren, sodass das Ändern von Variablen innerhalb eines Anwendungsbereichs keine Auswirkungen auf alle anderen Anwendungsbereiche hat. Das bedeutet, dass du beim Schreiben oder Debuggen des Codes keine Angst vor Code anderen Anwendungsbereichen haben musst und dich nur auf den Code konzentrieren musst, dem du arbeitest. Da Anwendungsbereiche isoliert sind, können sie gleichnamige Variablen haben, die jedoch keine Beziehung zueinander haben, da sie ihren eigenen parallelen Universen existieren26. Wenn du also wissen möchten, welchen Wert eine Variable hat, musst du nur innerhalb des Anwendungsbereichs schauen und alle anderen Anwendungsbereiche ignorieren (auch wenn die Namen übereinstimmen!).Mache Übung #5.","code":"# dies ist die Variable `x` im globalen Anwendungsbereich\nx  = 5 \n\ndef f1():\n  # Das ist die Variable `x` im Anwendungsbereich der Funktion f1\n  # Sie hat den gleichen Namen wie die globale Variable, aber\n  # hat keine Beziehung zu ihr: viele Leute heißen Sasha, \n  # sind aber immer noch unterschiedliche Personen. Was auch immer\n  # mit `x` in f1 passiert, bleibt im Anwendungsbereich von f1.\n  x = 3\n\n  \ndef f2(x):\n  # Dies ist der Parameter `x` im Anwendungsbereich der Funktion f2.\n  # Wieder keine Beziehung zu anderen globalen oder lokalen Variablen.\n  # Es ist ein völlig getrenntes Objekt, es passiert einfach, \n  # dass es den gleichen Namen hat (wieder einfach Namensvettern)\n  print(x)"},{"path":"guess-the-number-ai.html","id":"spielerantwort-als-funktion","chapter":"Kapitel 7 Guess the Number: KI ist dran","heading":"7.5 Spielerantwort als Funktion","text":"Lassen wir diese Theorie über Funktionen die Praxis umsetzen. Verwende den Code, den du erstellt hast, um die Spielerantwort zu erhalten und verwandle ihn eine Funktion. Sie sollte keine Parameter haben (zumindest vorerst) und sollte die Spielerantwort zurückgeben. Ich schlage vor, dass du sie input_response (oder ähnlich) nennst. Überprüfe, ob der Code funktioniert, indem du diese Funktion aus dem Hauptskript aufrufst.Füge deinen Code code02.py ein.","code":""},{"path":"guess-the-number-ai.html","id":"eine-funktion-debuggen","chapter":"Kapitel 7 Guess the Number: KI ist dran","heading":"7.6 Eine Funktion debuggen","text":"Jetzt, da du deine erste Funktion hast, kannst du den Sinn von drei Schritt über/Schritt /Schritt heraus-Tasten verstehen, die dir der Debugger anbietet. Kopiere den folgenden Code eine separate Datei (nenne sie zum Beispiel test01.py).Setze zuerst einen Breakpoint auf die Zeile im Hauptskript, die die Funktion f2() aufruft. Starte den Debugger über F5 und das Programm wird dieser Zeile anhalten. Wenn du nun F10 drückst (Schritt über), geht das Programm zur nächsten Zeile print(z). Wenn du aber stattdessen F11 drückst (Schritt hinein), wird das Programm die Funktion hineingehen und zur Zeile x = x + 5 gehen. Innerhalb der Funktion hast du die gleichen beiden Möglichkeiten, die wir gerade angeschaut haben, aber du kannst auch Shift+F11 drücken, um aus der Funktion herauszugehen. Hier wird das Programm den gesamten Code durchlaufen, bis du die nächste Zeile außerhalb der Funktion erreichst (du solltest wieder bei print(z) ankommen). Experimentiere mit dem Setzen von Breakpoints verschiedenen Zeilen und dem Über-/Hinein-/Herausschreiten, um dich mit diesen nützlichen Debugging-Tools vertraut zu machen.Setze nun den Breakpoint innerhalb der f1() Funktion und führe den Code über F5 aus. Schau dir die linke Fensterseite , du wirst einen Call Stack Reiter sehen. Während die gelb hervorgehobene Zeile im Editor zeigt, wo du gerade bist (sollte innerhalb der f1() Funktion sein), zeigt der Call Stack dir, wie du dorthin gekommen bist. diesem Fall sollte es zeigen:Die Aufrufe sind von unten nach oben gestapelt, das bedeutet, dass eine Funktion im Hauptmodul Zeile 9 aufgerufen wurde, du der Funktion f2 Zeile 7 gelandet bist und dann der Funktion f1 und Zeile 2. Experimentiere mit dem Ein- und Austreten aus Funktionen und behalte dabei den Call Stack im Auge. Du wirst diese Informationen vielleicht nicht oft benötigen, aber sie könnten unseren späteren Projekten mit mehreren verschachtelten Funktionsaufrufen nützlich sein.","code":"def f1(x, y):\n  return x / y\n  \ndef f2(x, y):\n  x = x + 5\n  y = y * 2\n  return f1(x, y)\n  \nz = f2(4, 2)\nprint(z)"},{"path":"guess-the-number-ai.html","id":"numpy-docstring","chapter":"Kapitel 7 Guess the Number: KI ist dran","heading":"7.7 Deine Funktion dokumentieren","text":"Eine Funktion zu schreiben, ist nur die halbe Arbeit. Du musst sie dokumentieren! Erinnere dich, das ist eine gute Gewohnheit, die deinen Code einfach zu benutzen und wiederzuverwenden macht. Es gibt verschiedene Möglichkeiten, den Code zu dokumentieren, aber wir werden die NumPy Docstring Konvention verwenden. Hier ist ein Beispiel für eine solche dokumentierte FunktionSchau dir das Handbuch und dokumentiere die input_response Funktion. Du wirst den Abschnitt Parameter nicht benötigen, da sie derzeit keine Eingaben akzeptiert.Aktualisiere deinen Code code02.py.","code":"def generate_initial(full_string):\n    \"\"\"Erzeugt eine Initiale mit dem ersten Symbol.\n    \n    Parameter\n    ----------\n    full_string : str\n    \n    Gibt zurück\n    ----------\n    str : Einzelnes Symbol\n    \"\"\"\n    return full_string[0]"},{"path":"guess-the-number-ai.html","id":"verwendung-der-aufforderung","chapter":"Kapitel 7 Guess the Number: KI ist dran","heading":"7.8 Verwendung der Aufforderung","text":"der Zukunft werden wir nach einer bestimmten Zahl fragen, die eine aktuelle Vermutung des Computers ist, daher können wir keine feste Aufforderungsnachricht verwenden. Ändere die input_response Funktion, indem du einen guess Parameter hinzufügst. Dann ändere die Aufforderung, die du für die input() verwendet hast, um den Wert diesem Parameter einzuschließen. Aktualisiere die Dokumentation der Funktionen. Teste es, indem du mit verschiedenen Werten für den guess Parameter aufrufst und eine unterschiedliche Aufforderung zur Antwort siehst.Gib deinen Code code03.py ein.","code":""},{"path":"guess-the-number-ai.html","id":"aufteilen-des-intervalls-in-der-mitte","chapter":"Kapitel 7 Guess the Number: KI ist dran","heading":"7.9 Aufteilen des Intervalls in der Mitte","text":"Lass uns ein bisschen mehr üben, Funktionen zu schreiben. Denke daran, dass der Computer die Mitte des Intervalls als Vermutung verwenden sollte. Erstelle eine Funktion (nennen wir sie split_interval() oder ähnlich), die zwei Parameter – lower_limit und upper_limit - entgegennimmt und eine Ganzzahl zurückgibt, die der Mitte des Intervalls nächsten liegt. Der einzige knifflige Teil ist, wie du eine potentiell Gleitkommazahl (z.B. wenn du versuchst, sie für das Intervall 1..10 zu finden) eine Ganzzahl umwandelst. Du kannst dafür die Funktion int() verwenden. Lies jedoch die Dokumentation sorgfältig durch, da sie keine korrekte Rundung durchführt (tut sie? Lies die Dokumentation!). Du solltest daher die Zahl auf die nächste Ganzzahl round() runden, bevor du sie umwandelst.Schreibe eine Funktion, dokumentiere sie und teste sie, indem du überprüfst, ob die Zahlen korrekt sind.Gib deine split_interval() Funktion und den Testcode code04.py ein.","code":""},{"path":"guess-the-number-ai.html","id":"einzelne-runde","chapter":"Kapitel 7 Guess the Number: KI ist dran","heading":"7.10 Einzelne Runde","text":"Du hast beide Funktionen, die du brauchst, also lass uns den Code schreiben, um das Spiel zu initialisieren und eine einzelne Runde zu spielen. Die Initialisierung läuft darauf hinaus, zwei Variablen zu erstellen, die den unteren und oberen Grenzwerten des Spielbereichs entsprechen (wir haben bisher 1 bis 10 verwendet, aber das kannst du natürlich immer ändern). Als nächstes sollte der Computer eine Vermutung generieren (dafür hast du deine split_interval() Funktion) und den Spieler nach der Vermutung fragen (das ist die input_response() Funktion). Sobald du die Antwort hast (einer separaten Variable gespeichert, denke dir selbst einen Namen aus), aktualisiere entweder die obere oder untere Grenze mit einem ..elif..else Ausdruck, basierend auf der Antwort des Spielers (wenn der Spieler gesagt hat, dass seine Zahl höher ist, bedeutet das, dass das neue Intervall von guess bis upper_limit reicht, und umgekehrt, wenn sie niedriger ist). Drucke eine freudige Nachricht aus, wenn die Vermutung des Computers richtig war.Gib beide Funktionen und den Skriptcode code05.py ein.","code":""},{"path":"guess-the-number-ai.html","id":"mehrere-runden","chapter":"Kapitel 7 Guess the Number: KI ist dran","heading":"7.11 Mehrere Runden","text":"Erweitere das Spiel, dass der Computer lange rät, bis er schließlich gewinnt. Du weißt bereits, wie man die Schleife verwendet, überlege nur, wie du die Antwort des Teilnehmers als eine Schleifenbedingungsvariable verwenden kannst. Denke auch über den Anfangswert dieser Variable nach und wie du sie verwenden kannst, um input_response() nur einer Stelle aufzurufen.Gib den aktualisierten Code code06.py ein.","code":""},{"path":"guess-the-number-ai.html","id":"nochmal-spielen","chapter":"Kapitel 7 Guess the Number: KI ist dran","heading":"7.12 Nochmal spielen","text":"Ändere den Code , dass du dieses Spiel mehrere Male spielen kannst. Du weißt bereits, wie das geht und das Einzige, du beachten musst, ist, wo genau du die Initialisierung vor jedem Spiel durchführen sollst. Da du das schon für das letzte Spiel implementiert hast, könntest du versucht sein zu sehen, wie du es gemacht hast oder sogar den Code zu kopieren und einzufügen. Allerdings würde ich empfehlen, es von Grund auf neu zu schreiben. Denke daran, dein Ziel ist es nicht, ein Programm zu schreiben, sondern zu lernen, wie man das macht und daher ist der Weg wichtiger als das Ziel.Gib den aktualisierten Code code07.py ein.","code":""},{"path":"guess-the-number-ai.html","id":"bester-punktestand","chapter":"Kapitel 7 Guess the Number: KI ist dran","heading":"7.13 Bester Punktestand","text":"Füge den Code hinzu, um die Anzahl der Versuche zu zählen, die der Computer jeder Runde benötigt hat, und melde den besten Punktestand (wenigste Anzahl von Versuchen), nachdem das Spiel vorbei ist. Du wirst eine Variable brauchen, um die Anzahl der Versuche zu zählen, und eine, um den besten Punktestand zu speichern. Versuche erneut, es zu schreiben, ohne auf dein vorheriges Spiel zu schauen.Gib den aktualisierten Code code08.py ein.","code":""},{"path":"guess-the-number-ai.html","id":"verwenden-deiner-eigenen-bibliotheken","chapter":"Kapitel 7 Guess the Number: KI ist dran","heading":"7.14 Verwenden deiner eigenen Bibliotheken","text":"Du weißt bereits, wie man bestehende Bibliotheken verwendet, aber du kannst auch deine eigenen erstellen und verwenden. Nimm die beiden Funktionen, die du entwickelt hast, und lege sie eine neue Datei namens utils.py (vergiss nicht, einen mehrzeiligen Kommentar Anfang der Datei hinzuzufügen, um dich daran zu erinnern, drin ist!). Kopiere den verbleibenden Code (das globale Skript) code09.py. Es wird seinem aktuellen Zustand nicht funktionieren, da es die beiden Funktionen nicht finden wird (versuche es, um die Fehlermeldung zu sehen), daher musst du aus deinem eigenen Modul utils importieren. Das Importieren funktioniert genau wie bei anderen Bibliotheken. Beachte, dass der Name deines Moduls utils ist (ohne die Endung), auch wenn deine Datei utils.py heißt.Gib die Funktionen utils.py ein, den verbleibenden Code code09.py.","code":""},{"path":"guess-the-number-ai.html","id":"keep-imports-tidy","chapter":"Kapitel 7 Guess the Number: KI ist dran","heading":"7.15 Ordnung muss sein!","text":"Bisher hast du höchstens eine Bibliothek importiert. Da Python jedoch hoch modular ist, ist es sehr verbreitet, viele Importe einer einzelnen Datei zu haben. Es gibt einige Regeln, die es einfacher machen, die Importe zu verfolgen. Wenn du Bibliotheken importierst, sollten alle Import-Anweisungen oben deiner Datei stehen und du solltest vermeiden, sie zufälliger Reihenfolge zu platzieren. Die empfohlene Reihenfolge ist 1) Systembibliotheken, wie os oder random; 2) Drittanbieter-Bibliotheken, wie psychopy; 3) deine Projektmodule. Und innerhalb jedes Abschnitts solltest du die Bibliotheken alphabetisch anordnen, sodass beispielsweiseDas mag für unseren einfachen Code nicht besonders nützlich aussehen, aber wenn deine Projekte wachsen, musst du mehr und mehr Bibliotheken einbeziehen. Wenn du sie dieser Reihenfolge hältst, ist es einfach zu verstehen, welche Bibliotheken du verwendest und welche nicht standardmäßig sind. Die alphabetische Reihenfolge bedeutet, dass du schnell überprüfen kannst, ob eine Bibliothek enthalten ist, da du schnell den Ort finden kannst, dem ihre Import-Anweisung erscheinen sollte.","code":"import os\nimport random"},{"path":"guess-the-number-ai.html","id":"videospiele-mit-video","chapter":"Kapitel 7 Guess the Number: KI ist dran","heading":"7.16 Videospiele mit Video","text":"Reiche deine Dateien ein und mach dich bereit für mehr Aufregung, denn wir wechseln zu “richtigen” Videospielen mit PsychoPy.","code":""},{"path":"One-armed-bandit.html","id":"One-armed-bandit","chapter":"Kapitel 8 Einarmiger Bandit, aber mit Listen und Schleifen","heading":"Kapitel 8 Einarmiger Bandit, aber mit Listen und Schleifen","text":"diesem Kapitel werden wir das Spiel des Einarmigen Banditen mehrmals neu programmieren. Das ist vielleicht nicht die aufregendste Aussicht, aber es gibt uns ein einfaches Spiel, das du bereits zu programmieren weißt, sodass wir uns auf Listen und -Schleifen konzentrieren können. Hol dir das Übungsnotebook, bevor wir starten.","code":""},{"path":"One-armed-bandit.html","id":"konzepte-des-kapitels-3","chapter":"Kapitel 8 Einarmiger Bandit, aber mit Listen und Schleifen","heading":"8.1 Konzepte des Kapitels","text":"Speichern von vielen Elementen Listen.Iterieren über Elemente mit der Schleife.Erstellen eines Bereichs von Werten.Schleifen über nummerierte Indizes und Werte.Listen erstellen mit Listenabstraktion.","code":""},{"path":"One-armed-bandit.html","id":"lists","chapter":"Kapitel 8 Einarmiger Bandit, aber mit Listen und Schleifen","heading":"8.2 Listen","text":"Bisher haben wir Variablen verwendet, um einzelne Werte zu speichern: die Wahl des Computers, die Vermutung des Spielers, die Anzahl der Versuche, das PsychoPy-Fensterobjekt usw. Aber manchmal müssen wir mehr als einen Wert verarbeiten. Dieses Problem hatten wir bereits im computerbasierten Raten-der-Zahl Spiel, als wir den verbleibenden Zahlenbereich speichern mussten. Wir haben das Problem gelöst, indem wir zwei Variablen verwendet haben, eine für die untere und eine für die obere Grenze. Allerdings ist klar, dass dieser Ansatz nicht gut skalierbar ist und manchmal wissen wir vielleicht nicht einmal, wie viele Werte wir speichern müssen. Die Listen von Python sind die Lösung für dieses Problem.Eine Liste ist eine veränderbare27 Sequenz von Elementen, auf die über ihren nullbasierten Index zugegriffen werden kann. Wenn du die Idee der Variablen-als-Box fortschreitest, kannst du dir Listen als eine Box mit nummerierten Steckplätzen vorstellen. Um ein bestimmtes Stück zu speichern und abzurufen, musst du sowohl den Variablennamen als auch den Index des Elements, dem du interessiert bist, dieser Box kennen. Dann arbeitest du mit einer Variable-plus-Index auf genau dieselbe Weise wie mit einer normalen Variable, indem du auf ihren Wert zugreifst oder ihn änderst, genau wie vorher.Eine Liste wird durch eckige Klammern definiert <variable> = [<wert1>, <wert2>, ... <wertN>]. Auf einen einzelnen Platz innerhalb einer Liste wird ebenfalls über eckige Klammern zugegriffen <variable>[<index>], wobei der Index wiederum nullbasiert ist28. Das bedeutet, dass das erste Element variable[0] ist und, wenn es N Elemente der Liste gibt, ist das letzte Element variable[N-1]. Du kannst die Gesamtzahl der Elemente einer Liste herausfinden, indem du ihre Länge über eine spezielle len() Funktion erhältst. kannst du auf das letzte Element über variable[len(variable)-1] zugreifen29. Beachte die -1: Wenn deine Liste 3 Elemente hat, ist der Index des letzten Elements 2, wenn sie 100 hat, dann 99, usw. Ich verbringe viel Zeit damit, weil dies eine recht häufige Quelle von Verwirrung ist.Mache Übung #1 um zu sehen, wie Listen definiert und indiziert werden.Listen erlauben dir auch, auf mehr als einen Slot/Index gleichzeitig zuzugreifen, und zwar über slicing. Du kannst den Index der Elemente über die Notation <start>:<stop> angeben. Zum Beispiel gibt dir x[1:3] Zugang zu zwei Elementen mit den Indizes 1 und 2. Ja, zwei Elemente: der Slicing-Index geht vom start bis aber nicht einschließlich zum stop. Wenn du also alle Elemente einer Liste abrufen willst, musst du x[0:length(x)] schreiben, und um nur das letzte Element zu bekommen, schreibst du immer noch x[len(x)-1]. Verwirrend? Ich denke schon! Ich verstehe die Logik, aber ich finde dieses stop---included Konzept gegenintuitiv und ich muss mich immer wieder bewusst daran erinnern. Leider ist dies die Standardmethode, um Zahlenfolgen Python zu definieren, daher musst du dir dies merken.Mache Übung #2, um die Intuition zu entwickeln.Beim Slicing kannst du entweder start oder stop weglassen. diesem Fall geht Python davon aus, dass ein fehlendes start 0 bedeutet (der Index des ersten Elements) und ein fehlendes stop len(<list>) bedeutet (also ist das letzte Element eingeschlossen). Wenn du beide weglässt, z.B. meine_schönen_zahlen[:], gibt es alle Werte zurück, da dies äquivalent zu meine_schönen_zahlen[0:len(meine_schönen_zahlen)] ist.30Mache Übung #3.Du kannst auch negative Indizes verwenden, die relativ zur Länge der Liste berechnet werden31. Wenn du zum Beispiel das letzte Element der Liste abrufen willst, kannst du meine_schönen_zahlen[len(meine_schönen_zahlen)-1] oder einfach nur meine_schönen_zahlen[-1] sagen. Das vorletzte Element wäre meine_schönen_zahlen[-2], usw. Du kannst negative Indizes für das Slicing verwenden, aber vergiss nicht den Haken einschließlich-dem-Start-aber-ausgenommen-dem-Stopp: meine_schönen_zahlen[:-1] gibt alle Elemente außer dem letzten Element der Liste zurück, nicht die gesamte Liste!Mache Übung #4.Das Slicing kann erweitert werden, indem ein Schritt über die Notation start:stop:Schritt angegeben wird. Schritt kann negativ sein, ermöglicht, Indizes umgekehrter Reihenfolge zu erstellen:Aber du musst auf das Vorzeichen des Schritts achten. Wenn es die falsche Richtung geht und stop nicht erreicht werden kann, gibt Python eine leere Liste zurück.Schritte können mit ausgelassenen und negativen Indizes kombiniert werden. Um jedes ungerade Element der Liste zu bekommen, schreibst du meine_schönen_zahlen[::2]:Mache Übung #5.Wenn du versuchst, auf Indizes außerhalb eines gültigen Bereichs zuzugreifen, wird Python einen IndexError32 auslösen. Wenn du also versuchst, das 6te Element (Index 5) einer fünfelementigen Liste zu holen, wird ein einfacher und unmissverständlicher Fehler generiert. Wenn jedoch deine Scheibe größer ist als der Bereich, wird sie ohne zusätzliche Warnung oder einen Fehler abgeschnitten. Daher wird für eine fünfelementige Liste my_pretty_numbers[:6] oder my_pretty_numbers[:600] beide alle Nummern zurückgeben (effektiv ist dies gleichwertig mit my_pretty_numbers[:]). Zudem, wenn die Scheibe leer ist (2:2, kann 2 nicht einschließen, weil es ein Stop-Wert ist, obwohl es auch von 2 aus startet) oder die gesamte Scheibe außerhalb des Bereichs liegt, wird Python eine leere Liste zurückgeben, wiederum wird weder eine Warnung noch ein Fehler generiert.Mache Übung #6.Python sind Listen dynamisch, daher kannst du immer Elemente hinzufügen oder entfernen, siehe die Liste der Methoden. Du kannst ein neues Element Ende der Liste über die Methode .append(<new_value>) hinzufügenOder du kannst insert(<index>, <new_value>) vor einem Element mit diesem Index verwenden. Leider bedeutet dies, dass du einen beliebig großen Index verwenden kannst und es fügt einen neuen Wert als letztes Element ein, ohne einen Fehler zu erzeugen.Du kannst ein Element mit seinem Index über pop(<index>) entfernen, beachte, dass das Element auch zurückgegeben wird. Wenn du den Index weglässt, entfernt pop() das letzte Element der Liste. Hier kannst du nur gültige Indizes verwenden.Mache Übung #7.","code":"meine_schönen_zahlen = [1, 2, 3, 4, 5, 6, 7]\nmeine_schönen_zahlen[4:0:-1]\n#> [5, 4, 3, 2]meine_schönen_zahlen = [1, 2, 3, 4, 5, 6, 7]\nmeine_schönen_zahlen[4:0:1]\n#> []meine_schönen_zahlen = [1, 2, 3, 4, 5, 6, 7]\nmeine_schönen_zahlen[::2]\n#> [1, 3, 5, 7]my_pretty_numbers = [1, 2, 3, 4, 5, 6, 7]\nmy_pretty_numbers.append(10)\nmy_pretty_numbers\n#> [1, 2, 3, 4, 5, 6, 7, 10]my_pretty_numbers = [1, 2, 3, 4, 5, 6, 7]\nmy_pretty_numbers.insert(2, 10)\nmy_pretty_numbers.insert(500, 20)\nmy_pretty_numbers\n#> [1, 2, 10, 3, 4, 5, 6, 7, 20]my_pretty_numbers = [1, 2, 3, 4, 5, 6, 7]\nmy_pretty_numbers.pop(-1)\n#> 7\nmy_pretty_numbers.pop(3)\n#> 4\nmy_pretty_numbers\n#> [1, 2, 3, 5, 6]"},{"path":"One-armed-bandit.html","id":"neukonzeption-des-einarmigen-banditen-spiels-mit-listen","chapter":"Kapitel 8 Einarmiger Bandit, aber mit Listen und Schleifen","heading":"8.3 Neukonzeption des Einarmigen Banditen-Spiels mit Listen","text":"Puh, das war viel über Listen33. Aber Work hard, play hard! Lass uns zum Einarmigen Banditen-Spiel zurückkehren, das du bereits implementiert hast, und es mithilfe von Listen neu gestalten. Letztere machen viel Sinn, wenn man mit mehreren Slots arbeitet. Erinnere dich die Regeln: Du hast drei Slots mit zufälligen Zahlen zwischen 1 und 5, wenn alle drei Zahlen übereinstimmen, gibst du “Drei Gleiche!” aus, wenn nur zwei Zahlen übereinstimmen, druckst du “Ein Paar!”. Implementiere dieses Spiel mit einer Liste anstelle von drei Variablen. der ersten Version, verwende die Notation <variable> = [<value1>, <value2>, ..., <valueN>], um sie zu definieren. Beachte außerdem, dass du bei der Verwendung von String-Formatierung alle Werte einem Tuple (eine eingefrorene Liste, mehr dazu späteren Kapiteln) oder einer Liste übergibst. Die gute Nachricht: Deine drei Werte befinden sich der Liste, daher kannst du sie für die String-Formatierung verwenden, denke nur die Anzahl der Slots, die du innerhalb des Format-Strings definieren musst.Ich weiß, es wird verlockend sein, einfach den bereits implementierten Code zu kopieren und zu bearbeiten, aber wir sind hier, um zu lernen, daher empfehle ich dringend, ihn von Grund auf neu zu schreiben. Es ist ein sehr einfaches Programm, es neu zu machen ist sehr einfach, aber es hilft dir, mehr zu üben.Setze deinen Code code01.py um.Jetzt mache dasselbe, aber beginne mit einer leeren Liste und füge zufällige Zahlen hinzu.Setze deinen Code code02.py um.","code":""},{"path":"One-armed-bandit.html","id":"for-loop","chapter":"Kapitel 8 Einarmiger Bandit, aber mit Listen und Schleifen","heading":"8.4 For-Schleife","text":"dem oben genannten Code mussten wir über drei Maulwürfe (Kreise) iterieren, die wir einer Liste hatten. Python bietet dafür ein spezielles Werkzeug: eine\n-Schleife, die über die Elemente jeder Sequenz iteriert (unsere Liste ist eine Sequenz!). Hier ist ein Beispiel:Hier wird der Code innerhalb der -Schleife dreimal wiederholt, weil es drei Elemente der Liste gibt. Bei jeder Iteration wird der nächste Wert aus der Liste einer temporären Variable a_number zugewiesen (siehe Ausgabe). Sobald der Wert einer Variablen zugewiesen ist, kannst du ihn wie jede andere Variable verwenden. Du kannst ihn ausgeben lassen (erster print), du kannst ihn ändern (zweite Zeile innerhalb der Schleife), seinen Wert verwenden, wenn du andere Funktionen aufrufst, usw. Um das besser zu würdigen, kopiere diesen Code eine temporäre Datei (nenne sie test01.py), setze einen Breakpoint auf die erste print Anweisung und dann verwende F10, um durch die Schleife zu springen und zu sehen, wie sich der Wert der Variable a_number bei jeder Iteration ändert und dann der zweiten Zeile innerhalb der Schleife modifiziert wird.Beachte, dass du die gleiche break Anweisung verwenden kannst wie bei der Schleife.Mache Übung #8.","code":"numbers = [2, 4, 42]\nfor a_number in numbers:\n    print(\"Der Wert der Variable a_number in dieser Iteration beträgt %d\"%(a_number))\n    a_number = a_number + 3\n    print(\"  Jetzt haben wir es um 3 erhöht: %d\"%(a_number))\n    print(\"  Jetzt verwenden wir es in einer Formel a_number / 10: %g\"%(a_number / 10))\n#> Der Wert der Variable a_number in dieser Iteration beträgt 2\n#>   Jetzt haben wir es um 3 erhöht: 5\n#>   Jetzt verwenden wir es in einer Formel a_number / 10: 0.5\n#> Der Wert der Variable a_number in dieser Iteration beträgt 4\n#>   Jetzt haben wir es um 3 erhöht: 7\n#>   Jetzt verwenden wir es in einer Formel a_number / 10: 0.7\n#> Der Wert der Variable a_number in dieser Iteration beträgt 42\n#>   Jetzt haben wir es um 3 erhöht: 45\n#>   Jetzt verwenden wir es in einer Formel a_number / 10: 4.5"},{"path":"One-armed-bandit.html","id":"verwendung-der-for-schleife-zur-erzeugung-von-slots","chapter":"Kapitel 8 Einarmiger Bandit, aber mit Listen und Schleifen","heading":"8.5 Verwendung der For-Schleife zur Erzeugung von Slots","text":"Verwende die -Schleife zweimal. Zuerst, wenn du die drei Slots erstellst: Beginne mit einer leeren Liste und füge drei zufällige Nummern mit einer -Schleife hinzu. Zweitens, beim Ausdrucken der Slots. Ich habe oben darauf hingewiesen, dass es einfacher ist, die Formatierung vorzunehmen, wenn man drei Werte einer Liste hat, aber hier sollst du, um der Übung willen, jeden Slot separat mit einer -Schleife ausdrucken.Setze deinen Code code03.py um.","code":""},{"path":"One-armed-bandit.html","id":"range","chapter":"Kapitel 8 Einarmiger Bandit, aber mit Listen und Schleifen","heading":"8.6 range() Funktion: Code N-mal wiederholen","text":"Manchmal musst du den Code mehrmals wiederholen. Stelle dir zum Beispiel vor, dass du einem Experiment 40 Versuche hast. Daher musst du den versuchsbezogenen Code 40 Mal wiederholen. Natürlich kannst du von Hand eine 40 Elemente lange Liste erstellen und darüber iterieren, aber Python hat dafür eine praktische range() Funktion. range(N) erzeugt N Ganzzahlen von 0 bis N-1 (gleiche Regel wie beim Slicing, dass bis zu, aber nicht einschließlich gilt), über die du einer -Schleife iterieren kannst.Du kannst das Verhalten der range() Funktion ändern, indem du einen Startwert und eine Schrittgröße angibst. Aber ihrer einfachsten Form ist range(N) ein praktisches Werkzeug, um den Code oft zu wiederholen. Beachte, dass du zwar immer eine temporäre Variable einer Schleife benötigst, sie manchmal aber überhaupt nicht verwendest. solchen Fällen solltest du _ (Unterstrich) als Variablennamen verwenden, um anzuzeigen, dass sie nicht verwendet wird.Alternativ kannst du range() verwenden, um durch die Indizes einer Liste zu schleifen (denke daran, du kannst immer auf ein einzelnes Listenelement über var[index] zugreifen). Mache genau das34! Ändere deinen Code , dass du die range() Funktion der -Schleife verwendest (wie kannst du die Anzahl der Iterationen, die du benötigst, aus der Länge der Liste berechnen?), verwende die temporäre Variable als Index für die Liste, um jedes Element zu zeichnen35. Wenn du unsicher bist, setze einen Breakpoint innerhalb (oder kurz vor) der Schleife und schreite durch deinen Code, um zu verstehen, welche Werte eine temporäre Schleifenvariable erhält und wie sie verwendet wird.","code":"for x in range(3):\n    print(\"Der Wert von x ist %d\"%(x))\n#> Der Wert von x ist 0\n#> Der Wert von x ist 1\n#> Der Wert von x ist 2for _ in range(2):\n    print(\"Ich werde zweimal wiederholt!\")\n#> Ich werde zweimal wiederholt!\n#> Ich werde zweimal wiederholt!"},{"path":"One-armed-bandit.html","id":"informationen-zum-slot-index-hinzufügen","chapter":"Kapitel 8 Einarmiger Bandit, aber mit Listen und Schleifen","heading":"8.7 Informationen zum Slot-Index hinzufügen","text":"der vorherigen Version des Spiels hatten wir keine Möglichkeit, den Slot-Index anzugeben. Es ist zwar offensichtlich der Reihenfolge im Ausdruck erkennbar, aber es wäre schöner, wenn wir explizit \"Slot #1: 2\" ausdrucken würden. Verwende die Funktion range() um Indizes von Slots zu generieren, schlaufe über diese Indizes und drucke sie “Slot # : ” aus. Beachte jedoch, dass die Indizes Python bei Null beginnen, unsere Slots aber bei 1 starten (kein Slot Null!). Überlege dir, wie du dies einem Ausdruck korrigieren könntest.Gib deinen Code code04.py ein.","code":""},{"path":"One-armed-bandit.html","id":"enumerate","chapter":"Kapitel 8 Einarmiger Bandit, aber mit Listen und Schleifen","heading":"8.8 Über Index und Element gleichzeitig schleifen mit Listenaufzählung","text":"Es passiert ziemlich oft, dass du sowohl über die Indizes als auch über die Elemente einer Liste schleifen musst, daher hat Python eine praktische Funktion dafür: enumerate()! Wenn du anstelle einer Liste über enumerate() iterierst, erhältst du ein Tupel mit (Index, Wert). Hier ist ein Beispiel:Verwende enumerate, um gleichzeitig über den Index und das Element zu schleifen und einen Slot nach dem anderen auszudrucken. Sieh dir den start Parameter der Funktion , um sicherzustellen, dass dein Index jetzt bei 1 beginnt.Gib deinen Code code05.py ein.","code":"letters = ['a', 'b', 'c']\nfor index, letter in enumerate(letters):\n    print('%d: %s'%(index, letter))\n#> 0: a\n#> 1: b\n#> 2: c"},{"path":"One-armed-bandit.html","id":"list-comprehension","chapter":"Kapitel 8 Einarmiger Bandit, aber mit Listen und Schleifen","heading":"8.9 List Comprehension","text":"Die List Comprehension bietet eine elegante und leicht zu lesende Möglichkeit, Elemente einer Liste zu erzeugen, zu ändern und/oder zu filtern und dabei eine neue Liste zu erstellen. Die allgemeine Struktur lautetSchauen wir uns Beispiele , um zu verstehen, wie es funktioniert. Stell dir vor, du hast eine Liste numbers = [1, 2, 3] und du musst jede Zahl um 1 erhöhen36. Du kannst es machen, indem du eine neue Liste erstellst und 1 zu jedem Element im  Teil hinzufügst:Beachte, dass dies äquivalent ist zuOder stelle dir vor, du musst jedes Element einen String umwandeln. Das kannst du einfach machenWie wäre die äquivalente Form mit einer normalen -Schleife? Schreibe beide Versionen des Codes Jupiter cells und überprüfe, ob die Ergebnisse gleich sind.Mache Übung #9 im Jupyter Notebook.Implementiere nun den unten stehenden Code mit Hilfe der List Comprehension. Überprüfe, ob die Ergebnisse übereinstimmen.Mache Übung #10 im Jupyter Notebook.Wie oben bemerkt, kannst du auch eine bedingte Anweisung verwenden, um zu filtern, welche Elemente die neue Liste weitergegeben werden. unserem Zahlenbeispiel können wir Zahlen beibehalten, die größer als 1 sindManchmal wird die gleiche Aussage drei Zeilen statt einer geschrieben, um das Lesen zu erleichtern:Natürlich kannst du die Transformation und Filterung einer einzigen Aussage kombinieren. Schreibe einen Code, der alle Elemente unter 2 herausfiltert und 4 zu ihnen hinzufügt.Mache Übung #11 im Jupyter Notebook.","code":"new_list = [<Transformation-des-Elements> for item in old_list if <Bedingung-gegeben-das-Element>]numbers = [1, 2, 3]\nnumbers_plus_1 = [item + 1 for item in numbers]numbers = [1, 2, 3]\nnumbers_plus_1 = []\nfor item in numbers:\n    numbers_plus_1.append(item + 1)numbers = [1, 2, 3]\nnumbers_as_strings = [str(item) for item in numbers]strings = ['1', '2', '3']\nnumbers = []\nfor astring in strings:\n    numbers.append(int(astring) + 10)numbers = [1, 2, 3]\nnumbers_greater_than_1 = [item for item in numbers if item > 1]numbers = [1, 2, 3]\nnumbers_greater_than_1 = [item \n                          for item in numbers\n                          if item > 1]"},{"path":"One-armed-bandit.html","id":"verwendung-von-list-comprehension-zur-erstellung-von-drei-slots","chapter":"Kapitel 8 Einarmiger Bandit, aber mit Listen und Schleifen","heading":"8.10 Verwendung von List Comprehension zur Erstellung von drei Slots","text":"Lass uns List Comprehension verwenden, um einer einzigen Zeile drei Slots zu erstellen. Die gute Nachricht ist, dass wir uns das Erstellen einer leeren Liste und die Verwendung von append ersparen. Die schlechte Nachricht ist, dass du darüber nachdenken musst, über welche Werte du schleifen möchtest, wenn du drei Zufallszahlen erzeugen willst. Tipp: schau dir die Funktion range() erneut und überlege, ob du die temporäre Schleifenvariable tatsächlich verwenden wirst.Gib deinen Code code06.py ein.","code":""},{"path":"One-armed-bandit.html","id":"fertig-für-den-tag","chapter":"Kapitel 8 Einarmiger Bandit, aber mit Listen und Schleifen","heading":"8.11 Fertig für den Tag","text":"Ausgezeichnet! Verpacke den Ordner mit dem Code und dem Notebook eine Zip-Datei und reiche sie ein!","code":""},{"path":"hunt-the-wumpus.html","id":"hunt-the-wumpus","chapter":"Kapitel 9 Jagd auf den Wumpus","heading":"Kapitel 9 Jagd auf den Wumpus","text":"Heute werden wir ein Text-Abenteuer-Computerspiel Jagd auf den Wumpus programmieren: “Im Spiel bewegt sich der Spieler durch eine Reihe von miteinander verbundenen Höhlen, die einem Dodekaeder angeordnet sind, während sie ein Monster namens Wumpus jagen. Das rundenbasierte Spiel hat den Spieler versucht, tödliche bodenlose Gruben und”super Fledermäuse” zu vermeiden, die sie durch das Höhlensystem bewegen; das Ziel ist es, einen ihrer “krummen Pfeile” durch die Höhlen zu schießen, um den Wumpus zu töten…”Wie zuvor werden wir mit einem sehr einfachen Programm beginnen und es Schritt für Schritt zur endgültigen Version ausbauen. Der Zweck dieses Kapitels ist es, die Fähigkeiten, die du bereits hast, zu festigen, indem du sie einem komplexeren Spiel mit mehreren Funktionen, Spielobjekten usw. anwendest. Vergiss nicht, die gesamte Datei zu kommentieren (oberer mehrzeiliger Kommentar, um zu erklären, worum es hier geht), strukturiere deinen Code, kommentiere einzelne Abschnitte und verwende sinnvolle Variablen- und Funktionsnamen. Deine Codekomplexität wird ziemlich hoch sein, daher wirst du den guten Stil benötigen, um dir dabei zu helfen.Hol dir das Übungsnotebook, bevor wir starten.","code":""},{"path":"hunt-the-wumpus.html","id":"kapitel-konzepte","chapter":"Kapitel 9 Jagd auf den Wumpus","heading":"9.1 Kapitel Konzepte","text":"Verwenden von sets.","code":""},{"path":"hunt-the-wumpus.html","id":"ein-höhlensystem","chapter":"Kapitel 9 Jagd auf den Wumpus","heading":"9.2 Ein Höhlensystem","text":"unserem Spiel wird der Spieler durch ein System von Höhlen wandern, wobei jede Höhle mit drei anderen Höhlen verbunden ist. Das Layout der Höhle wird eine KONSTANTE sein, daher definieren wir es zu Beginn des Programms wie folgt.Lassen uns das entschlüsseln. Du hast eine Liste von zwanzig Elementen (Höhlen). Innerhalb jeden Elements ist eine Liste von verbundenen Höhlen (Höhlen, zu denen du reisen kannst). Das bedeutet, dass du, wenn du Höhle Nr. 1 (Index 0) bist, verbunden bist mit CONNECTED_CAVES[0] → [1, 4, 5] (beachte, dass auch diese Zahlen im Inneren nullbasierte Indizes sind!). Um also zu sehen, welchen Index die zweite mit der ersten verbundene Höhle hat, würdest du CONNECTED_CAVES[0][1] schreiben (du erhältst das erste Element der Liste und dann das zweite Element der Liste aus dem Inneren).Um dem Spieler das Herumwandern zu ermöglichen, müssen wir zunächst wissen, wo er sich befindet. Lass uns eine neue Variable namens player_location definieren und einen zufälligen vordefinierten Index zuweisen. Denke über den niedrigsten gültigen Index nach, den du Python haben kannst (diesen musst du fest verdrahten). Um den höchstmöglichen gültigen Index zu berechnen, musst du die Gesamtzahl der Höhlen kennen, d.h., die Länge - len() - der Liste. Denke daran, dass die Indizes Python nullbasiert sind, also überlege, wie du den höchsten gültigen Index aus der Länge berechnest! Nutze diese beiden Indizes und setze den Spieler eine zufällige Höhle. Hierfür kannst du die Funktion randint verwenden. Schau den vorherigen Kapiteln nach, falls du vergessen hast, wie man sie benutzt.Unser Spieler muss wissen, wohin er gehen kann, also müssen wir jeder Runde die Informationen darüber ausgeben, welcher Höhle sich der Spieler befindet und über die verbindende Höhle (verwende String-Formatierung, um dies schön aussehen zu lassen). Lass uns das unser erster Code-Ausschnitt für das Spiel sein. Der Code sollte aussehenFüge deinen Code code01.py ein.","code":"CONNECTED_CAVES = [[1, 4, 5], [2, 0, 7], [3, 1, 9], [4, 2, 11], \n                   [0, 3, 13], [6, 14, 0], [7, 5, 15], [8, 6, 1], \n                   [9, 7, 16], [10, 8, 2], [11, 9, 17], [12, 10, 3], \n                   [13, 11, 18], [14, 12, 4], [5, 13, 19], [16, 19, 6], \n                   [17, 15, 8], [18, 16, 10], [19, 17, 12], [15, 18, 14]]# Import randint\n\n# Definiere CONNECTED_CAVES (einfach die Definition kopieren und einfügen)\n\n# Erstelle Variable `player_location` und weise ihr einen zufälligen gültigen Index zu \n# Spieler in eine zufällige Höhle setzen\n\n# Ausgabe des aktuellen Höhlenindexes und der Indizes der verbundenen Höhlen. Verwende String-Formatierung."},{"path":"hunt-the-wumpus.html","id":"herumwandern","chapter":"Kapitel 9 Jagd auf den Wumpus","heading":"9.3 Herumwandern","text":"Jetzt, da der Spieler “sehen” kann, wo er sich befindet, lass ihn herumwandern! Verwende die Funktion input(), um den Index der Höhle abzufragen, die der Spieler gehen möchte, und “bewege” den Spieler diese Höhle (welche Variable musst du ändern?). Denke daran, dass input() einen String zurückgibt, daher musst du ihn explizit eine Ganzzahl umwandeln (siehe das Zahlenraten Spiel, wenn du vergessen hast, wie man das macht). Gib vorerst nur gültige Zahlen ein, da wir später Überprüfungen hinzufügen werden. Um das Herumwandern kontinuierlich zu gestalten, setze es eine -Schleife, sodass der Spieler herumwandert, bis er zur Höhle Nr. 5 (Index 4!) gelangt. Wir werden später sinnvollere Spiel-Ende-Bedingungen haben, aber dies ermöglicht es dir, das Spiel zu beenden, ohne es von außen zu unterbrechen. Der Code sollte wie folgt aussehen (achte auf deine Einrückungen!).Füge deinen Code code02.py ein.","code":"# import randint function\n\n# define CONNECTED_CAVES (simply copy-paste the definition)\n\n# create `player_location` variable and set it to a random valid cave index\n\n# solange der Spieler nicht in der Höhle Nr. 5 ist (Index 4):\n    # Ausgabe des aktuellen Standorts und Liste der verbundenen Höhlen. Verwende String-Formatierung.\n    # Eingabeaufforderung, in welche Höhle der Spieler gehen möchte und \"verschiebung\" des Spielers\n    \n# Ausgabe einer schönen Game-Over-Nachricht"},{"path":"hunt-the-wumpus.html","id":"prüfen-ob-ein-wert-in-der-liste-istin-collection","chapter":"Kapitel 9 Jagd auf den Wumpus","heading":"9.4 Prüfen, ob ein Wert in der Liste ist[#in-collection]","text":"Momentan vertrauen wir dem Spieler (naja, dir), den korrekten Index für die Höhle einzugeben. Daher wird das Programm den Spieler zu einer neuen Höhle versetzen, selbst wenn du einen Index einer Höhle eingibst, die nicht mit der aktuellen verbunden ist. Noch schlimmer ist, dass es versuchen wird, den Spieler zu einer undefinierten Höhle zu versetzen, wenn du einen Index größer als 19 eingibst. Um zu prüfen, ob ein eingegebener Index mit einer der verbundenen Höhlen übereinstimmt, musst du die bedingte Anweisung   verwenden. Die Idee ist einfach, wenn der Wert der Liste ist, ist die Aussage True, wenn nicht, ist sie False.Beachte, dass du jeweils einen Wert/Objekt prüfen kannst. Da eine Liste auch ein einzelnes Objekt ist, prüfst du, ob sie ein Element der anderen Liste ist, und nicht, ob alle oder einige ihrer Elemente darin enthalten sind.Mache Übung #1.","code":"x = [1, 2, 3]\nprint(1 in x)\n#> True\nprint(4 in x)\n#> Falsex = [1, 2, [3, 4]]\n# Das ist Falsch, weil x kein Element [1, 2] hat, sondern nur 1 und 2 (getrennt voneinander).\nprint([1, 2] in x)\n#> False\n\n# Das ist wahr, weil x das Element [3, 4] hat.\nprint([3, 4] in x)\n#> True"},{"path":"hunt-the-wumpus.html","id":"gültigen-höhlenindex-prüfen","chapter":"Kapitel 9 Jagd auf den Wumpus","heading":"9.5 Gültigen Höhlenindex prüfen","text":"Jetzt, da du weißt, wie man prüft, ob ein Wert der Liste ist, lass uns das verwenden, um den Höhlenindex zu validieren. Bevor du den Spieler bewegst, musst du jetzt prüfen, ob der eingegebene Index der Liste der verbundenen Höhlen enthalten ist. Wenn dies True ist, bewegst du den Spieler wie zuvor. Andernfalls gib eine Fehlermeldung aus, z. B. “Falscher Höhlenindex!” ohne den Spieler zu bewegen. Die Schleife stellt sicher, dass der Spieler erneut zur Eingabe aufgefordert wird, sodass wir uns darüber im Moment keine Sorgen machen müssen. Hier musst du eine temporäre Variable erstellen, um die Eingabe des Spielers zu speichern, da du ihre Gültigkeit prüfen musst bevor du entscheidest, ob du den Spieler bewegst. Du machst das Letztere nur, wenn der Wert dieser temporären Variable ein Index einer der verbundenen Höhlen ist!Ändere deinen Code, um die Überprüfung der Eingabegültigkeit einzuschließen.Füge deinen Code code03.py ein.","code":""},{"path":"hunt-the-wumpus.html","id":"isdigit","chapter":"Kapitel 9 Jagd auf den Wumpus","heading":"9.6 Überprüfung, ob eine Zeichenfolge in eine ganze Zahl umgewandelt werden kann","text":"Es gibt eine weitere Gefahr bei unserer Eingabe: Der Spieler ist nicht garantiert eine gültige Ganzzahl einzugeben! Bisher haben wir uns darauf verlassen, dass du dich benimmst, aber im wirklichen Leben werden die Leute, selbst wenn sie nicht absichtlich versuchen, dein Programm zu stören, gelegentlich die falsche Taste drücken. Daher müssen wir überprüfen, ob die Zeichenfolge, die sie eingegeben haben, eine Ganzzahl umgewandelt werden kann.Die Python-Zeichenkette ist ein Objekt (mehr dazu ein paar Kapiteln) mit verschiedenen Methoden, die es ermöglichen, verschiedene Operationen ihnen durchzuführen. Eine Teilmenge von Methoden ermöglicht es dir, eine grobe Überprüfung ihres Inhalts durchzuführen. Die Methode, die uns interessiert, ist str.isdigit(), die überprüft, ob alle Symbole Ziffern sind und dass die Zeichenfolge nicht leer ist (sie hat mindestens ein Symbol). Du kannst dem obigen Link folgen, um andere Alternativen wie str.islower(), str.isalpha(), usw. zu überprüfen.Mache Übung #2.","code":""},{"path":"hunt-the-wumpus.html","id":"überprüfung-der-gültigen-ganzzahleneingabe","chapter":"Kapitel 9 Jagd auf den Wumpus","heading":"9.7 Überprüfung der gültigen Ganzzahleneingabe","text":"Ändere den Code, der die Eingabe vom Benutzer erhält. Speichere zuerst die rohe Zeichenkette (nicht eine Ganzzahl umgewandelt!) einer Zwischenvariable. Wenn diese Zeichenkette dann nur aus Ziffern besteht, konvertiere sie eine Ganzzahl und überprüfe dann, ob es sich um einen gültigen verbundenen Höhlenindex handelt (Verschieben des Spielers oder Ausgeben einer Fehlermeldung). Wenn die Eingabezeichenkette jedoch nicht nur aus Ziffern besteht, gib nur die Fehlermeldung aus (“Ungültiger Höhlenindex!”). Dies bedeutet, dass du eine -Anweisung der -Anweisung haben musst!Füge deinen Code code04.py ein.","code":""},{"path":"hunt-the-wumpus.html","id":"den-code-in-einer-funktion-kapseln","chapter":"Kapitel 9 Jagd auf den Wumpus","heading":"9.8 Den Code in einer Funktion kapseln","text":"Dein Code ist bereits seiner Komplexität gewachsen, mit zwei Überprüfungen auf einer Eingabefunktion, daher macht es Sinn, diese Komplexität zu verbergen, indem man ihn einer Funktion kapselt. Nennen wir es input_cave, da es nur eine Eingabe für einen gültigen Index einer verbundenen Höhle sein wird. Du hast bereits den gesamten Code, den du brauchst, aber denke darüber nach, welchen Parameter (oder welche Parameter?) es benötigt: Du kannst nicht direkt auf die globale Konstante CONNECTED_CAVES oder die globale Variable player_location zugreifen!Lege die Funktion eine separate utils.py Datei, dokumentiere sowohl die Datei als auch die Funktion! Importiere und verwende sie im Hauptskript. Dein Programm sollte genau wie zuvor laufen!Lege input_cave utils.py ab.\n\nAktualisiere deinen Code code05.py.","code":""},{"path":"hunt-the-wumpus.html","id":"sets","chapter":"Kapitel 9 Jagd auf den Wumpus","heading":"9.9 Mengen","text":"Bisher hatten wir nur den Spieler im Auge und wir haben das getan, indem wir seinen Standort der Variable player_location gespeichert haben. Da wir jedoch mehr Spielobjekte hinzufügen werden (bodenlose Gruben, Fledermäuse, den Wumpus), müssen wir den Überblick behalten, wer-wo-ist, damit wir sie nicht einer bereits besetzten Höhle platzieren. Wir werden dies als Gelegenheit nutzen, um etwas über sets zu lernen: eine ungeordnete Sammlung von einzigartigen Elementen. Diese sind eine Implementierung von mathematischen Mengen und haben Eigenschaften, die für unsere notwendige Buchhaltung nützlich sind. Du erstellst eine Menge über die Funktion set() und es kann entweder eine leere Menge sein (zu der du .add() hinzufügen kannst) oder es kann eine Liste (oder ein Tupel) eine Menge umwandeln, aber es wird alle Duplikate entfernen.Wenn du zwei Mengen hast, kannst du verschiedene Operationen durchführen, um die Vereinigung, Schnittmengeoder Differenz zwischen zwei Mengen zu finden (siehe Grundlegende Operationen der Wikipedia.Mache Übung #3.Beachte bitte, dass die Menge nicht geordnet ist, dass du nicht auf ihre einzelnen Elemente zugreifen kannst. Allerdings kannst du genauso wie bei Listen überprüfen, ob ein Wert der Menge ist.","code":"# Beginnen mit einer leeren Menge\na_set = set()\na_set.add(1)\nprint(a_set)\n#> {1}\na_set.intersection()\n#> {1}\n\n# Umwandlung einer Liste in eine Menge\nprint(set([1, 2, 2, 3]))\n#> {1, 2, 3}a_set = set([1, 2, 3, 3])\n3 in a_set\n#> True"},{"path":"hunt-the-wumpus.html","id":"die-belegung-von-höhlen-im-auge-behalten","chapter":"Kapitel 9 Jagd auf den Wumpus","heading":"9.10 Die Belegung von Höhlen im Auge behalten","text":"Jetzt, da du Mengen kennst, wird es leicht sein, den Überblick über die belegten Höhlen zu behalten. Im globalen Skript benötigen wir eine Variable, die die Indizes aller belegten Höhlen einer Menge enthält (du startest mit einer leeren Menge, da alle Höhlen anfangs leer sind). Außerdem benötigen wir eine Funktion, die einen gültigen Index für eine freie Höhle generiert. Dies basiert auf 1) dem Bereich der gültigen Indizes (denke darüber nach, wie du diese Informationen wirtschaftlichsten die Funktion weitergeben kannst, du kommst mit nur einer Ganzzahl aus) und 2) den Indizes der bereits belegten Höhlen (wir haben das der globalen Variable, die du definierst, aber du kannst auf diese Variable nicht direkt zugreifen, also musst du diese Information als Parameter übergeben!).Wir werden diese Funktion zweimal schreiben. Zunächst verwenden wir eine Brute-Force-Methode, um eine freie Höhle zu finden: Erzeuge einfach einer Schleife einen gültigen zufälligen Index, bis er nicht der Menge der belegten Höhlen ist. Da er es nicht ist, handelt es sich um eine gültige freie Höhle, also solltest du die Schleife verlassen und diesen Wert zurückgeben. Nenne diese Funktion find_vacant_cave_bruteforce, implementiere und dokumentiere sie utils.py, teste sie, indem du sie ein Jupiter-Notebook kopierst und mehrmals mit verschiedenen fest codierten Mengen von belegten Höhlen ausführst. Überprüfen, dass die gültige Höhle nie der Menge der belegten Höhlen ist.Lege find_vacant_cave_bruteforce utils.py ab.\n\nTeste es Übung 4.Die Funktion, die du geschrieben hast, funktioniert, ist aber sehr ineffizient und kann ziemlich problematisch sein, wenn unsere Menge belegten Höhlen lang ist, da du viele Versuche benötigst, bevor du zufällig eine freie findest. Wir können das besser machen, indem wir Mengenoperationen verwenden: Wir können range generieren, es eine Menge umwandeln, belegte Höhlen davon subtrahieren (das ergibt eine Menge von unbesetzten Höhlen) und dann einen Wert auswählen (beachte aber, dass du dafür eine Menge eine Liste umwandeln musst!). Im letzten Schritt wählen wir zufällig, aber nur aus freien Höhlen, dass wir keine Schleifen und mehrere Versuche benötigen, um es richtig zu machen.Implementiere die Funktion find_vacant_cave und teste sie mit dem gleichen Code wie zuvor. Du solltest immer nur einen gültigen Index für eine freie Höhle erhalten.Lege find_vacant_cave utils.py ab.\n\nTeste es Übung 5.","code":""},{"path":"hunt-the-wumpus.html","id":"platzieren-von-bodenlosen-gruben","chapter":"Kapitel 9 Jagd auf den Wumpus","heading":"9.11 Platzieren von bodenlosen Gruben","text":"Jetzt, da wir das Gerüst haben, fügen wir bodenlose Gruben hinzu. Die Idee ist einfach, wir platzieren zwei davon zufälligen freien Höhlen. Wenn der Spieler eine Höhle mit einer bodenlosen Grube stolpert, fällt er hinein und stirbt (Spielende). Wir werden den Spieler jedoch warnen, dass seine gegenwärtige Höhle neben einer bodenlosen Grube ist, ohne ihm zu sagen, welcher Höhle sie genau ist.Zuerst fügen wir sie hinzu. Dazu erstellen wir eine neue Konstante NUMBER_OF_BOTTOMLESS_PITS (ich schlage vor, dass wir sie auf 2 setzen, aber du kannst mehr oder weniger davon haben) und eine neue Variable (bottomless_pits), die eine Menge von Indizes von Höhlen mit bodenlosen Gruben ihnen enthält. Füge bodenlose Gruben mit einer -Schleife hinzu: Bei jeder Iteration erhalte einen Index einer leeren Höhle (über die Funktion find_empty_cave, denke über ihre Parameter nach), füge diesen Index sowohl zu 1) bottomless_pits als auch zu 2) occupied_caves hinzu, dass du 1) weißt, wo die bodenlosen Gruben sind und 2) weißt, welche Höhlen belegt sind. Hier ist der Code-Umriss für den Initialisierungsteil (kopiere die Hauptschleife noch nicht). Überprüfe, ob die Zahlen sinnvoll sind (die Anzahl der Höhlen entspricht deinen Erwartungen, der Wert liegt im erwarteten Bereich, es gibt keine Duplikate, usw.)Teste den Code zum Erstellen von bodenlosen Gruben  Übung 6.","code":"# Erstelle die Variable `occupied_caves` und initialisiere sie als leere Menge\n# Erstelle die Variable `bottomless_pits` und initialisiere sie als leere Menge\n# Benutze eine for-Schleife und die range-Funktion, um die for-Schleife NUMBER_OF_BOTTOMLESS_PITS-mal zu wiederholen\n#     Generiere einen neuen Standort für die bodenlose Grube über die Funktion find_empty_cave() und füge ihn zu beiden Mengen hinzu"},{"path":"hunt-the-wumpus.html","id":"in-eine-bodenlose-grube-fallen","chapter":"Kapitel 9 Jagd auf den Wumpus","heading":"9.12 In eine bodenlose Grube fallen","text":"Jetzt fügen wir eine der Möglichkeiten hinzu, das Spiel zu beenden: Der Spieler fällt eine bodenlose Grube. Dafür müssen wir nur überprüfen, ob sich der Spieler jeder Runde gerade einer Höhle befindet, der eine bodenlose Grube ist. Wenn das der Fall ist, ist die Höhle des Spielers tatsächlich der Liste der bodenlosen Gruben, drucke eine traurige Spiel-Ende-Nachricht und breche aus der Schleife aus. Darüber hinaus verändern wir die Bedingung der Schleife zu True:, dass die einzige Möglichkeit, das Spiel zu beenden, darin besteht, die Grube zu fallen (nicht ganz fair für den Spieler, aber das werden wir später korrigieren).Füge den Code für das Platzieren von bodenlosen Gruben und das Hineinfallen sie das Hauptskript ein. Drucke die Höhlen mit bodenlosen Gruben zu Beginn des Programs aus und wandere sie hinein, um sicherzustellen, dass dies das Spiel korrekt beendet.Aktualisiere deinen Code code06.py.","code":""},{"path":"hunt-the-wumpus.html","id":"warnung-vor-einer-bodenlosen-grube","chapter":"Kapitel 9 Jagd auf den Wumpus","heading":"9.13 Warnung vor einer bodenlosen Grube","text":"Wir müssen dem Spieler die Chance geben, das Schicksal zu vermeiden, eine bodenlose Grube zu fallen, indem wir ihn warnen, dass eine (oder zwei oder mehr) der Nähe sind. Zu diesem Zweck müssen wir zusätzliche Informationen vor ihrer Entscheidung, ihren Zug zu machen, ausdrucken. Deine Aufgabe ist es, zu überprüfen, ob eine Höhle sowohl im Set bottomless_pits als auch der aktuellen Liste der verbundenen Höhlen ist. Du kannst eine -Schleife verwenden, aber die Verwendung von Mengenoperationen ist viel einfacher, du musst nur überprüfen, ob eine Schnittmenge dieser beiden Mengen leer ist (sie hat null Länge). Wenn mindestens eine der verbundenen Höhlen eine bodenlose Grube sich hat, drucke “Du fühlst einen Hauch!”.Füge deinen Code code07.py ein.","code":""},{"path":"hunt-the-wumpus.html","id":"platzierung-von-fledermäusen-und-warnung-vor-ihnen","chapter":"Kapitel 9 Jagd auf den Wumpus","heading":"9.14 Platzierung von Fledermäusen und Warnung vor ihnen","text":"Wir brauchen mehr Nervenkitzel! Lassen wir Fledermäusen hinzu. Sie leben Höhlen, der Spieler kann sie hören, wenn sie einer verbundenen Höhle sind (“Du hörst Flügelschläge!”), aber wenn der Spieler unabsichtlich die Höhle mit Fledermäusen betritt, tragen sie den Spieler zu einer zufälligen Höhle.Die Platzierung der Fledermäuse ist analog zur Platzierung der bodenlosen Gruben. Du brauchst eine Konstante, die die Anzahl der Fledermauskolonien bestimmt (z.B. ANZAHL_DER fledermaeuse und setzte diese auf 2 oder eine andere von dir bevorzugte Zahl), eine Variable, die ein Set mit Indizes von Höhlen mit Fledermäusen hält (z.B. fledermaeuse), und du musst zufällige leere Höhlen auswählen und sie genau bats speichern, wie du es bei den bodenlosen Gruben getan hast. Drucke den Ort der Fledermäuse zu Diagnosezwecken aus.Die Warnung vor den Fledermäusen folgt auch der gleichen Logik wie bei den bodenlosen Gruben: Wenn eine der verbundenen Höhlen Fledermäuse sich hat, druckst du \"Du hörst Flügelschläge!\" aus.Füge deinen Code code08.py ein.","code":""},{"path":"hunt-the-wumpus.html","id":"der-spieler-wird-von-fledermäusen-in-eine-zufällige-höhle-transportiert","chapter":"Kapitel 9 Jagd auf den Wumpus","heading":"9.15 Der Spieler wird von Fledermäusen in eine zufällige Höhle transportiert","text":"Wenn sich der Spieler einer Höhle mit Fledermäusen befindet, transportieren diese ihn eine zufällige Höhle, unabhängig davon, ob die Höhle bewohnt ist oder nicht (also jede Höhle ist eine gültige Höhle). können die Fledermäuse den Spieler eine Höhle tragen:mit einer weiteren Fledermaus-Kolonie, und diese wird den Spieler wieder transportieren.mit einer bodenlosen Grube, und der Spieler wird hineinfallen.später die Höhle mit dem Wumpus (der Spieler überlebt das möglicherweise nicht und du implementierst das jetzt nicht).Denk darüber nach:wann du die Anwesenheit von Fledermäusen überprüfst (vor oder nach der Überprüfung auf eine bodenlose Grube?),überprüfst du einmal (mit Hilfe von ) oder ein-oder-mehrere Male (mit Hilfe von )Teste deinen Code, indem du eine Höhle mit Fledermäusen gehst (drucke ihren Standort Anfang aus, damit du weißt, wo du hingehen musst).Füge deinen Code code09.py ein.","code":""},{"path":"hunt-the-wumpus.html","id":"hinzufügen-von-wumpus-und-vom-ihm-gefressen-werden.","chapter":"Kapitel 9 Jagd auf den Wumpus","heading":"9.16 Hinzufügen von Wumpus (und vom ihm gefressen werden).","text":"Bis jetzt hast du einen Spieler hinzugefügt (Einzelspieler, Standort als Integer gespeichert), bodenlose Gruben (mehrzahl, Standorte einem Set gespeichert) und Fledermäusen (ebenfalls Mehrzahl). Füge Wumpus hinzu!Erstelle eine neue Variable (wumpus?) und platziere Wumpus einer freien Höhle. Drucke den Standort von Wumpus zu Debugging-Zwecken aus.Warne vor Wumpus im selben Code, der vor Gruben und Fledermäusen warnt. Die Logik ist die gleiche, aber die Überprüfung ist einfacher, da du dir nur um einen einzigen Wumpus-Standort Sorgen machen musst. Der kanonische Warnungstext lautet \"Du riechst einen Wumpus!\".Überprüfe, ob der Spieler der gleichen Höhle wie Wumpus ist. Falls dies der Fall ist, ist das Spiel vorbei, da der Spieler von einem hungrigen Wumpus gefressen wird. Dies ähnelt dem Spielende aufgrund des Sturzes eine bodenlose Grube. Überlege, ob die Überprüfung vor oder nach der Überprüfung auf Fledermäuse erfolgen sollte.Teste deinen Code, indem du eine Höhle mit Wumpus gehst (drucke ihren Standort Anfang aus, damit du weißt, wohin du gehen musst).Füge deinen Code code10.py ein.","code":""},{"path":"hunt-the-wumpus.html","id":"dem-spieler-eine-chance-geben.","chapter":"Kapitel 9 Jagd auf den Wumpus","heading":"9.17 Dem Spieler eine Chance geben.","text":"Geben wir dem Spieler eine Chance. Wenn er die Höhle mit dem Wumpus kommt, erschreckt er ihn. Dann läuft Wumpus entweder weg zu einer zufälligen angrenzenden Höhle (neu) oder bleibt stehen und frisst den Spieler. Erstelle zunächst eine neue Konstante, die die Wahrscheinlichkeit definiert, dass Wumpus wegrennt, zum Beispiel P_WUMPUS_AENGSTLICH. den Implementierungen, die ich gefunden habe, beträgt sie typischerweise 0,25, aber verwende einen Wert, den du für angemessen hältst.Wenn also der Spieler der Höhle mit dem Wumpus ist, ziehe eine zufällige Zahl zwischen 0 und 1 (verwende dafür die Funktion uniform). Sie ist Teil der random Bibliothek, daher lautet der Aufruf random.uniform(...). Denke daran, dass du entweder die gesamte Bibliothek importieren und dann deren Funktion durch Voranstellen des Bibliotheksnamens aufrufen kannst oder du importierst nur eine bestimmte Funktion über ... import .... Sobald du die Zahl zwischen 0 und 1 generiert hast, wenn diese Zahl kleiner ist als die Wahrscheinlichkeit, dass der Wumpus Angst hat, bewege ihn zu einer zufälligen angrenzenden Höhle (Fledermäuse ignorieren Wumpus und es klammert sich die Decke der Höhlen, bodenlose Gruben sind also kein Problem für ihn). Eine nützliche Funktion, die du bereits verwendet hast, ist choice(), auch Teil der random Bibliothek. Andernfalls, wenn Wumpus nicht weggeschreckt wurde, wird der Spieler gefressen und das Spiel ist vorbei (das einzige Ergebnis code10).Füge deinen Code code11.py ein.","code":""},{"path":"hunt-the-wumpus.html","id":"flug-eines-krummen-pfeils","chapter":"Kapitel 9 Jagd auf den Wumpus","heading":"9.18 Flug eines krummen Pfeils","text":"Unser Spieler ist mit krummen Pfeilen bewaffnet, die durch Höhlen fliegen können. Die Regeln für seinen Flug sind folgende:Der Spieler entscheidet, welche Höhle er einen Pfeil schießt und wie weit der Pfeil fliegt (von 1 bis 5 Höhlen).Jedes Mal, wenn der Pfeil die nächste Höhle fliegen muss, wird diese Höhle zufällig aus den angrenzenden Höhlen ausgewählt, mit Ausnahme der Höhle, aus der er kam (also der Pfeil kann keine 180° Wende machen und es stehen nur zwei von drei Höhlen zur Auswahl).Wenn der Pfeil eine Höhle mit Wumpus fliegt, ist er besiegt und das Spiel ist gewonnen.Wenn der Pfeil eine Höhle mit dem Spieler fliegt, dann hat er einen unbeabsichtigten Selbstmord begangen und das Spiel ist verloren.Wenn der Pfeil seine letzte Höhle erreicht hat (basierend darauf, wie weit der Spieler schießen wollte) und die Höhle leer ist, fällt er auf den Boden.Fledermäuse oder bodenlose Gruben haben keinen Einfluss auf den Pfeil.Die Gesamtzahl der Pfeile, die der Spieler zu Beginn hat, sollte der Konstante PFEIL_ANZAHL definiert werden (z.B. 5).Um den Überblick über den Pfeil zu behalten, benötigst du folgende Variablen:pfeil: aktuelle Position des Pfeils.pfeil_vorherige_höhle: Index der Höhle, aus der der Pfeil kam, dass du weißt, wohin er nicht zurückfliegen kann.verbleibende_schussdistanz: verbleibende zu reisende Distanz.verbleibende_pfeile: Anzahl der verbleibenden Pfeile (auf PFEIL_ANZAHL gesetzt, wenn das Spiel beginnt).Behalte dieses Gerüst im Hinterkopf und lass uns anfangen, unsere Pfeile zu programmieren.","code":""},{"path":"hunt-the-wumpus.html","id":"zufällige-höhle-aber-keine-u-turn","chapter":"Kapitel 9 Jagd auf den Wumpus","heading":"9.19 Zufällige Höhle, aber keine U-Turn","text":"Du musst eine Funktion programmieren (nennen wir sie next_arrow_cave()), die eine zufällige Höhle auswählt, aber nicht die vorherige Höhle, der der Pfeil war. Es sollte zwei Parameter haben:connected_caves: eine Liste von verbundenen Höhlen.previous_cave: Höhle, aus der der Pfeil gekommen ist.Zuerst, debugge den Code einer separaten Zelle. Nehme , dass connected_caves = CONNECTED_CAVES[1] (also, der Pfeil ist derzeit Höhle 1) und previous_cave = 0 (Pfeil kam aus Höhle 0). Schreibe den Code, der eine der verbleibenden Höhlen zufällig auswählt (diesem Fall entweder 2 oder 7), du willst wahrscheinlich Mengenoperationen verwenden (wie bei der effizienten Platzierung von Spielobjekten). Sobald der Code funktioniert, mache daraus eine Funktion, die die nächste Höhle für einen Pfeil zurückgibt. Dokumentiere die Funktion. Teste sie mit anderen Kombinationen von verbundenen und vorherigen Höhlen.Teste deinen Code Übung #7.\nSobald getestet, packe die Funktion utils.py.","code":""},{"path":"hunt-the-wumpus.html","id":"zurückgelegte-entfernung","chapter":"Kapitel 9 Jagd auf den Wumpus","heading":"9.20 Zurückgelegte Entfernung","text":"Jetzt, da du eine Funktion hast, die zur nächsten zufälligen Höhle fliegt, implementiere das Fliegen mit einer -Schleife. Ein Pfeil sollte durch shooting_distance Höhlen fliegen (setze es für den Test auf 5, maximale Entfernung, von Hand). Die erste Höhle ist gegeben (sie wird vom Spieler ausgewählt), setze daher arrow auf 1 und arrow_previous_cave auf 0 (Spieler ist Höhle 0 und hat den Pfeil Höhle 1 geschossen). Drucke aus Debugging-Zwecken den Standort des Pfeils bei jeder Iteration aus. Teste den Code, indem du die shooting_distance änderst. Setzen sie insbesondere auf 1. Der Pfeil sollte bereits Höhle 1 “herunterfallen”.Verwende für dieses eine abgespeckte Version des Codes mit der Konstante CONNECTED_CAVES, der importierten Funktion next_arrow_cave() und allen relevanten Konstanten und Variablen für den Pfeil. Gib die Anfangshöhle, die vorherige Höhle und die Entfernung von Hand ein.Füge deinen Code code12.py ein.","code":""},{"path":"hunt-the-wumpus.html","id":"ein-ziel-treffen","chapter":"Kapitel 9 Jagd auf den Wumpus","heading":"9.21 Ein Ziel treffen","text":"Implementiere die Prüfung zum Treffen des Wumpus oder des Spielers der Schleife. Sollte die Überprüfung vor oder nach dem Fliegen des Pfeils zur nächsten zufälligen Höhle stattfinden? beiden Fällen schreibe eine passende “Spiel vorbei” Nachricht und brich aus der Schleife aus. Teste den Code, indem du den Wumpus von Hand die Höhle platzierst, auf die der Spieler schießt oder die nächste.Du kannst auf den Code aus dem vorherigen Abschnitt aufbauen, aber füge player_location und wumpus Variablen hinzu und kodiere sie von Hand für das Debugging. Führe den Code mehrmals aus, um zu überprüfen, dass er funktioniert.Füge deinen Code code13.py ein.","code":""},{"path":"hunt-the-wumpus.html","id":"bewegen-oder-schießen","chapter":"Kapitel 9 Jagd auf den Wumpus","heading":"9.22 Bewegen oder schießen?","text":"Wir sind fast fertig, aber bevor wir anfangen können, den Code zusammenzustellen, benötigen wir noch ein paar weitere Dinge. Zum Beispiel konnte der Spieler zuvor nur ziehen, also haben wir einfach nach der nächsten Höhlennummer gefragt. Jetzt hat der Spieler bei jedem Zug die Wahl, einen Pfeil abzuschießen oder sich zu bewegen. Implementiere eine Funktion input_shoot_or_move(), die keine Parameter hat und \"s\" für “Schießen” oder \"m\" für “Bewegen” zurückgibt. Frage darin den Spieler nach seiner Wahl, bis er eine von zwei gültigen Optionen auswählt. Konzeptionell ist dies sehr ähnlich zu deiner anderen Eingabefunktion input_cave(), die wiederholt eine Eingabe fordert, bis eine gültige gegeben ist. Teste und dokumentiere!Füge input_shoot_or_move() utils.py einTeste es Übung 8.","code":""},{"path":"hunt-the-wumpus.html","id":"wie-weit","chapter":"Kapitel 9 Jagd auf den Wumpus","heading":"9.23 Wie weit?","text":"Implementiere die Funktion input_distance(), die keine Parameter hat und die gewünschte Schussentfernung zwischen 1 und 5 zurückgibt. Frage erneut wiederholt nach einer ganzzahligen Eingabe (denke daran, du weißt, wie man überprüfen kann, ob die Eingabe eine gültige Ganzzahl ist), wie weit der Pfeil reisen soll, bis eine gültige Eingabe gegeben ist. Dies ist sehr ähnlich zu deinen anderen Eingabefunktionen. Teste und dokumentiere.Füge input_distance() utils.py einTeste sie Übung 9.","code":""},{"path":"hunt-the-wumpus.html","id":"input_cave_with_prompt","chapter":"Kapitel 9 Jagd auf den Wumpus","heading":"9.24 input_cave_with_prompt","text":"Erstellen eine neue Version der Funktion input_cave(), nenne sie input_cave_with_prompt und füge einen prompt Parameter hinzu, damit wir nun entweder nach dem Bewegen zu oder dem Schießen auf die Höhle fragen können (daher die Notwendigkeit des prompts anstelle einer fest codierten Nachricht).Füge input_cave_with_prompt() utils.py einTeste sie Übung 10.","code":""},{"path":"hunt-the-wumpus.html","id":"alles-zusammenfügen","chapter":"Kapitel 9 Jagd auf den Wumpus","heading":"9.25 Alles zusammenfügen","text":"den letzten Abschnitten hast du alle Teile erstellt, die du für das finale Spiel mit einem krummen Pfeil benötigst. Hier ist ein Pseudocode, wie der finale Code aussehen sollte. Schau dir das , um besser zu verstehen, wie die neuen Teile den alten Code integriert werden. Bis jetzt solltest du folgende Konstanten haben (du kannst auch andere Werte haben):CONNECTED_CAVESNUMBER_OF_BATS = 2NUMBER_OF_BOTTOMLESS_PITS = 2P_WUMPUS_SCARED = 0.25ARROWS_NUMBER = 5Folgende Funktionen:find_vacant_cave(...), gibt einen Integer-Höhlenindex zurückinput_cave_with_prompt(prompt, connected_cave), gibt einen Integer-Höhlenindex zurückinput_shoot_or_move(), gibt \"s\" für “schießen” und \"m\" für “bewegen” zurück.input_distance(), gibt eine Ganzzahl zwischen 1 und 5 zurücknext_arrow_cave(connected_caves, previous_cave), gibt einen Integer-Höhlenindex zurückFolgende Variablen:player_location : Höhlenindexbottomless_pit: Liste von Höhlenindizesbats: Liste von Höhlenindizeswumpus: Höhlenindexremaining_arrows: Ganzzahl der verbleibenden PfeileDienst-/temporäre Variablen:occupied_caves: Liste der Höhlenindizesgameover_due_to_arrow : gibt , ob das Spiel vorbei ist, weil entweder der Wumpus oder der Spieler von einem Pfeil getroffen wurdearrow: Standort eines Pfeils, der ursprünglich auf die Wahl des Spielers basiertshooting_distance: Anzahl der Höhlen, die der Pfeil durchfliegen soll.andere pfeilbezogene temporäre VariablenFüge deinen Code code14.py ein.","code":"importiere die benötigten Bibliotheken\n\nimportiere die benötigten Funktionen aus utils\n\ndefiniere KONSTANTEN\n\nplatziere Spieler, bodenlose Gruben, Fledermäuse und Wumpus\nsetze die Anzahl der verbleibenden Pfeile auf ARROWS_NUMBER\nsetze die Variable gameover_due_to_arrow auf False\n\nwährend WAHR:\n    solange der Spieler schießen will und noch Pfeile hat:\n        frage nach der Höhle, auf die der Spieler schießen will  (speichere die Antwort in der Variable `arrow`)\n        frage, wie weit der Pfeil fliegen soll (speichere die Antwort in der Variable `shooting_distance`)\n        \n        lass in einer for-Schleife den Pfeil durch die Höhlen fliegen:\n            Wenn den Wumpus getroffen -> Glückwunsch Spiel vorbei Nachricht, gameover_due_to_arrow = True und breche aus der Schleife aus\n            Wenn den Spieler getroffen -> Oops Spiel vorbei Nachricht, gameover_due_to_arrow = True und breche aus der Schleife aus\n            bewege den Pfeil zur nächsten zufälligen Höhle (Funktion next_arrow_cave und Variable arrow)\n        verringere die Anzahl der verbleibenden Pfeile (Variable remaining_arrows)\n        \n    überprüfe, ob das Spiel aufgrund des Pfeils vorbei ist, breche aus der Schleife aus, falls das der Fall ist\n        \n    frage den Spieler, welche Höhle er betreten möchte und bewege den Spieler\n    \n    solange der Spieler in der Höhle mit den Fledermäusen ist: \n        bewege den Spieler zu einer zufälligen Höhle\n    \n    überprüfe die bodenlosen Gruben (Spieler stirbt, breche aus der Schleife aus)\n    \n    wenn der Spieler in der gleichen Höhle wie der Wumpus ist:\n        wenn der Wumpus erschrocken ist\n            bewege den Wumpus zu einer zufälligen Höhle\n        sonst\n            der Spieler ist tot, bricht aus der Schleife aus"},{"path":"hunt-the-wumpus.html","id":"abschluss-1","chapter":"Kapitel 9 Jagd auf den Wumpus","heading":"9.26 Abschluss","text":"Gut gemacht, das war wirklich ein Abenteuer, diese Höhlen zu erkunden! Zippe und reiche ein.","code":""},{"path":"guess-the-animal.html","id":"guess-the-animal","chapter":"Kapitel 10 Rate das Tier","heading":"Kapitel 10 Rate das Tier","text":"Heute programmieren wir ein Spiel, bei dem der Computer versucht, ein Tier zu erraten, das du gedacht hast, und lernt aus seinen Fehlern, während er allmählich seinen Wortschatz aufbaut. Trotz der Einfachheit des Algorithmus, bietet es uns die Möglichkeit, über Wörterbücher, die kritischen Unterschiede zwischen veränderlichen und unveränderlichen Objekten, Rekursion und Dateisystem zu lernen. Wie üblich, schnapp dir das Übungs-Notizbuch bevor wir starten.","code":""},{"path":"guess-the-animal.html","id":"konzepte-des-kapitels-4","chapter":"Kapitel 10 Rate das Tier","heading":"10.1 Konzepte des Kapitels","text":"WörterbücherRekursionVeränderliche (Engl.: Mutable) vs. unveränderliche (Engl.: Immutable) ObjekteSpeichern/Lesen von Objekten via Pickle und JSON","code":""},{"path":"guess-the-animal.html","id":"spielstruktur","chapter":"Kapitel 10 Rate das Tier","heading":"10.2 Spielstruktur","text":"Die Art und Weise, wie das Spiel gespielt wird, ist sehr einfach: jeder Runde fragt der Computer dich, ob ein Tier eine bestimmte Eigenschaft hat oder ob es ein spezifisches Tier ist. Es beginnt nur mit einem Tier, sagen wir “Hund”. Also fragt es dich “Ist das Tier, das du denkst, ein Hund?”. Wenn ja, ist das Spiel vorbei und du kannst es erneut tun. Wenn es jedoch kein Hund ist, fragt der Computer “Wer ist es dann?”, sagen wir, du antwortest “Ente” und dann fragt der Computer auch “macht die Ente?” und du antwortest “quaken”. Der wichtige Punkt hier ist, dass der Computer diese Information beim nächsten Mal, wenn du das Spiel spielst, nutzt. Es beginnt mit der Frage “quakt das Tier?”, wenn ja, rät es “Ente”, wenn nicht, fällt es auf das einzige Tier zurück, das es noch hat, und rät “Hund”. Wenn es kein Hund ist, fragt es dich erneut “Wer ist es?”, du sagst “Katze”. “macht die Katze?”, “miauen”. Unten siehst du den Entscheidungsbaum, den der Computer jeder Runde nutzen kann, und wie er die Informationen hinzufügt, die er aus seinen Fehlern gelernt hat.","code":""},{"path":"guess-the-animal.html","id":"janein-eingabe","chapter":"Kapitel 10 Rate das Tier","heading":"10.3 Ja/Nein-Eingabe","text":"unserem Spiel werden wir viele Ja/Nein-Fragen stellen, also fangen wir mit der Programmierung der Funktion input_yes_no, die einen Eingabeaufforderungstext als Einzelargument nimmt und solange nach einer Antwort fragt, bis sie eine gültige erhält. Sie sollte True zurückgeben, wenn die Antwort “Ja” war und False für “Nein”. Für die Bequemlichkeit sollte sie den Aufforderungstext mit der Nachricht 'Gib \"j\" für ja und \"n\" für nein ein.' voranstellen, z.B. wenn der Eingabeaufforderungstext \"Ist es ein Pony?\" war, sollte die tatsächliche Eingabeaufforderung 'Gib \"j\" für ja und \"n\" für nein ein. Ist es ein Pony?' sein. Dies sollte dir jetzt leicht fallen, da du während des Jage den Wumpus Spiels schon mehrere ähnliche Funktionen implementiert hast. Dokumentiere(!) es, teste es Übung 1, und gib den Code utils.py ein.Füge input_yes_no utils.py ein.  Teste es Übung 1.","code":""},{"path":"guess-the-animal.html","id":"dictionaries","chapter":"Kapitel 10 Rate das Tier","heading":"10.4 Wörterbücher","text":"Im Entscheidungsbaum haben wir zwei Arten von Knoten: 1) den Aktionsentscheidungsknoten (“quaken?”) mit zwei Kanten (ja und nein), die zu anderen Knoten führen, und 2) die tierischen Blattknoten (“Ente”, “Hund”, “Katze” usw.). Jeder Knoten hat folgende Eigenschaften:Art: Knoten-Art entweder \"Aktion\" oder \"Tier\"Text: Knoten-Text, der entweder eine Aktion oder den Namen des Tieres enthältja : Unterbaum für die Antwort “ja” (nur relevant für Aktions-Knoten)nein : Unterbaum für die Antwort “nein” (ebenfalls nur relevant für Aktions-Knoten)Das verlangt nach einem Container und wir könnten jeden Knoten mit seinen Unterbäumen eine Liste stecken und numerische Indizes verwenden, um auf einzelne Elemente zuzugreifen: z.B. wäre knoten[0] die Knotenart, während knoten[2] den Ja-Unterbaum enthalten würde usw. Aber Indizes haben sich keine Bedeutung, daher ist es nicht unmöglich, aber erfordert zusätzliche Anstrengungen herauszufinden, wie sich knoten[0] von knoten[2] unterscheidet. Python hat eine Lösung für Fälle wie diesen: Wörterbücher.Ein Wörterbuch ist ein Container, der Informationen Schlüssel : Wert-Paaren speichert. Dies ist ähnlich, wie du einem echten Wörterbuch eine Bedeutung oder Übersetzung (Wert) eines Wortes (Schlüssel) nachschlägst, daher der Name. Um ein Wörterbuch zu erstellen, verwendest du geschweifte Klammern {<Schlüssel1> : <Wert1>}, {<Schlüssel2> : <Wert2>, ...} oder erstellst es über dict(<Schlüssel1>=<Wert1>, <Schlüssel2>=<Wert2>, ...). Beachte, dass die zweite Variante restriktiver ist, da die Schlüssel den Regeln für Variablennamen folgen müssen, während der geschweiften-Klammern-Version Schlüssel beliebige Zeichenketten sein können.Wenn du ein Wörterbuch erstellt hast, kannst du jedes Feld über seinen Schlüssel abrufen oder ändern, z.B. print(buch[\"Autor\"]) oder buch[\"Autor\"] = \"Moers, W.\". Du kannst auch neue Felder hinzufügen, indem du ihnen Werte zuweist, z.B., buch[\"Erscheinungsjahr\"] = 1999. Kurz gesagt, du kannst die Kombination von <Wörterbuch-Variable>[<Schlüssel>] genauso verwenden wie eine normale Variable. Dies ähnelt der Verwendung der Kombination Liste[Index], der einzige Unterschied ist, dass Index eine Ganzzahl sein muss, während Schlüssel ein hashbarer37 Wert sein kann.","code":"buch = {\"Autor\" : \"Walter Moers\",\n        \"Titel\": \"Die 13½ Leben des Käpt'n Blaubär\"}\n       \n# oder, äquivalent\nbuch = dict(Autor=\"Walter Moers\",\n            Titel=\"Die 13½ Leben des Käpt'n Blaubär\")"},{"path":"guess-the-animal.html","id":"das-ein-trick-pony","chapter":"Kapitel 10 Rate das Tier","heading":"10.5 Das Ein-Trick-Pony","text":"Beginnen wir Anfang, indem wir ein Wörterbuch mit einem einzigen Tier erstellen, das verwendet werden kann, um die Frage “Ist es ein ?” zu stellen. Erstelle ein Wörterbuch gemäß der oben dargelegten Struktur und überlege, welche Felder du benötigst (Hinweis, nicht alle vier) und welche Werte sie haben sollten. Zukunft werden wir diesen Baum modifizieren, daher ist es, obwohl du ihn hart codierst, immer noch eine Variable, keine Konstante, also verwende den entsprechenden Namensstil.Als Nächstes benötigst du einen einfachen Code, der die Node \"Art\" überprüft und, wenn sie \"Tier\" ist, “Ist es ein ?” fragt (welches Feld musst du dafür verwenden?) mit der Funktion input_yes_no, die du zuvor implementiert hast. Gratuliere dir im Moment selbst, wenn die Antwort “ja” war (der Computer hat es richtig geraten!) aber unternehme sonst keine Aktion.Geben Sie Ihren Code code01.py ein.","code":""},{"path":"guess-the-animal.html","id":"einen-neuen-trick-lernen","chapter":"Kapitel 10 Rate das Tier","heading":"10.6 Einen neuen Trick lernen","text":"der endgültigen Implementierung wird unser Entscheidungsbaum durch Versuch und Irrtum wachsen, aber zunächst lassen wir einen kleinen Entscheidungsbaum von Hand fest einprogrammieren. Erstelle zuerst ein Verzeichnis von Verzeichnissen für den Entscheidungsbaum Runde 2. Es hat nur drei Knoten, der höchste ist ein Aktionsbaum mit zwei Unterbäumen. Jeder Unterbaum ist ein Blattknoten für Tiere. Wenn du dir nicht sicher bist, wie du das machen sollst, schreibe zuerst ein Verzeichnis für die Tierknoten. Dann schreibe den “Aktion”-Knoten und setze entweder Referenzen auf Tierverzeichnisse die Felder “yes” und “” oder füge die tatsächlichen Verzeichnisse ein. Da Unterbäume selbst Verzeichnisse sind, bedeutet das, dass du ein Verzeichnis ein entsprechendes Feld einfügst. Daher wird decision_tree['yes'] zu {\"kind\" : \"animal\", \"text\" : \"duck\"} und deshalb wird decision_tree['yes']['animal'] zu \"duck\". Sobald du es definiert hast, erkunde es von Hand einem Jupyter-Notebook. Versuche verschiedene Felder und verschiedene Ebenen, wie im oben gezeigten Beispiel.Jetzt, wo wir zwei Arten von Knoten haben, müssen wir den Abfragecode aktualisieren, dass er bei einem Tier-Knoten nach “Ist es ?” fragt (du hast diesen Code schon), aber bei einem Aktions-Knoten nach “Tut es ?”. Implementiere das, aber unternimm noch keine Aktion für die Antwort auf die Aktion-Knoten-Frage. Packe den Code eine Funktion ask_question ein, die nur das Baumverzeichnis als Parameter nimmt. Dokumentiere die Funktion und teste, dass sie funktioniert, indem du Bäume aus Runde 1 und Runde 2 verwendest (sollte unterschiedliche Fragen stellen!)Füge die Funktion ask_question utils.py ein.\nTeste den Code code02.py.","code":""},{"path":"guess-the-animal.html","id":"rekursion","chapter":"Kapitel 10 Rate das Tier","heading":"10.7 Rekursion","text":"Unsere Bäume haben viele Knoten verschiedenen Tiefen. Aber wenn wir einem Knoten arbeiten müssen (eine relevante Frage stellen), ist das Einzige, zählt, der Knoten selbst, nicht der Baum, zu dem er gehört, oder wo er diesem Baum ist. Zum Beispiel, betrachte die untenstehenden Abbildungen mit vollständigen und verkürzten Entscheidungsbäumen. Sobald wir beim Knoten “miaut?” angekommen sind, macht es keinen Unterschied, ob wir von einem höheren Knoten kamen oder ob es der höchste Knoten selbst war. Die Frage, die wir stellen und die Entscheidung, die wir treffen, sind die gleichen. Ebenso macht es für uns keinen Unterschied, ob wir beim Knoten “Katze” nach langer Suche landen oder ob es der einzige Knoten war, den wir hatten.Das bedeutet, dass wir nur eine Funktion benötigen, die auf den Knoten reagiert und diese gleiche Funktion wird auf einen relevanten Unter-Knoten für den Aktions-Knoten angewendet. D.h., die Funktion ruft sich selbst auf! Dies wird als Rekursion bezeichnet und ein klassisches Beispiel38 zur Veranschaulichung des Konzepts ist die Berechnung einer Fakultät:\n\\[!n = n \\times (n - 1) \\times (n - 2) \\times ...\\times3\\times2\\times1\\]Es ist leicht zu erkennen, dass die Berechnung hier von Natur aus rekursiv ist, da die Formel wie folgt umgeschrieben werden kann:\n\\[!n = n \\times !(n - 1)\\]Die einzige Ausnahme ist, wenn \\(n = 1\\), daher lautet die vollständige Formel:\n\\[\\ !n = \\begin{cases}\n  1 & \\text{n = 1} \\\\\n  n \\times !(n - 1) & \\text{n > 1}\n\\end{cases}\\]Deine Aufgabe ist es, eine Funktion zu schreiben (dokumentiere sie!), die eine Fakultät für eine gegebene positive ganze Zahl mit der obigen Formel berechnet. Solange \\(n > 1\\) sollte es sich selbst verwenden, um die Fakultät der verbleibenden Zahlen zu berechnen. Teste die Funktion, um zu überprüfen, ob die Berechnung korrekt funktioniert. Setze einen Haltepunkt die Funktion und verwende einen Debugger, um zu sehen, wie die Rekursion funktioniert.Implementiere und teste die factorial Funktion Übung 2.","code":""},{"path":"guess-the-animal.html","id":"erkundung-des-entscheidungsbaums","chapter":"Kapitel 10 Rate das Tier","heading":"10.8 Erkundung des Entscheidungsbaums","text":"Lassen uns die Idee der Rekursion anwenden, um den Entscheidungsbaum zu erkunden, während wir das Spiel spielen. Du kannst für den Moment den Entscheidungsbaum, der unten der Figur gezeigt wird, hardcodieren. Du kannst Wörterbücher direkt verschachteln, aber ich fand es einfacher, ein meow_action Wörterbuch für den zweiten Unterbaum separat zu definieren und es dann dem \"\" Feld des Quack-Wörterbuchs aus dem code02 zuzuweisen.Als Nächstes müssen wir die Funktion ask_question erweitern, nennen wir die neue Version explore_tree. Der Schlüssel und einzige Änderung: Wenn der Knoten ein Aktions-Knoten ist, geht die Funktion eine Ebene tiefer und ruft sich selbst (Rekursion!) mit dem entsprechenden “Ja” oder “Nein” Unterbaum auf, der durch die Antwort des Spielers bestimmt wird.Unser Hauptproblem hier ist, dass die von der Funktion input_yes_no zurückgegebenen Werte nicht mit den entsprechenden Feldschlüsseln übereinstimmen, daher müssen wir die logischen Werte die Strings \"yes\" und \"\" “umwandeln”. Es gibt zwei Möglichkeiten, dies zu tun, eine, die für binäre Fälle wie unsere funktioniert, verwendet bedingte Ausdrücke, eine andere ist allgemeiner und funktioniert zur Übersetzung einer beliebigen Anzahl von Dateien mit Wörterbüchern.Die bedingte Zuweisung ist eine Syntactic Sugar, die eine -else-Anweisung für spezielle Fälle der Wertauswahl basierend auf Bedingungen vereinfacht. Hier ist ein Beispiel für eine vollständige und kompakte Version des gleichen Codes, beachte, dass du prinzipiell die Aufrufe verschachteln könntest, um eine “else else”-Struktur zu erstellen, aber das ist garantiert, dass der Code unleserlich wird, daher würde ich immer eine Standard--elif-else für Fälle wie diesen verwenden.Implementiere und teste den Code zur Umwandlung eines logischen Werts, der einer user_response Variable gespeichert ist, mit bedingten Ausdrücken Übung 3.Implementiere und teste Bedingte Ausdrücke\nÜbung 3.Bedingte Ausdrücke funktionieren gut für binäre Fälle, werden aber umständlich und unlesbar, selbst wenn du nur drei Werte zum Umwandeln hast. Eine einfachere Lösung besteht darin, Wörterbücher zu verwenden, die  → <Übersetzung> als Feld: Schlüsselpaar definieren: “{Original: Übersetzung}”. Dann kannst du einfach den Originalwert als Schlüssel verwenden und die Übersetzung direkt erhalten. Übung 4, implementiere die gleiche Umwandlung von logischen zu “Ja”/“Nein”-Strings wie zuvor, aber mit Wörterbüchern.Implementiere die Übersetzung mit Wörterbüchern\nÜbung 4.Kehren wir zurück zu explore_tree: Sobald du eine Benutzerantwort für einen Aktions-Knoten erhältst, wandele sie mit einer der beiden Methoden (wähle diejenige, die du einfacher zu lesen und zu verstehen findest) einen “Ja”/“Nein”-Schlüssel um. Die Funktion sollte sich selbst aufrufen (wieder Rekursion!) und den entsprechenden Unterbaum als Parameter übergeben. Einmal implementiert, rufe es mit dem hardcodierten Baum auf und teste es, indem du verschiedene Antworten gibst. Der Baum ist klein, du solltest also schnell alle Pfade ausprobieren können. Es sollte ein positives “Juhu!” (oder eine beliebige von dir gewählte Nachricht) geben, wenn du Ende zustimmst, dass die Vermutung des Computers über ein Tier korrekt war, und keine Ausgabe, wenn du “Nein” gesagt hast.Implementiere die Funktion explore_tree utils.py\nVerwende sie im Code code03.py.Unser nächster Schritt ist das Schreiben des Codes, der den Baum erweitert, aber bevor wir damit beginnen, musst du mehr über veränderbare Objekte und die Vorteile und Gefahren, die sie mit sich bringen, lernen.","code":"a_value = 1\n\n# standard if-else\nif a_value > 0:\n  value_kind = \"positive\"\nelse:\n  value_kind = \"zero or negative\"\n  \n# conditional assignment\nvalue_kind = \"positive\" if a_value > 0 else \"zero or negative\""},{"path":"guess-the-animal.html","id":"variablen-als-schachteln-unveränderliche-objekte","chapter":"Kapitel 10 Rate das Tier","heading":"10.9 Variablen als Schachteln (unveränderliche Objekte)","text":"diesem Spiel wirst du Wörterbücher verwenden. Diese sind veränderlich, wie Listen, im Gegensatz zu “normalen” unveränderlichen Werten (Ganzzahlen, Fließkommazahlen, Zeichenketten). Du musst diesen Unterschied lernen, da diese beiden Arten von Objekten (Werten) unter bestimmten Umständen sehr unterschiedlich reagieren, sowohl gut (Macht!) als auch schlecht (merkwürdiges, unerwartetes Verhalten!) ist.Vielleicht erinnerst du dich die Metapher variable---box, die ich verwendet habe, um Variablen einzuführen. Kurz gesagt, eine Variable kann als eine “Schachtel” gedacht werden, auf der der Name der Variable geschrieben steht und ein Wert “innen” gespeichert wird. Wenn du diesen Wert benutzt oder ihm eine andere Variable zuweist, kannst du davon ausgehen, dass Python eine Kopie davon macht39 und diese Kopie eine andere Variable “Schachtel” steckt. Wenn du den Wert einer Variable ersetzt, nimmst du den alten Wert heraus, zerstörst ihn (indem du ihn das nächste Schwarze Loch wirfst, nehme ich ), erstellst einen neuen und steckst ihn die Variable “Schachtel”. Wenn du eine Variable auf Basis ihres aktuellen Zustands änderst, passiert dasselbe. Du nimmst den Wert heraus, erzeugst einen neuen Wert (indem du zum ursprünglichen hinzufügst oder eine andere Operation ausführst), zerstörst den alten und legst den neuen zurück die Variable “Schachtel”. Der wichtige Punkt ist, dass, obwohl eine Variable verschiedene unveränderliche Werte haben kann (wir haben die imole Variable jeder Runde geändert), der unveränderliche Wert selbst sich nie ändert. Er wird ersetzt durch einen anderen unveränderlichen Wert, aber ändert sich nie40.Die Schachtel-Metapher erklärt, warum Anwendungsbereiche funktionieren, wie sie es tun. Jeder Anwendungsbereich hat sein eigenes Set Schachteln und wann immer du Informationen zwischen Anwendungsbereichen austauscht, zum Beispiel von einem globalen Skript zu einer Funktion, wird eine Kopie eines Werts (aus einer Variable) erstellt und eine neue Schachtel (z.B. ein Parameter) innerhalb der Funktion gestellt. Wenn eine Funktion einen Wert zurückgibt, wird er kopiert und eine der Schachteln im globalen Skript (Variable, der du den zurückgegebenen Wert zugewiesen hast) gestellt, usw.Dies gilt jedoch nur für unveränderliche Objekte (Werte) wie Zahlen, Zeichenketten, logische Werte usw., aber auch Tupel (siehe unten für diese sind). Wie du aus dem Namen erraten kannst, bedeutet das, dass es auch andere veränderbare Objekte gibt und diese verhalten sich sehr unterschiedlich.","code":""},{"path":"guess-the-animal.html","id":"mutable-objects","chapter":"Kapitel 10 Rate das Tier","heading":"10.10 Variablen als Post-its (veränderbare Objekte)","text":"Beispiele für veränderbare Objekte sind Listen oder Wörterbücher41, also Dinge, die sich ändern können. Der entscheidende Unterschied ist, dass unveränderliche Objekte als fest ihrer Größe betrachtet werden können. Eine Zahl benötigt viele Bytes zum Speichern, das Gleiche gilt für eine gegebene Zeichenkette (obwohl eine andere Zeichenkette mehr oder weniger Bytes benötigen würde). Trotzdem ändern sie sich nicht, sie werden erstellt und zerstört, wenn sie nicht mehr benötigt werden, aber niemals wirklich aktualisiert.Veränderbare Objekte können geändert werden42. Du kannst beispielsweise Elemente zu deiner Liste hinzufügen, entfernen oder sie mischen. Das Gleiche gilt für Wörterbücher. Ein solches Objekt unveränderlich zu machen, wäre rechnerisch ineffizient: Jedes Mal, wenn du einen Wert hinzufügst, wird eine (lange) Liste zerstört und mit nur diesem einen zusätzlichen Wert neu erstellt. Aus diesem Grund aktualisiert Python einfach das ursprüngliche Objekt. Für weitere Recheneffizienz werden diese Objekte nicht kopiert, wenn du sie einer anderen Variable zuweist oder als Parameterwert verwendest, sondern werden per Referenz übergeben. Das bedeutet, dass die Variable nicht mehr eine “Schachtel” ist, die du Werte legst, sondern ein “Aufkleber”, den du auf ein Objekt (eine Liste, ein Wörterbuch) klebst. Und du kannst viele Aufkleber auf ein Objekt kleben, wie du willst und es wird immer noch dasselbe Objekt sein!zum Teufel meine ich damit? Denke daran, dass eine Variable nur ein Aufkleber (einer von vielen) auf einem veränderbaren Objekt ist, und versuche herauszufinden, die Ausgabe unten sein wird:Mach Übung #5.Hä? Das ist genau das, ich mit “Aufklebern auf demselben Objekt” meinte. Zuerst erstellen wir eine Liste und kleben einen x Aufkleber darauf. Dann weisen wir die gleiche Liste y zu, mit anderen Worten, wir kleben einen y Aufkleber auf die gleiche Liste. Da sowohl x als auch y Aufkleber auf dem gleichen Objekt sind, sind sie effektiv Synonyme. dieser speziellen Situation, sobald du x = y festlegst, ist es egal, welchen Variablennamen du verwendest, um das Objekt zu ändern, sie sind nur zwei Aufkleber, die nebeneinander der gleichen Liste hängen. Nochmals zur Erinnerung, das ist nicht das, bei unveränderlichen Werten wie Zahlen passieren würde, wo die Dinge sich verhalten würden, wie du es erwartest.Diese Theorie von Variablen als Aufkleber, auch bekannnt als “Wertübergabe per Referenz”, hat sehr wichtige Auswirkungen auf Funktionsaufrufe, da sie deinen Umfang bricht, ohne dir jemals eine Warnung zu geben. Schau dir den untenstehenden Code und versuche herauszufinden, welche Ausgabe es geben wird.Mache Übung #6.Wie haben wir es geschafft, eine globale Variable von innerhalb der Funktion zu ändern? Haben wir nicht den lokalen Parameter der Funktion geändert? Ja, genau das ist das Problem bei der Übergabe per Referenz. Dein Funktionsparameter ist nur ein weiterer Sticker auf dem gleichen Objekt. Selbst wenn es also aussieht, als müsstest du dir keine Sorgen um globale Variablen machen (dafür hast du ja die Funktion geschrieben und über Scopes gelernt!), musst du das doch. Wenn dich das verwirrt, bist du guter Gesellschaft. Dies ist eine der unerwartetsten und verwirrendsten Stellen Python, die immer wieder Leute43 überrascht. Lass uns noch ein paar Übungen machen, bevor ich dir zeige, wie du das Scope-Problem bei veränderbaren Objekten lösen kannst.Mach die Übung #7.","code":"x = [1, 2, 3]\ny = x\ny.append(4)\nprint(x)def change_it(y):\n    y.append(4)\n\nx = [1, 2, 3]\nchange_it(x)\nprint(x)"},{"path":"guess-the-animal.html","id":"tuple","chapter":"Kapitel 10 Rate das Tier","heading":"10.11 Tupel: eine eingefrorene Liste","text":"Die klugen Leute, die Python entwickelt haben, waren sich des Problems, das die Variable-als-Sticker-Methode schafft, sehr bewusst. Darum haben sie eine unveränderliche Version einer Liste hinzugefügt, genannt Tupel. Es handelt sich um eine “eingefrorene” Liste von Werten, über die du iterieren kannst, auf deren Elemente du per Index zugreifen kannst oder herausfinden, wie viele Elemente sie hat, aber du kannst sie nicht ändern. Kein Anhängen, Entfernen, Ersetzen von Werten, etc. Für dich bedeutet das, dass eine Variable mit einer eingefrorenen Liste eher eine Box als ein Sticker ist und dass sie sich genau wie jedes andere “normale” unveränderliche Objekt verhält. Du kannst ein Tupel erstellen, indem du runde Klammern verwendest.Du kannst über es iterieren, z.B.wie ich aber schon sagte, wird das Anhängen einen Fehler verursachenDas Gleiche passiert, wenn du es versuchst zu ändernDas bedeutet, dass wenn du eine Liste von Werten eine Funktion übergeben musst und du nicht möchtest, dass sie eine Verbindung zur ursprünglichen Variable hat, solltest du stattdessen ein Tupel von Werten die Funktion übergeben. Die Funktion hat immer noch eine Liste von Werten, aber die Verbindung zum ursprünglichen Listenobjekt ist jetzt unterbrochen. Du kannst eine Liste ein Tupel umwandeln, indem du tuple() verwendest. Wenn du bedenkst, dass tuple() eine eingefrorene Kopie der Liste erstellt, wird dann im Folgenden passieren?Mach die Übung #8.Wie du wahrscheinlich herausgefunden hast, erstellt Python bei y = tuple(x) eine Kopie der Listeneinträge, friert sie ein (sie sind jetzt unveränderlich) und legt sie die “y”-Box. Daher hat alles, du mit der ursprünglichen Liste machst, keinen Einfluss auf das unveränderliche “y”.Umgekehrt kannst du ein Tupel “auftauen”, indem du es mit list() eine Liste umwandelst. Bitte beachte, dass dies eine neue Liste erstellt, die keinen Bezug zu jeder anderen existierenden Liste hat, auch wenn die Werte gleich sind oder ursprünglich von einer von ihnen stammen!Mach die Übung #9.Erinnerst du dich, dass ich gerade gesagt habe, dass list() eine neue Liste erstellt? Das bedeutet, dass du es verwenden kannst, um direkt eine Kopie einer Liste zu erstellen, ohne einen Zwischenschritt über ein Tupel. Auf diese Weise kannst du zwei verschiedene Listen mit identischen Werten erstellen. Du kannst das gleiche Ergebnis auch erzielen, indem du eine gesamte Liste ausschneidest, z.B. ist list(x) das Gleiche wie x[:].Mach die Übung #10.Hier hat y = list(x) eine neue Liste erstellt (die eine genaue Kopie derjenigen war, auf der der “x”-Sticker klebte) und der “y”-Sticker wurde auf diese neue Liste geklebt, während der “x” Original hängen blieb.Wenn dir jetzt der Kopf schwirrt, muss ich dir leider sagen, dass es noch schlimmer wird. Der folgende Absatz behandelt ein ziemlich fortgeschrittenes Szenario, aber ich möchte, dass du davon weißt, da die Dinge extrem kontraintuitiv funktionieren und ich persönlich schon ein paar Mal auf dieses Problem gestoßen bin und es hat mich immer ewig gekostet, das Problem herauszufinden. Deshalb möchte ich, dass du dir zumindest dessen bewusst bist. ist, wenn du ein Tupel (unveränderlich!) hast, das eine Liste (veränderlich) enthält? Wie ich dir schon früher sagte, kannst du den Eintrag selbst nicht ändern, aber dieser Eintrag ist nur eine Referenz auf die Liste (ein Sticker auf einem veränderlichen Objekt!), dass du selbst wenn das Tupel unveränderlich ist, immer noch mit der Liste selbst herumhantieren kannst. Darüber hinaus wird das Anfertigen einer Kopie eines Tupels lediglich eine Kopie der Referenz erstellen, die immer noch auf die gleiche Liste zeigt! Also könntest du denken, dass, weil alles Tupel sind, alles unveränderlich und gut verhält, und von dem erwischt werden44. Hier ist ein Beispiel für ein solches Durcheinander:Verwirrend? Wetten, dass! Wenn du dich von dieser ganzen unveränderlich/veränderlich, Tupel/Liste, Kopie/Referenz-Verwirrung überwältigt fühlst, bist du nur ein normaler Mensch. Ich verstehe die (rechnerischen) Gründe, warum man die Dinge auf diese Weise macht, ich bin mir dieser Unterschiede und wie nützlich sie sein können bewusst, aber trotzdem überraschen sie mich immer wieder! Also, ein Rat, sei vorsichtig und überprüfe deinen Code immer mit dem Debugger, wenn du Listen oder Wörterbücher zuweist, sie Funktionen übergibst, Kopien anfertigst, Listen Listen hast, etc. Sei dir bewusst, dass die Dinge vielleicht nicht funktionieren, wie du denkst, dass sie sollten!","code":"ich_bin_ein_tupel = (1, 2, 3)ich_bin_ein_tupel = (1, 2, 3)\nfor number in ich_bin_ein_tupel:\n    print(number)\n#> 1\n#> 2\n#> 3ich_bin_ein_tupel = (1, 2, 3)\n\n# wirft AttributeError: 'tuple' object has no attribute 'append'\nich_bin_ein_tupel.append(4)\n#> 'tuple' object has no attribute 'append'ich_bin_ein_tupel = (1, 2, 3)\n\n# wirft TypeError: 'tuple' object does not support item assignment\nich_bin_ein_tupel[1] = 1 \n#> 'tuple' object does not support item assignmentx = [1, 2, 3]\ny = tuple(x)\nx.append(4)\nprint(y)tuple_1 = tuple([1, [\"A\", \"B\"], 2])\ntuple_2 = tuple_1\n\n# Das funktioniert (korrekterweise) nicht.\ntuple_1[0] = [\"C\", \"D\"]\n#> 'tuple' object does not support item assignment\n\n# Aber wir können das erste Element der Liste zu \"C\" ändern und das zweite zu \"D\"\n# Die Referenz zur Liste ist eingefroren, aber die Liste selbst ist veränderlich!\ntuple_1[1][0] = \"C\"\ntuple_2[1][1] = \"D\"\n\nprint(tuple_1)\n#> (1, ['C', 'D'], 2)\nprint(tuple_2)\n#> (1, ['C', 'D'], 2)"},{"path":"guess-the-animal.html","id":"erweitern-des-baumes","chapter":"Kapitel 10 Rate das Tier","heading":"10.12 Erweitern des Baumes","text":"Zurück zur Aufgabe, den Baum zu erweitern. Jeder Knoten, den wir einem Baum haben, ist ein Wörterbuch, welches veränderlich ist und das macht es einfach, wenn auch ein bisschen verwirrend. Das Gute ist, wir können den Baum von innen der Funktion aus verändern. Wie ich dir oben gezeigt habe, gibst du nicht das Wörterbuch selbst die Funktion weiter, sondern eine Referenz darauf, also wird alles, du mit irgendeinem Wörterbuch innerhalb des Baumes machst, der globalen Baumvariable reflektiert. Das verwirrende dabei ist, dass wir im Hinterkopf behalten müssen, dass wir immer mit einer Referenz arbeiten, also wenn wir die Daten kopieren müssen, wird eine einfache Zuweisung nicht ausreichen (weil sie nur die Referenz kopiert, erinnerst du dich?) Wir haben zwei Optionen, die der unten stehenden Abbildung dargestellt sind. Der ursprüngliche Baum hat nur einen Knoten, dargestellt durch Dict #1.. Wenn wir den Baum erweitern, muss dieser Knoten nach unten versetzt werden und zu einem Blatt eines Aktionsknotens werden, der nun zum Ausgangspunkt wird. Wir können ein neues Aktionsknoten-Wörterbuch (Dict #2) erstellen, einen neuen Tierknoten für die Katze (Dict #3) und sie wie Option #1 anordnen. diesem Fall müssen wir jedoch sicherstellen, dass die Referenz der Variable tree aktualisiert wird, dass sie nun auf Dict #2 zeigt. Alternativ können wir Dict #1. als obersten Knoten behalten, aber seinen Inhalt komplett ersetzen und ihn einen Aktionsknoten umwandeln. Die ursprünglichen Informationen werden ein neues Dict #3 kopiert. Lass uns beide Ansätze ausprobieren, angefangen mit Option #1.","code":""},{"path":"guess-the-animal.html","id":"den-baum-durch-zurückgeben-einer-neuen-referenz-erweitern","chapter":"Kapitel 10 Rate das Tier","heading":"10.13 Den Baum durch Zurückgeben einer neuen Referenz erweitern","text":"Lass uns wie gewohnt kleinen Schritten vorgehen. Schreibe zuerst einen Code, der einen Tier-Knoten nimmt (setze die tree Variable per Hand) und erstelle einen Baum mit drei Knoten, wie Option #1 oben. Du musst zwei zusätzliche Wörterbücher erstellen und sie auf die Felder \"ja\" und \"nein\" setzen, damit du ein Wörterbuch erhältst, das dem Baum Option #1 entspricht. Harte zunächst das neue Tier und die neue Aktion. Sobald dein Code funktioniert, ersetze die fest codierten Werte durch input Aufrufe, die den Benutzer fragen: “Wer ist es?” und “macht ?”.Teste den Code Übung #11.Das gibt uns den Code, den wir für die explore_and_extend_tree_via_return Funktion benötigen (Ich weiß, dass ist ein Mundvoll), die die explore_tree Funktion, die du zuvor implementiert hast, erweitert. Denke darüber nach, wo der neue Code hinkommt.Eine wichtige Änderung ist, dass die Funktion nun eine Referenz zum Baum (dem Wörterbuch mit dem Baum) zurückgeben muss. Es handelt sich entweder um den ursprünglichen Baum oder, falls du ihn erweitert hast, um den neuen Baum. Das bedeutet auch, dass den Aktionsknoten entweder die \"ja\" oder \"nein\" Wörterbücher eine Referenz zugewiesen werden muss, die von einem rekursiven Aufruf der Funktion explore_and_extend_tree_via_return zurückgegeben wird. Zum Beispiel, wenn nichts passiert ist, wird die gleiche Referenz auf das ursprüngliche Wörterbuch zurückgegeben und zugewiesen. Wenn wir jedoch einen neuen Baum erstellt haben, müssen die Referenzen auf diesen neuen Baum nun im Feld \"ja\" oder \"nein\" gespeichert werden. Wenn wir das nicht tun, wird das Feld immer noch auf den ursprünglichen Knoten zeigen und unsere Änderungen sind unsichtbar. Das Gleiche gilt für die oberste Ebene, da dies bedeutet, dass wir nicht nur unseren globalen tree die Funktion übergeben, sondern auch die zurückgegebene Referenz wieder zuweisen müssen. Überlege, wann/wo du das aktualisierte oder ursprüngliche Wörterbuch zurückgeben und wann/wo du den zurückgegebenen Wert einem “ja”/“nein” Feld zuweisen musst.Aktualisiere die Funktion (überprüfe doppelt, welche Funktion du rekursiv aufrufst, es sollte explore_and_extend_tree_via_return sein, nicht die ursprüngliche explore_tree!) und teste sie, indem du mit einem einzelnen Tierknotenbaum beginnst und ihn einer endlosen Schleife aufrufst (wir verwenden vorerst den Notstopp über den Debugger als Exit-Strategie). Ich würde vorschlagen, das Wörterbuch nach jedem Aufruf (Erkunden und Erweitern des Baums) auszudrucken, um zu sehen, wie es wächst, sowie einen Haltepunkt innerhalb oder nach der Funktion zu setzen, um den Prozess zu erforschen, den Aufrufstapel zu sehen und die Parameterwerte für jede Stufe zu prüfen.Implementiere die Funktion utils.py\nVerwende sie im Code code04.py.","code":""},{"path":"guess-the-animal.html","id":"den-baum-durch-modifikation-eines-wörterbuchs-am-ort-erweitern","chapter":"Kapitel 10 Rate das Tier","heading":"10.14 Den Baum durch Modifikation eines Wörterbuchs am Ort erweitern","text":"Die zweite Option (siehe Illustration oben) ist einfacher, weil wir nichts zurückgeben müssen. Sie ist jedoch weniger transparent, da wir Dinge hinter den Kulissen verändern und diese Änderungen nicht offensichtlich durch eine Rückgabe signalisiert werden. Schreibe zuerst den Code, der zwei neue Tierknoten erstellt und den Inhalt des ursprünglichen Knotens durch eine neue Aktion ersetzt (wie zuvor, codiere zuerst das neue Tier und die neue Aktion hart, später ersetze es durch input Aufrufe wie der vorherigen Funktion). Du kannst prüfen, ob der tree das gleiche Objekt referenziert, indem du seine id überprüfst. Sie sollte gleich bleiben, auch wenn der Inhalt anders ist (die id für den obersten Knoten sollte sich Übung #11 ändern, gehe zurück zum Code und überprüfe).Wichtiger Hinweis! Denke daran, dass tree eine Referenz ist, daher wird dir no_animal = tree nicht helfen, die ursprünglichen Informationen einem neuen Knoten zu speichern, da dies bedeutet, dass sowohl tree als auch no_animal auf dasselbe Wörterbuch verweisen werden. Denke daran, dass es die Referenz auf ein Wörterbuch ist, die kopiert wird, nicht der tatsächliche Inhalt des Wörterbuchs. Mache no_animal = tree und drucke dann die id für beide (die gleiche) aus und schreibe tree no_animal (überprüft, ob zwei Objekte identisch sind, d.h. dieselben Objekte, daher wird es True sein). Seltsamerweise wird, sobald du danach tree[\"\"] = no_animal schreibst, es sich selbst referenzieren (tree tree[\"\"] wird True sein)!Es gibt zwei Wege, dieses Problem zu lösen. Du kannst ein neues Wörterbuch erstellen, indem du die Feld- Werte einzeln zuweist. Da unsere “Tier”-Wörterbuchfeldwerte unveränderliche Zeichenketten sind, wird dieses Vorgehen ein anderes Objekt mit dem gleichen Inhalt erstellen.Alternativ kannst du entweder eine flache Kopie oder eine tiefe Kopie von einem Objekt erstellen, indem du die copy Bibliothek verwendest. Die erstere - copy - erstellt eine “flache” Kopie indem sie den Kontext “wie er ist” kopiert. diesem Fall wird eine Referenz zu einem anderen Objekt kopiert, wie sie ist, und verweist immer noch auf das gleiche Objekt. Die deepcopy geht tiefer und erstellt eine Kopie für das Objekt, auf das das Original verweist. Letzteres ist rechenintensiver (du erstellst Kopien von allem!), aber es garantiert, dass eine Kopie erstellt wird, die keine versteckten Verbindungen zum Original hat. Also, im Zweifelsfall, nimm die deepcopy. unserem Fall gibt es keinen Unterschied, da unser ursprüngliches Wörterbuch gerade mal zwei unveränderliche Zeichenketten hat, dass sowohl copy als auch deepcopy das Gleiche tun würden.unserem Code verwenden wir die letztere Option über die copy Bibliothek. Schreibe den Code, der den Baum erweitert, indem er den Inhalt des ursprünglichen Knotens ersetzt und neue Tierknoten Übung 12 hinzufügt. Beachte, dass du einen Baum nicht mit der Notation tree = {...} verändern kannst, da dies ein neues Objekt erzeugen würde. Um vor Ort zu verändern, musst du die Felder einzeln über die Zuweisung tree[field] = value ändern.Teste den Code Übung #12.Jetzt, wo der Code funktioniert, kannst du ihn einer neuen Funktion namens explore_and_modify_tree verwenden, die auf der explore_tree Funktion aufbaut. Wiederum verwende den neuen Code, wenn du dich im Tier-Knoten befindest und die Vermutung falsch war (Antwort war “nein”). Diese Funktion ist einfacher als explore_and_extend_tree_via_return, da du dir keine Gedanken über Rückgabewerte und deren Rückzuweisung machen musst. Teste sie auf die gleiche Weise einer endlosen Schleife, wie du es für explore_and_extend_tree_via_return getan hast. Überprüfe doppelt, welche Funktion du beim rekursiven Aufruf aufrufst!Implementiere die Funktion utils.py\nVerwende sie im Code code05.py.","code":"# Zuweisung kopiert Referenz, das Objekt bleibt jedoch gleich.\ndict1 = {\"a\": 1}\ndict2 = dict1\nprint(id(dict1), id(dict2), dict1 is dict2)\n#> 2256991031872 2256991031872 True\n\n# Das Objekt referenziert sich selbst!\ndict1[\"a\"] = dict1\nprint(id(dict1), id(dict1[\"a\"]), dict1 is dict1[\"a\"])\n#> 2256991031872 2256991031872 Truedict1 = {\"a\": 1}\ndict2 = {\"a\" : dict1[\"a\"]}\n\n# gleicher Inhalt!\nprint(dict1 == dict2)\n#> True\n\n# verschiedene Objekte\nprint(id(dict1), id(dict2), dict1 is dict2)\n#> 2256990820544 2256991072704 False"},{"path":"guess-the-animal.html","id":"kann-ich-jetzt-nach-hause-gehen","chapter":"Kapitel 10 Rate das Tier","heading":"10.15 Kann ich jetzt nach Hause gehen?","text":"Unser Programm funktioniert gut, aber die aktuelle Idee ist, buchstäblich, für immer zu spielen. Wir sollten freundlicher sein, also frage den Spieler nach jeder Runde, ob er wieder spielen möchte und fahre nur fort, wenn die Antwort “ja” war (denke daran, du hast bereits eine Funktion, um “ja” / “nein” Fragen zu stellen, verwende sie!).Aktualisiere die Schleife im Code code06.py.","code":""},{"path":"guess-the-animal.html","id":"pickle","chapter":"Kapitel 10 Rate das Tier","heading":"10.16 Den Baum über pickle für die zukünftige Verwendung speichern","text":"Unser Spiel funktioniert, unser Entscheidungsbaum wächst mit jeder Runde, aber das Problem ist, dass wir jedes Mal von vorne anfangen, wenn wir das Programm starten. Das ist verschwenderisch und macht keinen Spaß, daher sollten wir unseren Baum Ende jedes Spiels speichern und ihn immer wieder laden, wenn das Programm erneut gestartet wird. Eine Option ist die Verwendung der pickle Bibliothek, die es dir ermöglicht, Python-Objekte zu dump und zu laden. Hier ist, wie es funktioniert (benutze das unbekannte open(\"dict1.p\", \"wb\") pickle_file: als):unserem Programm müssen wir den Baum zu Beginn aus einer Datei (ich habe sie animal_tree.p genannt) laden und entweder Ende (sobald der Spieler nicht mehr spielen möchte) oder nach jeder Runde dumpen (das bedeutet, dass die neueste Version des Baumes sogar gespeichert wird, wenn der Spieler über einen Notausstieg aussteigt).Beachte, dass wir einen ursprünglichen Baum benötigen, der sogar vor dem ersten Ausführen des Programms erstellt wurde. Erstelle diesen Baum (einzelner Tierknoten) und dumpe ihn einer separaten Skript oder Jupyter-Zelle die Datei. Das ist der Baum, den du lesen, ändern und code07 schreiben musst. Sobald du die ursprüngliche Datei erstellt hast, lade sie zurück und überprüfe, ob das Wörterbuch das ist, das du gedumpt hast.Sobald das Laden Anfang und das Dumpen Ende eingebaut sind, teste es, indem du Ein-Runden-Spiele spielst und das Programm neu startest. Der Baum sollte erhalten bleiben und weiter wachsen.Implementiere das Programm code07.py.","code":"import pickle\n\ndict1 = {\"a\": 1}\nprint(dict1)\n#> {'a': 1}\n\n# Wörterbuch in eine Datei dumpen\nwith open(\"dict1.p\", \"wb\") as pickle_file:\n  pickle.dump(dict1, pickle_file)\n\n# Ein Wörterbuch aus einer Datei laden\nwith open(\"dict1.p\", \"rb\") as pickle_file:\n  dict2 = pickle.load(pickle_file)\nprint(dict2)\n#> {'a': 1}"},{"path":"guess-the-animal.html","id":"json","chapter":"Kapitel 10 Rate das Tier","heading":"10.17 Den Baum über JSON für die zukünftige Verwendung speichern","text":"Pickle ist ein Python-spezifisches Serialisierungsformat, sodass du diesen Baum nicht anderswo verwenden kannst (du kannst ihn nicht deinen Freund weitergeben, der R oder C verwendet). Außerdem handelt es sich um ein binäres Format (also nicht vom Menschen lesbar) und es ist nicht sicher (siehe die große rote Warnung Anfang der offiziellen Dokumentation), sodass du niemals einer Pickle-Datei vertrauen solltest, es sei denn, sie ist von dir selbst.Eine alternative Methode sind JSON-Dateien, die häufig im interaktiven Web verwendet werden (JSON steht für JavaScript Object Notation), sie sind vom Menschen lesbar (es handelt sich um eine Textdatei, die du jedem Editor öffnen kannst) und werden von jeder anderen Software unterstützt (jede Sprache, die dein Freund verwendet, wird eine JSON-Bibliothek haben, um mit deiner Datei zu arbeiten).Die Verwendung von JSON ist sehr ähnlich wie die Verwendung von Pickle:Wie zuvor benötigst du ein Startwörterbuch für dein Programm. Du kannst von vorne anfangen (definiere ein alleinstehendes Tierknoten-Wörterbuch und speichere es) oder du kannst dein gepickeltes Wörterbuch laden, es aber ein JSON dumpen (dies verwendet den Baum, den du bereits erstellt hast). Beachte, dass du im Gegensatz zu pickle-Dateien den Inhalt der Datei im VS Code betrachten kannst.Implementiere das Programm code08.py.","code":"import json\n\ndict1 = {\"a\": 1}\nprint(dict1)\n#> {'a': 1}\n\n# Wörterbuch in eine Datei dumpen\nwith open(\"dict1.json\", \"w\") as json_file:\n  json.dump(dict1, json_file)\n\n# Ein Wörterbuch aus einer Datei laden\nwith open(\"dict1.json\", \"r\") as json_file:\n  dict2 = json.load(json_file)\nprint(dict2)\n#> {'a': 1}"},{"path":"guess-the-animal.html","id":"zusammenfassung","chapter":"Kapitel 10 Rate das Tier","heading":"10.18 Zusammenfassung","text":"Glückwunsch, du hast nun ein selbstlernendes KI-System programmiert! Verpacke alle Dateien eine Zip-Datei und reiche sie ein.","code":""},{"path":"sudoku-brute-force.html","id":"sudoku-brute-force","chapter":"Kapitel 11 Sudoku: Brute-Force-Algorithmus","heading":"Kapitel 11 Sudoku: Brute-Force-Algorithmus","text":"diesem Kapitel werden wir ein Programm schreiben, das ein Sudoku-Rätsel generiert. einem typischen Sudoku-Rätsel musst du ein \\(9\\times9\\) Gitter mit den Zahlen 1 bis 9 vervollständigen, dass sich die Zahlen jeder Reihe, jeder Spalte und jedem \\(3\\times3\\) Quadratblock nicht wiederholen. Wenn du das Spiel spielst, hast du ein unvollständiges Puzzle und je mehr Lücken es hat, desto schwieriger tendiert das Rätsel zu sein. Aber bevor du das Spiel spielen kannst, muss jemand (das bist du heute) 1) ein komplettes Rätsel generieren (woran wir uns heute konzentrieren werden), 2) einige Zahlen entfernen, während sichergestellt wird, dass die Lösung des Rätsels eindeutig bleibt. Heute werden wir uns auf die erste Aufgabe konzentrieren: Das Generieren eines vollständigen Bretts.\nDas Rätsel basiert auf einem 2D-Gitter und prinzipiell könntest du Listen von Zeilen (die selbst Listen sind) verwenden, um dieses Gitter zu erstellen. Das wäre ähnlich der Liste von Listen, die Informationen über verbundene Höhlen im Spiel Hunt Wumpus enthielten. Allerdings macht eine geschachtelte Listenstruktur das Arbeiten mit Spalten und Blöcken schwierig, da ihre Elemente verschiedenen Listen angehören und du anstelle von einfacherem Listen-Slicing (nur für Zeilen funktioniert) Schleifen verwenden musst.Stattdessen werden wir es als Gelegenheit nutzen, um etwas über die NumPy Bibliothek zu lernen, die eines der Schlüsselpakete für wissenschaftliches Rechnen Python ist und die Grundlage für viele Bibliotheken zur Datenanalyse bildet. Beachte, dass das untenstehende Material keinesfalls vollständig ist. Es kratzt, wenn überhaupt, nur der Oberfläche von NumPy. Wenn du NumPy für deine Projekte benötigst, empfehle ich dringend, einen Blick den offiziellen Getting Started für absolute Anfänger Leitfaden und das offizielle Benutzerhandbuch zu werfen.Nimm dir das Übungs-Notebook und lass uns loslegen.","code":""},{"path":"sudoku-brute-force.html","id":"numpy-importieren","chapter":"Kapitel 11 Sudoku: Brute-Force-Algorithmus","heading":"11.1 NumPy importieren","text":"NumPy ist keine Standardbibliothek von Python, daher musst du sie eventuell installieren. Wie bei allen Bibliotheken, musst du NumPy importieren, bevor du es deinem Skript verwenden kannst. Dies ist jedoch einer der seltenen Fälle, bei denen das Umbenennen der Bibliothek beim Importieren der Standard und der empfohlene Weg ist:","code":"import numpy as np"},{"path":"sudoku-brute-force.html","id":"d-numpy-arrays-versus-python-listen","chapter":"Kapitel 11 Sudoku: Brute-Force-Algorithmus","heading":"11.2 1D-NumPy-Arrays versus Python-Listen","text":"Die Schlüsseldatenstruktur, die NumPy einführt, ist ein NumPy-Array, das beliebig viele Dimensionen haben kann. Ein eindimensionales Array, typischerweise “Vektor” genannt, ist direktsten mit einer Python-Liste verwandt, hat aber sowohl einige Einschränkungen als auch zusätzliche Funktionalität. Im Gegensatz zu Python-Listen, die alles enthalten können, einschließlich anderer Listen, müssen alle Elemente eines Arrays vom gleichen Typ sein. Der Vorteil dieser Einschränkung besteht darin, dass, da alle Elemente vom gleichen Typ sind, du eine Funktion auf alle Elemente anwenden kannst. Beachte, dass dies keine Garantie dafür bietet, dass es bei intrinsisch heterogenen Python-Listen funktioniert, der Grund ist, warum du Operationen auf jedes Element einzeln ausführen musst.Du kannst aus einer Liste ein NumPy-Array über die array-Funktion erstellen:Beachte, dass aufgrund der Einschränkung “alle Werte müssen vom gleichen Typ sein”, wenn die ursprüngliche Python-Liste Daten verschiedener Typen enthielt, alle Werte den flexibelsten Typ umgewandelt werden. Zum Beispiel wird eine Mischung aus logischen Werten und Ganzzahlen dir Ganzzahlen geben, eine Mischung aus Ganzzahlen und Fließkommazahlen wird dir Fließkommazahlen geben, eine Mischung aus irgendetwas mit Zeichenketten wird dir Zeichenketten geben usw.Der Typ eines Arrays wird bei der Erstellung festgelegt, und wenn du einen Wert eines anderen Typs einfügst, wird dieser entweder diesen Typ umgewandelt oder, falls eine Umwandlung nicht möglich ist, wird NumPy einen Fehler ausgeben.Mache Übung #1.Im Allgemeinen kannst du mit einem 1D-NumPy-Array das Gleiche tun wie mit einer Liste. Zum Beispiel funktioniert das Slicing auf die gleiche Weise, du kannst genauso über Elemente eines Arrays iterieren usw.Allerdings wird bestimmte Funktionalität anders implementiert, wie das Anhängen im folgenden Beispiel. Andere Funktionalitäten, wie ein Entfernen (pop), fehlen, können aber durch Slicing emuliert werden.Der wichtigste praktische Unterschied zwischen Listen und NumPy-Arrays liegt darin, dass Letztere homogen sind und Operationen ihnen vektorisiert werden. Das bedeutet, dass du eine Funktion auf das gesamte Array auf einmal anwenden kannst, es sowohl einfacher der Handhabung macht als auch schneller, da die meisten Operationen Arrays stark optimiert sind. Hier ist ein Beispiel dafür, wie du den gleichen Wert mit jedem Element eines Arrays multiplizierst und dann diesen Wert zu jedem Element hinzufügst, etwas, das bei einer normalen Liste eine -Schleife erfordert.Du kannst auch elementweise Operationen auf zwei (oder mehr) Arrays gleichzeitig ausführen. Zum Beispiel, hier ist ein Beispiel für elementweises Addieren von zwei Arrays.Beachte, dass dies nur funktioniert, wenn die Formen (shapes) der Arrays gleich sind. Im Falle von 1D-Arrays (auch Vektoren genannt), bedeutet das, dass ihre Länge gleich sein muss.Gleichzeitig kannst du immer Vektoren mit einem einzelnen Element verwenden, die “Skalare” genannt werden, und dieser einzelne Wert wird für jedes Element im anderen Vektor verwendet.Mache Übung #2.Vektorisierung bedeutet auch, dass du aggregierende Funktionen – Mittelwert (mean), Median, Minimum (min) usw. – auf das Array anwenden kannst, anstatt diese von Hand zu berechnen.Mache Übung #3.","code":"import numpy as np\n\n# Eine Python-Liste von Zahlen\na_list = [1, 5, 7]\nprint(a_list)\n#> [1, 5, 7]\n\n# Ein aus der Liste erstelltes NumPy-Array\nan_array = np.array(a_list)\nprint(an_array)\n#> [1 5 7]# Logische Werte und Ganzzahlen -> alle Ganzzahlen\nprint(np.array([True, 2, 3, False]))\n#> [1 2 3 0]\n\n# Ganzzahlen und Fließkommazahlen -> alle Fließkommazahlen\nprint(np.array([1.0, 2, 3, 0.0]))\n#> [1. 2. 3. 0.]\n\n# Logische Werte, Ganzzahlen, Fließkommazahlen und Zeichenketten -> alle Zeichenketten\nprint(np.array([False, 1, 2.0, \"a\"]))\n#> ['False' '1' '2.0' 'a']# Array von Booleschen Werten\narray_of_bool = np.array([True, False, True])\n\n# Ein Fließkommawert wird automatisch in einen logischen Wert umgewandelt.\n# es ergibt 'True', weil nur 0.0 'False' ist\narray_of_bool[1] = 2.0\nprint(array_of_bool)\n#> [ True  True  True]\n\n# Ein beliebiger Zeichenkettenwert, der nicht automatisch in eine Ganzzahl umgewandelt werden kann\narray_of_int = np.array([1, 2, 3])\narray_of_int[1] = \"A text\"\n#> invalid literal for int() with base 10: 'A text'a_list = [1, 5, 7]\nan_array = np.array(a_list)\n\n# Slicing (Teilauswahl)\nprint(a_list[:2])\n#> [1, 5]\nprint(an_array[1:])\n#> [5 7]\n\n# for-Schleife\nfor value in an_array:\n  print(value)\n#> 1\n#> 5\n#> 7# Werte anhängen\nan_array = np.append(an_array, 4)\nprint(an_array)\n#> [1 5 7 4]a_list = [1, 2, 3]\nan_array = np.array(a_list)\n2 * an_array + 1\n#> array([3, 5, 7])array1 = np.array([1, 2, 4])\narray2 = np.array([-1, -3, 5])\narray1 + array2\n#> array([ 0, -1,  9])array1 = np.array([1, 2, 4])\narray2 = np.array([-1, -3, 5, 7])\narray1 + array2\n#> operands could not be broadcast together with shapes (3,)\n#> (4,)a_vector = np.array([1, 2, -4])\na_scalar = np.array([-1])\na_vector * a_scalar\n#> array([-1, -2,  4])"},{"path":"sudoku-brute-force.html","id":"d-numpy-arrays-auch-matrizen-genannt","chapter":"Kapitel 11 Sudoku: Brute-Force-Algorithmus","heading":"11.3 2D-NumPy-Arrays, auch Matrizen genannt","text":"Die wahre Stärke von NumPy entfaltet sich, sobald dein Array zwei oder mehr Dimensionen hat. 2D-Arrays werden als Matrizen bezeichnet, während Arrays mit drei oder mehr Dimensionen als Tensoren bekannt sind. Erstere spielen eine Schlüsselrolle der klassischen linearen Algebra Python, während letztere für künstliche neuronale Netzwerke erforderlich sind (deshalb auch “Tensor” TensorFlow).Wie bei Vektoren (1D-Arrays) im Vergleich zu Python-Listen, ergibt sich der Vorteil aus Einschränkungen. Matrizen sind rechteckig, d.h., sie bestehen aus mehreren Reihen, aber jede Reihe hat die gleiche Anzahl von Elementen. Im Gegensatz dazu kannst du eine rechteckige Matrix als Liste von Listen erstellen (auch hier war unser CONNECTED_CAVES eine \\(20\\times3\\) rechteckige Matrix), aber dies ist nicht garantiert. Darüber hinaus bedeutet die Homogenität der Matrix (alle Werte müssen vom gleichen Typ sein), dass du einen rechteckigen Teil der Matrix extrahieren kannst und es garantiert eine weitere Matrix des gleichen Typs ist. Und Slicing macht das Arbeiten mit 2D-Arrays viel einfacher. Zum Beispiel, hier ist der Code, um eine Spalte aus einer Liste von Listen im Vergleich zu einer NumPy-Matrix zu extrahieren.Das Extrahieren von Zeilen, Spalten und quadratischen Blöcken aus einer Matrix wird entscheidend sein, um den Code für Sudoku zu schreiben, also lass uns üben!Mache Übung #4.","code":"matrix_as_list = [[1, 2, 3],\n                  [4, 5, 6],\n                  [7, 8, 9]]\nmatrix_as_array = np.array(matrix_as_list)\n\nicolumn = 1 # der Spaltenindex, den wir extrahieren möchten\n\n# Extrahieren einer Spalte mittels List Comprehension\ncolumn_as_list = [row[icolumn] for row in matrix_as_list]\nprint(column_as_list)\n#> [2, 5, 8]\n\n# Extrahieren einer Spalte aus einer Matrix\nprint(matrix_as_array[:, 1])\n#> [2 5 8]"},{"path":"sudoku-brute-force.html","id":"arrays-einer-bestimmten-form-erstellen","chapter":"Kapitel 11 Sudoku: Brute-Force-Algorithmus","heading":"11.4 Arrays einer bestimmten Form erstellen","text":"Es gibt verschiedene Möglichkeiten, NumPy-Arrays zu erstellen. Oben haben wir Listen oder Listen von Listen verwendet, um sie zu erstellen. Aber manchmal musst du ein Array einer bestimmten Form anlegen, das mit Nullen oder Einsen gefüllt ist. Der Schlüsselparameter diesen Funktionen ist die Form des Arrays: eine Liste mit den Dimensionen des Arrays. Für ein 1D-Array kann dies entweder <Anzahl der Elemente> oder (<Anzahl der Elemente>, ) sein. Für ein 2D-Array bedeutet dies (<Anzahl der Zeilen>, <Anzahl der Spalten>).Mache Übung #5.","code":"zeros_matrix_3_by_2 = np.zeros((3, 2))\nprint(zeros_matrix_3_by_2)\n#> [[0. 0.]\n#>  [0. 0.]\n#>  [0. 0.]]"},{"path":"sudoku-brute-force.html","id":"zufällige-arrays-einer-bestimmten-größe-erstellen","chapter":"Kapitel 11 Sudoku: Brute-Force-Algorithmus","heading":"11.5 Zufällige Arrays einer bestimmten Größe erstellen","text":"NumPy hat ein Modul zur Generierung von Zufallszahlen — numpy.random — das konzeptuell ähnlich zur Python-standardmäßigen random Bibliothek ist, aber es ermöglicht dir die Erstellung von Arrays von Werten anstatt eines einzigen Wertes. Aus Bequemlichkeit sind die Namen gleich geblieben. Zum Beispiel hat die Funktion random.randint, die eine einzige zufällige Ganzzahl generiert, einen Zwillingsbruder numpy.random.randint, der dieselben Parameter akzeptiert und standardmäßig ebenfalls einen einzigen Wert generiert. Du kannst jedoch das ganze Vektor-/Matrix-/Tensor-Array von Zufallszahlen auf einen Schlag generieren, indem du seine Größe angibst. Verwirrenderweise wird der Parameter size genannt, obwohl er sich auf die “Ausgabeform” bezieht (nicht sicher, warum sie es nicht “Form” genannt haben).Mache Übung #6.","code":""},{"path":"sudoku-brute-force.html","id":"erstellen-von-arrays-mit-sequenzen","chapter":"Kapitel 11 Sudoku: Brute-Force-Algorithmus","heading":"11.6 Erstellen von Arrays mit Sequenzen","text":"Ähnlich wie man eine Folge von Ganzzahlen mit range erstellen kann, kann man einen Vektor von Ganzzahlen mit arange45 erstellen und dies ist gleichwertig mit np.array(range(...)):NumPy hat auch eine praktische Funktion namens linspace, mit der du eine Sequenz von Fließkommazahlen mit einer beliebigen Fließkommazahl-Schrittweite erzeugen kannst.Mache Übung #7.","code":"print(np.arange(5))\n#> [0 1 2 3 4]\nprint(np.array(range(5)))\n#> [0 1 2 3 4]"},{"path":"sudoku-brute-force.html","id":"stack","chapter":"Kapitel 11 Sudoku: Brute-Force-Algorithmus","heading":"11.7 Arrays zu einer Matrix stapeln","text":"Die Funktion arange wird für uns nützlich sein, um eine Sequenz von Ganzzahlen von 1 bis 9 (oder 1 bis 4, wenn wir einer kleineren Version von Sudoku arbeiten) zu erzeugen. Beachte jedoch, dass du beiden Fällen nur einen Vektor, aber nicht die Matrix erzeugen kannst, die wir brauchen! Die Lösung diesem Fall ist, einzelne Vektoren zu stapeln (stack). Beim Stapeln spielen die Formen (shapes) der einzelnen Vektoren eine wichtige Rolle, da sie kompatibel sein müssen. Dies ist ein Schlüsselpunkt im Unterschied zu Python-Listen, die nur eine Länge haben.Für wirklich eindimensionale Arrays ist es einfach. Dies sind Arrays, die aus Listen oder über Funktionen wie zeros oder linspace erstellt wurden. Wenn du dir ihre Form ansiehst, wirst du nur eine Dimension sehen.Diese Vektoren haben keine “Orientierung” (wenn du dich mit linearer Algebra auskennst, würdest du entweder Spalten- oder Zeilenvektoren erwarten), daher kannst du beim Kombinieren dieser Arrays zu einer Matrix sie als Zeilen verwenden (stapeln entlang axis=0, das ist der Standard, siehe auch vstack) oder als Spalten (stapeln entlang axis=1, siehe auch hstack).Übe das Stapeln. Das Ergebnis für eine durch Zeilen gestapelte Matrix sieht aus:und für eine durch Spalten gestapelte Matrix sieht es aus:Mache Übung #8.","code":"print(np.array([10, 20, 30]).shape)\n#> (3,)\nprint(np.zeros(5).shape)\n#> (5,)one_d_vector = np.arange(5)\n\n# Vertikal stapeln: Vektoren werden als Zeilen verwendet\nprint(np.stack([one_d_vector, one_d_vector]))\n#> [[0 1 2 3 4]\n#>  [0 1 2 3 4]]\nprint(np.stack([one_d_vector, one_d_vector]).shape)\n#> (2, 5)\n\n# Horizontal stapeln: Vektoren werden als Spalten verwendet\nprint(np.stack([one_d_vector, one_d_vector], axis=1))\n#> [[0 0]\n#>  [1 1]\n#>  [2 2]\n#>  [3 3]\n#>  [4 4]]\nprint(np.stack([one_d_vector, one_d_vector], axis=1).shape)\n#> (5, 2)#> array([[1, 2, 3, 4],\n#>        [1, 2, 3, 4],\n#>        [1, 2, 3, 4],\n#>        [1, 2, 3, 4]])#> array([[1, 1, 1, 1],\n#>        [2, 2, 2, 2],\n#>        [3, 3, 3, 3],\n#>        [4, 4, 4, 4]])"},{"path":"sudoku-brute-force.html","id":"zeilen--und-spaltenvektoren-versus-1d-arrays-row-col-vectors","chapter":"Kapitel 11 Sudoku: Brute-Force-Algorithmus","heading":"11.8 Zeilen- und Spaltenvektoren versus 1D-Arrays (#row-col-vectors)","text":"Wie oben erwähnt, sind 1D-Arrays wirklich eindimensional, da ihre Form (N, ) ist (beachte die leere Stelle nach dem Komma). Jedoch benötigst du oft denselben Vektor einer 2D-Form entweder als Zeilenvektor (1, N) oder als Spaltenvektor (N, 1). Der Unterschied zwischen einem 1D-Array und einem 2D-Zeilen-/Spaltenvektor ist, dass Letztere eine “Orientierung” haben46 und trotz der gleichen Anzahl von Elementen unterschiedlich gestapelte Arrays erzeugen werden.Du kannst ein 1D-Array (N, ) einen Zeilenvektor (1, N) umwandeln, indem du es eine weitere Liste packst: np.array([<original Liste oder 1D-Array>]). Wie du unten sehen kannst, obwohl die Formen der beiden Arrays unterschiedlich sind, ist ihre Größe (Gesamtanzahl der Elemente) gleich.Es gibt zwei Möglichkeiten, einen Spaltenvektor mit der Form (N, 1) zu erstellen. Erstens kannst du ihn als Liste von Listen mit einem Wert pro Zeile (innere Liste) angeben. Alternativ kannst du einen Zeilenvektor erstellen und dann transponieren.Wie oben erwähnt, macht die “Orientierung” von Vektoren einen Unterschied beim Stapeln. Erkunde diese Unterschiede der Übung 9.Mache Übung #9.","code":"# Ein 1D-Array\noned_array = np.array([1, 2, 3])\n(oned_array.shape, oned_array.size)\n#> ((3,), 3)\n\n# Ein 2D-Array, jedoch mit der gleichen Anzahl von Elementen und der gleichen größten Dimension\nrow_vector = np.array([[1, 2, 3]])\n(row_vector.shape, row_vector.size)\n#> ((1, 3), 3)# Spaltenvektor aus Liste von Listen\nnp.array([[1], [2], [3]])\n#> array([[1],\n#>        [2],\n#>        [3]])\n\n# Spaltenvektor durch Transposition eines Zeilenvektors\nnp.transpose(np.array([[1, 2, 3]]))\n#> array([[1],\n#>        [2],\n#>        [3]])"},{"path":"sudoku-brute-force.html","id":"wiederholen-und-kacheln","chapter":"Kapitel 11 Sudoku: Brute-Force-Algorithmus","heading":"11.9 Wiederholen und Kacheln","text":"der oben genannten Übung hast du vier Zeilen- oder Spaltenvektoren gestapelt, aber sie waren alle identisch. NumPy kann solche wiederholten Sequenzen über die Funktionen repeat und tile generieren. Beide wiederholen die angeforderten Werte eine bestimmte Anzahl von Malen, aber es gibt ein paar wichtige Unterschiede. Erstens wiederholt repeat jeden Wert N Mal, bevor es zum nächsten Wert übergeht, während tile die gesamte Sequenz Reihenfolge N Mal wiederholt.Der zweite Unterschied besteht darin, wie du die Wiederholung beim Erstellen von 2D-Matrizen spezifizierst. Im Falle von repeat gibst du , entlang welcher Achse (axis) du die Sequenz wiederholst (gleich wie der Achse-Parameter beim Stapeln).Mache Übung #10.Für tile gibt man die Wiederholungen (reps-Parameter) , und man kann die Wiederholungen pro Achse spezifizieren.Mache Übung #11.","code":"print(np.repeat(np.arange(5), 2))\n#> [0 0 1 1 2 2 3 3 4 4]\nprint(np.tile(np.arange(5), 2))\n#> [0 1 2 3 4 0 1 2 3 4]# Ein Array zweimal zeilenweise und dreimal spaltenweise kacheln (tile)\nnp.tile(np.array([1, 2, 3]), (2, 3))\n#> array([[1, 2, 3, 1, 2, 3, 1, 2, 3],\n#>        [1, 2, 3, 1, 2, 3, 1, 2, 3]])"},{"path":"sudoku-brute-force.html","id":"sudoku-erzeugung-mittels-brute-force-ordnung-und-chaos","chapter":"Kapitel 11 Sudoku: Brute-Force-Algorithmus","heading":"11.10 Sudoku-Erzeugung mittels Brute-Force: Ordnung und Chaos","text":"Unser Ansatz zur Erzeugung von Sudoku wird konzeptionell einfach, aber sehr ineffizient sein: Wir werden eine geordnete Matrix erstellen (nach Zeile oder Spalte; keine gültige Ausgangslösung), diese mischen (zeilen- oder spaltenweise), und dann prüfen, ob wir zufällig eine gültige Sudoku-Matrix erhalten haben. Wenn nicht, weiter mischen, bis wir eine haben.Du weißt bereits, wie man eine geordnete Matrix erstellt, die vier oder neun Zeilen und Spalten hat. Um sie zu randomisieren, verwende np.random.shuffle, das ein Array oder einen Teil eines Arrays Ort mischt. Der letzte Teil bedeutet, dass die Funktion keinen Wert zurückgibt und das von dir gelieferte Array (es wird per Referenz übergeben, erinnere dich veränderliche Objekte und Funktionen).Schreibe den Code, der eine \\(4\\times4\\)-Matrix erstellt (definiere die Größe der Matrix über die Konstante SUDOKU_SIZE), die nach Zeilen geordnet ist\n(also jede Zeile geht von 1 bis SUDOKU_SIZE, aber jede Spalte hat die gleiche Zahl darin), und schreibe den Code, der genau eine Zeile mischt (lege ihren Index der Variablen irow fest). Ändere den Wert von irow, um zu testen, ob dein Code funktioniert. Beispielsweise könnte dein Output für eine zufällig gemischte Zeile #2 aussehen.Schreibe Code für das Erstellen einer Matrix\nund das Mischen einer Zeile Übung #12.Sobald der Code für das Mischen einer einzelnen Zeile funktioniert, modifiziere ihn , dass alle Zeilen einzeln gemischt werden (du kannst das gesamte Matrix mischen, aber dann werden die Zeilen höchstwahrscheinlich ungültig sein). Sobald der Misch-Code funktioniert, verwandle ihn eine Funktion shuffle_by_row. Wie bei np.random.shuffle muss sie nichts zurückgeben, da das Mischen direkt im übergebenen Array erfolgt. Schreibe den Code, der eine nach Zeilen geordnete Matrix der Größe SUDOKU_SIZE generiert, diese zeilenweise mischt und ausgibt. Du musst definitiv die Form der Matrix kennen und über den Bereich der Zeilen iterieren.Füge shuffle_by_row utils.py ein\nSchreibe das Programm code01.pyWir sind hier, um zu lernen, also um deine Fähigkeiten zu festigen, programmiere dieselbe Routine sowohl durch das Stapeln als auch durch das Mischen der Matrix spaltenweise (erstelle hierfür eine separate Funktion shuffle_by_column).Füge shuffle_by_column utils.py ein\nSchreibe das Programm code02.py","code":"#Das gesamte Array mischen\nan_array = np.arange(5)\nnp.random.shuffle(an_array)\nprint(an_array)\n#> [4 0 1 2 3]\n\n# Einen Teil eines Arrays mischen\nan_array = np.arange(5)\nnp.random.shuffle(an_array[:3])\nprint(an_array)\n#> [1 0 2 3 4]#> array([[1, 2, 3, 4],\n#>        [2, 4, 1, 3],\n#>        [1, 2, 3, 4],\n#>        [1, 2, 3, 4]])"},{"path":"sudoku-brute-force.html","id":"beispiele-für-validierungen","chapter":"Kapitel 11 Sudoku: Brute-Force-Algorithmus","heading":"11.11 Beispiele für Validierungen","text":"Im folgenden Abschnitt wirst du Funktionen schreiben, die die Gültigkeit von Zeilen, Spalten und Blöcken überprüfen. Dafür benötigen wir Beispiele, die für alle oder einige Überprüfungen gültig sind. Verwende die Zelle unten, um später die Überprüfung durchzuführen.","code":"all_valid = np.array([[4, 1, 3, 2],\n                      [3, 2, 4, 1],\n                      [2, 4, 1, 3],\n                      [1, 3, 2, 4]])\n\ninvalid_row = np.array([[4, 1, 3, 1],\n                        [3, 2, 4, 2],\n                        [2, 4, 1, 3],\n                        [1, 3, 2, 4]])\n\ninvalid_column = np.array([[4, 1, 3, 2],\n                           [3, 2, 1, 4],\n                           [2, 4, 1, 3],\n                           [1, 3, 2, 4]])\n\ninvalid_block_and_column = np.array([[4, 3, 1, 2],\n                                     [3, 2, 4, 1],\n                                     [2, 4, 1, 3],\n                                     [1, 2, 3, 4]])\n\ninvalid_block_and_row = np.array([[4, 1, 3, 2],\n                                  [3, 4, 4, 1],\n                                  [2, 2, 1, 3],\n                                  [1, 3, 2, 4]])\n\nall_invalid = np.array([[4, 1, 3, 2],\n                        [3, 4, 1, 4],\n                        [2, 2, 1, 3],\n                        [1, 3, 2, 4]])"},{"path":"sudoku-brute-force.html","id":"ist-diese-zeile-überhaupt-gültig","chapter":"Kapitel 11 Sudoku: Brute-Force-Algorithmus","heading":"11.12 Ist diese Zeile überhaupt gültig?","text":"Damit eine Matrix ein Sudoku ist, muss sie der Regel “nur eindeutige Zahlen jeder Zeile, jeder Spalte und jedem Block” folgen. Lass uns einen Code implementieren, um die Zeilen zu überprüfen (ihn eine Spaltenüberprüfung umzusetzen, wird trivial sein).Damit eine Zeile gültig ist, muss sie SUDOKU_SIZE verschiedene, d.h. einzigartige Zahlen enthalten. Verwende die Funktion unique, um einen Vergleich für die Zeile irow zu schreiben (setze sie von Hand auf einen gültigen Index), dass sie tatsächlich SUDOKU_SIZE einzigartige Zahlen hat, d.h. die Größe des Arrays einzigartiger Zahlen ist gleich SUDOKU_SIZE. Gib jedoch nicht die Konstante SUDOKU_SIZE die Funktion weiter, sondern leite die Anzahl der erforderlichen einzigartigen Elemente aus der Form der Matrix selbst ab.Verwende Beispielmatrizen (siehe oben), um zu überprüfen, ob es korrekt funktioniert.Schreibe und teste die Überprüfung einer einzelnen Zeile\nÜbung #12.Sobald der Code für eine einzelne Zeile funktioniert, können wir eine List Comprehension verwenden, um eine Liste von Gültigkeitswerten zu generieren, einen für jede Zeile. Eine Matrix ist gültig (zumindest die Zeilen angeht), nur wenn alle Zeilen gültig sind. Praktischerweise hat NumPy eine Funktion , die testet, ob alle Elemente des Arrays oder der Liste True sind. Verpacke diesen Code die Funktion validate_rows, überlege dir ihre Eingaben und Ausgaben, dokumentiere sie.Füge validate_rows utils.py ein\nErweitere das Programm aus code01.py code03.py\nTeste den Code mit Beispielmatrizen.Mache nun dasselbe für Spalten und verwende beide Überprüfungen, um zu sehen, ob die Matrix ein gültiges Sudoku ist (Zeilen sollten Ordnung sein, aber Spalten sollten den Test nicht bestehen).\n::: {.program}\nFüge validate_columns utils.py ein\nErweitere das Programm aus code03.py code04.py\nTeste den Code mit Beispielmatrizen.\n:::","code":""},{"path":"sudoku-brute-force.html","id":"sudoku-block","chapter":"Kapitel 11 Sudoku: Brute-Force-Algorithmus","heading":"11.13 Blöcke","text":"Blöcke zu bearbeiten ist etwas kniffliger, da wir keine einfache einzelne Achse zum Schneiden (Slicing) verwenden können. Wir können jedoch jeden Block betrachten, als hätte er einen Zeilen- und einen Spaltenindex, die beide von 0 bis 2 für ein \\(9\\times9\\) Sudoku gehen, weil wir \\(3\\times3\\) Blöcke haben, oder von 0 bis 1 für ein \\(4\\times4\\) Sudoku, wo wir \\(2\\times2\\) Blöcke haben.\nSchreibe den Code, der Slicing verwendet, um einen einzelnen Block zu extrahieren, der durch i_block_row und i_block_col definiert ist. Berechne die Matrixzeile für die obere linke Ecke des Blocks und nimm dann einen vertikalen Ausschnitt bezüglich dieser. Das Gleiche gilt für den horizontalen Ausschnitt Bezug auf die linke obere Blockspalte der Matrix. Um das Debuggen zu erleichtern, erzeuge eine \\(9\\times9\\) Matrix aus ganzen Zahlen, gestapelt entweder nach Zeilen oder Spalten, damit leichter zu sehen ist, ob dein Code funktioniert. Teste ihn für alle Kombinationen von i_block_row und i_block_col. Du musst auch die Blockgröße berechnen oder definieren. Tue letzteres, da es sehr einfach ist, aus der Matrixform zu berechnen. einem quadratischen Sudoku ist die Blockgröße eine Quadratwurzel der Brettgröße (Bretter der Größe \\(4\\times4\\) haben Blöcke der Größe \\(2\\times2\\), Bretter der Größe \\(9\\times9\\) haben Blöcke der Größe \\(3\\times3\\) usw.). Deine Größe sollte jedoch eine ganze Zahl sein, also musst du dich selbst um die Typumwandlung kümmern.sollte die Ausgabe aussehen, wenn i_block_row = 1 und i_block_col = 0 sind, wenn du die Matrix zeilenweise stapelst.und wenn sie spaltenweise gestapelt istSchreibe und teste den Code für die Extraktion eines einzelnen Blocks\nÜbung #13.Sobald du den Code hast, um Blockwerte zu extrahieren, ist die Logik zur Überprüfung der Gültigkeit sehr ähnlich wie bei der Überprüfung von Zeilen und Spalten. Beachte, dass du unique direkt auf das extrahierte 2D-Array anwenden kannst oder optional kannst du es zuerst mit flatten ein 1D-Array umwandeln. Sobald du eine Liste von neun logischen Werten (einer pro Block) hast, kannst du überprüfen, ob diese alle True sind. Der Hauptunterschied hier ist, dass du verschachtelte Schleifen benötigst, um über das 2D-Netz der Blöcke zu iterieren. Meine Lösung besteht darin, eine leere Liste für die Validierungswerte zu erstellen und dann über die Blockzeile und Blockspalte zu iterieren, indem ich Werte der Liste hinzufüge.Füge validate_blocks utils.py ein\nTeste alle drei Validierungsfunktionen mithilfe von\nBeispielmatrizen code05.py","code":"#> array([[1, 2, 3],\n#>        [1, 2, 3],\n#>        [1, 2, 3]])#> array([[4, 4, 4],\n#>        [5, 5, 5],\n#>        [6, 6, 6]])"},{"path":"sudoku-brute-force.html","id":"brute-force-in-aktion","chapter":"Kapitel 11 Sudoku: Brute-Force-Algorithmus","heading":"11.14 Brute-Force in Aktion","text":"Wir haben alle Bausteine, um den Versuch zu starten, Sudoku mittels Brute-Force zu generieren. Fasse die drei Validierungsfunktionen, die du erstellt hast, einer einzelnen Funktion validate_matrix zusammen, die nur dann True zurückgibt, wenn alle Zeilen, alle Spalten und alle Blöcke gültig sind. Dann generiere eine geordnete Matrix zeilenweise und mische einer Schleife (ich würde eine -Schleife nutzen und sie auf zum Beispiel 1000 Iterationen beschränken) diese Matrix zeilenweise und prüfe, ob sie gültig ist. Wenn sie es ist, brich aus der Schleife aus und drucke das Sudoku aus. Schreibe eine traurige Nachricht (ohne Ausdruck einer Matrix), sobald du die Versuche aufgebraucht hast (aber ansonsten keine traurige Nachricht!). Alternativ kannst du die Matrix auch spaltenweise ordnen und dann ebenso spaltenweise mischen (warum funktioniert es nicht, sie zeilenweise zu ordnen und spaltenweise zu mischen?). Setze die Matrixgröße auf 4, aber beachte, dass unser Code mit jeder korrekten Matrixgröße funktionieren wird (\\(9\\times9\\), \\(16\\times16\\) usw.).Füge validate_matrix utils.py ein\nSchreibe das Programm code06.py","code":""},{"path":"sudoku-brute-force.html","id":"zusammenfassung-1","chapter":"Kapitel 11 Sudoku: Brute-Force-Algorithmus","heading":"11.15 Zusammenfassung","text":"Ausgezeichnet, wir haben ein funktionierendes Programm, das (sehr selten) eine vollständige Sudoku-Matrix erzeugt. Zippe und reiche ein, und nächstes Mal werden wir eine andere, effizientere Implementierung des Algorithmus schreiben.","code":""},{"path":"sudoku-backtracking.html","id":"sudoku-backtracking","chapter":"Kapitel 12 Sudoku: Backtracking-Algorithmus","heading":"Kapitel 12 Sudoku: Backtracking-Algorithmus","text":"diesem Kapitel werden wir erneut Sudoku arbeiten, diesmal jedoch einen effizienteren Backtracking-Algorithmus verwenden. Im Gegensatz zum völlig stochastischen Brute-Force-Algorithmus, der versucht, das gesamte Spielbrett auf einmal zu “erraten”, macht der Backtracking-Algorithmus eine fundierte Vermutung über jeweils eine Zelle zur Zeit. Wie den vorherigen Kapiteln werden wir das Programm Schritt für Schritt aufbauen, aber die gute Nachricht ist, dass du fast alles, du zur Implementierung brauchst, bereits kennst: Matrizen, Slicing und rekursive Funktionen. Zusätzlich werden wir es als Gelegenheit nutzen, um mehr über Listen und NumPy zu lernen. Schnapp dir das Übungs-Notebook und lies weiter.","code":""},{"path":"sudoku-backtracking.html","id":"kapitelkonzepte","chapter":"Kapitel 12 Sudoku: Backtracking-Algorithmus","heading":"12.1 Kapitelkonzepte","text":"Wiederholung von ListenEntpacken von Tupeln und ListenSeeding des ZufallsgeneratorsUmformen von ArraysAusnahmen Auslösen und Behandeln","code":""},{"path":"sudoku-backtracking.html","id":"backtracking-algorithmus","chapter":"Kapitel 12 Sudoku: Backtracking-Algorithmus","heading":"12.2 Backtracking-Algorithmus","text":"Dieser Algorithmus ist sehr intuitiv, wenn man ihn sich als Erforschung eines Baumes vorstellt. Jeder Knoten ist eine Zelle, und unser Baum ist 82 Ebenen tief (beginnend mit einem leeren Gitter und durchgehend durch alle 81 Zellen). Jeder Knoten hat bis zu neun mögliche Kanten, die von ihm ausgehen. Warum bis zu neun? Wir können die Zahlen 1 bis 9 verwenden (also maximal neun Kanten), aber es sei denn, eine Zelle befindet sich einer völlig leeren Reihe, Spalte und Block, werden einige Werte bereits vergeben sein, die gültigen Kanten einschränkt.Ein Beispiel für einen solchen Baum für \\(4\\times4\\) Sudoku wird der Abbildung unten illustriert. Du beginnst oben mit einem leeren Raster und du hast vier mögliche Wege, um die erste Zelle (Rot markiert) auszufüllen. Wenn du jedoch zu einer anderen Zelle wechselst (eine Ebene tiefer gehst), sind deine Wahlmöglichkeiten eingeschränkt, da beide Zellen zur selben Reihe gehören. Das bedeutet, wenn du \\(1\\) gewählt hast, hast du drei Möglichkeiten bis auf die \\(1\\), und wenn du \\(3\\) gewählt hast, hast du drei Möglichkeiten bis auf die \\(3\\). Sobald du eine der verfügbaren Optionen gewählt hast, gehst du zur nächsten Zelle. Es kann jedoch vorkommen, dass du eine Sackgasse gerätst, wie unten rechts gezeigt: Alle vier Zahlen wurden bereits verwendet, also gibt es keinen gültigen Wert für die Zelle und dieser Weg durch den Baum ist ungültig. Die Lösung ist, ein Stück zurückzugehen: Eine Ebene nach oben gehen, eine andere Zahl für die Zelle anstelle von \\(4\\) wählen. Hier könntest du mit sowohl \\(1\\) als auch \\(2\\) ein vollständiges Brett enden. Dies ist wichtig, da der Baum alle möglichen Wege und daher alle möglichen \\(4\\times4\\) gültigen Sudoku-Matrizen definiert!Wenn du geduldig genug bist, alle Pfade diesem Baum systematisch zu erkunden, wirst du alle gültigen Sudoku-Matrizen finden. Jedoch wollen wir nicht alle, sondern genau eine. Gleichzeitig möchten wir, dass unser Programm bei jedem Durchlauf eine andere Matrix generiert. Wenn wir unseren Erkundungsweg festlegen (immer durch die Zellen derselben Reihenfolge gehen) und unsere Wahlmöglichkeiten festlegen (wir gehen immer durch verfügbare Zahlen aufsteigender Reihenfolge), werden wir immer mit der gleichen Matrix enden. Daher wird unsere Erkundungsstrategie Zufälligkeit beinhalten. Zunächst werden wir mit kleineren \\(4\\times4\\) Matrizen arbeiten, aber sobald der Algorithmus funktioniert, wird es einfach sein, ihn anzupassen, dass er die richtigen \\(9\\times9\\) Matrizen erzeugt.","code":""},{"path":"sudoku-backtracking.html","id":"leere-matrix-voller-nullen","chapter":"Kapitel 12 Sudoku: Backtracking-Algorithmus","heading":"12.3 Leere Matrix (voller Nullen)","text":"Die allererste Matrix unserem Baum ist leer. Zur Vereinfachung bezeichnen wir Leerstellen mit \\(0\\), daher musst du eine \\(4\\times4\\) Matrix erzeugen, die mit Nullen gefüllt ist. Schreibe den Code dafür unter Verwendung von NumPy: Es gibt eine Funktion, über die du das letzte Mal gelernt hast, die genau diese Aufgabe erledigt. Ein wichtiges Detail, definiere die Größe der Matrix (\\(4\\)) als eine KONSTANTE (nennen wir sie SUDOKU_SIZE). Diese Zahl definiert sowohl die Größe der Matrix als auch den Bereich der Zahlen, sodass dies die einzige Änderung sein wird, die erforderlich ist, um Sudoku unterschiedlicher Größe zu erzeugen.Mache Übung #1.","code":""},{"path":"sudoku-backtracking.html","id":"list-repetition","chapter":"Kapitel 12 Sudoku: Backtracking-Algorithmus","heading":"12.4 Empty matrix but via list repetitions","text":"","code":""},{"path":"sudoku-backtracking.html","id":"list-repetition","chapter":"Kapitel 12 Sudoku: Backtracking-Algorithmus","heading":"12.5 Leere Matrix, aber durch List-Wiederholungen","text":"Die NumPy-Lösung erfüllt ihren Zweck, es gibt jedoch auch eine alternative Methode zur Erstellung über Wiederholungen von Listen. Das vereinfacht die Dinge hier zwar nicht, aber es ist ein netter Trick, der hilfreich sein kann, wenn man mit Listen arbeitet. Nämlich, du kannst eine Liste \\(N\\)-mal wiederholen mit <Liste> * N, wobei * N bedeutet “N-mal wiederholen”. Hier ist ein Beispiel für die viermalige Wiederholung eines Arrays mit drei Elementen.Angesichts der Tatsache, dass du eine Liste von Listen wiederholen kannst, erzeuge eine \\(4\\times4\\) Liste von Listen, die alle Nullen enthält (diese kann eine \\(4\\times4\\) Matrix mittels np.array umgewandelt werden). Dafür benötigst du nur eine Zeile Code, du darfst die \\(0\\) nicht von Hand wiederholen (also nur eine \\(0\\) deinem Code!) und verwende die Konstante SUDOKU_SIZE.Mache Übung #2.Ein wichtiger Hinweis zum Gebrauch von * für Listen im Vergleich zu NumPy-Arrays. Im letzteren Fall bedeutet * “multiplizieren mit”, also selbst wenn die Dinge ähnlich aussehen, werden sie sich sehr unterschiedlich verhalten!","code":"[1, 2, 3] * 4\n#> [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]#> [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]a_list = [1, 2, 3]\nan_array = np.array(a_list)\n\n# Wiederholung für Listen\na_list * 2\n#> [1, 2, 3, 1, 2, 3]\n\n# Multiplikation für NumPy-Arrays\nan_array * 2\n#> array([2, 4, 6])"},{"path":"sudoku-backtracking.html","id":"zellenreihe-und--spalte-aus-index","chapter":"Kapitel 12 Sudoku: Backtracking-Algorithmus","heading":"12.6 Zellenreihe und -spalte aus Index","text":"Es gibt verschiedene Möglichkeiten, einen zufälligen Weg durch die Zellen zu definieren. der Matrix wird jede Zelle durch ihre Reihe und Spalte identifiziert, aber wir können auch davon ausgehen, dass die Zellen einen eindeutigen Index haben, der von 0 bis SUDOKU_SIZE * SUDOKU_SIZE - 1 geht (warum minus eins?). Hier ist eine Illustration von dem, ich meine. Der Index geht von der Zelle oben links nach rechts und unten, also wenn du die Zellenreihe und -spalte kennst, kannst du ihren Index berechnen. Umgekehrt, wenn du den Zellenindex kennst, kannst du berechnen, welcher Reihe und Spalte sie sich befindet. Zum Beispiel befindet sich die hervorgehobene Zelle mit Index \\(9\\) Reihe \\(2\\) und Spalte \\(1\\). Das Gleiche gilt für die Reihe und Spalte des Blocks, zu dem die Zelle gehört.Deine Aufgabe ist es, eine Funktion zu schreiben, die einen Zellenindex und die Reihenbreite als Parameter nimmt und ein Tupel (eine unveränderliche Liste) mit (Reihe, Spalte) zurückgibt. Um einen Gesamtindex Reihe und Spalte umzuwandeln, solltest du zwei spezielle Division-Operatoren verwenden: den Ganzzahl-Division-Operator // und den Modulo, Rest-Division-Operator %. Der erste gibt nur den ganzzahligen Teil der Division zurück, sodass 4 // 3 gleich 1 ist (weil 4/3 gleich 1.33333 ist) und 1 // 4 gleich 0 ist (weil 1/4 gleich 0.25 ist). Der letztere gibt die verbleibenden Ganzzahlen zurück, dass 4 % 3 gleich 1 und 1 % 4 gleich 0 ist. Diese beiden Operatoren reichen aus, um die Indizes für Reihe und Spalte zu berechnen.Schreibe die Funktion und teste sie, indem du die zurückgegebenen Werte überprüfst. Zur Erinnerung, du solltest ein Tupel mit zwei Werten erhalten (return (Reihe, Spalte)), also sollte deine Ausgabe für den Index \\(9\\) wie folgt aussehen:Füge row_col_from_index utils.py ein\nTeste es code01.py","code":"row_col_from_index(9, SUDOKU_SIZE)\n#> (2, 1)"},{"path":"sudoku-backtracking.html","id":"zellenblock-reihe-und-spalte-aus-index","chapter":"Kapitel 12 Sudoku: Backtracking-Algorithmus","heading":"12.7 Zellenblock (Reihe und Spalte) aus Index","text":"Unsere Zelle gehört auch zu einem Block, der durch ihre Reihen- und Spaltenindizes definiert werden kann, wie der folgenden Abbildung dargestellt.Du kannst den Block-Reihen- und Spaltenindex aus der Reihe und Spalte berechnen, die du zuvor ermittelt hast. Denke darüber nach, welchen Operator du dafür benötigst, und du wirst auch die Blockbreite benötigen, die du leicht aus der Reihenbreite berechnen kannst: Überlege dir, wie du dies entweder mit Python oder NumPy tun kannst, wenn du bedenkst, dass du bei einem \\(4\\times4\\) Gitter 2 Blöcke, bei einem \\(9\\times9\\) — 3, bei einem \\(16\\times16\\) — 4 usw. hast. Beachte, dass die Blockbreite zwingend eine ganze Zahl sein muss, also stelle sicher, dass du den Wert umwandelst. Erweitere deine vorherige Funktion (ich habe sie coords_from_index genannt), sodass sie ein Vierer-Tupel (Reihe, Spalte, Blockreihe, Blockspalte) wie im untenstehenden Ausgabebeispiel zurückgibt. Teste sie für verschiedene Zellenindizes, wobei du die obige Abbildung als Referenz verwendest.Füge coords_from_index utils.py ein\nTeste den Code code02.py","code":"coords_from_index(9, SUDOKU_SIZE)\n#> (2, 1, 1, 0)"},{"path":"sudoku-backtracking.html","id":"tupel-entpacken","chapter":"Kapitel 12 Sudoku: Backtracking-Algorithmus","heading":"12.8 Tupel entpacken","text":"Unsere Funktion gibt ein Tupel der Form (Reihe, Spalte, Blockreihe, Blockspalte) zurück. Theoretisch könnten wir es über Indizes verwenden, sodass row_col[0] die Reihe und row_col[1] die Spalte usw. bedeutet, aber das ist schwer lesbar. Es gibt eine bessere Lösung durch sogenanntes “Entpacken” (“unpacking”). Wenn du ein Tupel erstellst, “verpackst” du vier Werte darin, das “Entpacken” kehrt diesen Vorgang um47.Dieser Trick funktioniert nur, wenn die Anzahl der Elemente und Variablen übereinstimmt, also nur geeignet, wenn zurückgegebene Tupel ihrer Größe fest sind. Beachte, dass derselbe Trick auch bei einer Liste funktioniert, aber dies bricht die Semantik. Es ist okay für Tupel, weil sie unveränderlich sind und ihre Verwendung dem Leser anzeigt, dass ihre Größe zumindest konzeptionell festgelegt ist. Im Gegensatz dazu sind Listen veränderlich, sodass ihre Verwendung darauf hinweist, dass sie beliebig lang sein können. Nochmals, es macht keinen tatsächlichen Unterschied im Programm für ein Tupel oder eine Liste von identischer Größe, aber diese Unterscheidung dient dazu, den Leser über deine Absichten zu informieren, und jegliche Hilfe beim Lesen von Code sollte willkommen sein.","code":"row, col, block_row, block_col = coords_from_index(9, SUDOKU_SIZE)\n\nprint(\"Row: %d, column %d, block row %d, block column %d\"%(row, col, block_row, block_col))\n#> Row: 2, column 1, block row 1, block column 0# zu wenige Werte (oder zu viele Variablen)\nrow, col, depth = row_col_from_index(9, SUDOKU_SIZE)\n#> not enough values to unpack (expected 3, got 2)\n\n# zu viele Werte (oder zu wenige Variablen)\nrow, col, depth = coords_from_index(9, SUDOKU_SIZE)\n#> too many values to unpack (expected 3)"},{"path":"sudoku-backtracking.html","id":"reihenfolge-des-pfades-zufällig-gestalten","chapter":"Kapitel 12 Sudoku: Backtracking-Algorithmus","heading":"12.9 Reihenfolge des Pfades zufällig gestalten","text":"Jetzt, wo du die Funktion hast, lass uns einen zufälligen Pfad generieren und ihn visualisieren. Dafür:erzeuge eine leere (Nullen) Matrixerzeuge eine Sequenz aller gültigen Zellenindizes (du kannst entweder die Python- oder die NumPy-Lösung dafür verwenden, je nachdem, du bevorzugst)mische die Reihenfolge der Sequenz durchiteriere über die Sequenz und trage für jeden Index den Besuchsreihenfolge-Index die Zelle ein (z.B. bekommt die erste besuchte Zelle \\(1\\), die zweite \\(2\\), …, die letzte \\(16\\)). Hinweis!drucke die Matrix wie unten ausTeste den Code code03.py","code":"#> [[ 1.  2.  9. 15.]\n#>  [11.  3. 16. 12.]\n#>  [ 7.  8. 13.  6.]\n#>  [14.  5.  4. 10.]]"},{"path":"sudoku-backtracking.html","id":"random-seed","chapter":"Kapitel 12 Sudoku: Backtracking-Algorithmus","heading":"12.10 Zufallsgenerator seeden","text":"Die Wahrscheinlichkeit ist hoch, dass deine Matrix anders aussieht als meine. Das macht Sinn, wir wollten, dass die Dinge zufällig sind, also ist es höchst unwahrscheinlich, genau dieselbe Reihenfolge des Zellenbesuchs zu erhalten. Manchmal benötigst du jedoch ein Paradoxon: Zufällige Zahlen, die gleich sind. D.h., du möchtest zwar zufällige Zahlen, aber du möchtest dieselben zufälligen Zahlen wie jemand anders. Das klingt seltsam, wird aber häufig benötigt, wenn du Zufälligkeit verwenden und jemand anders der Lage sein möchtest, deine Ergebnisse genau zu replizieren. Zum Beispiel bestimmen die anfänglich zufälligen Gewichte eines künstlichen neuronalen Netzwerks letztendlich dessen finalen Zustand. Wenn du also genau dasselbe NN wie ich haben willst, sollten wir die gleichen zufälligen Gewichte verwenden (und natürlich alles andere auf genau die gleiche Weise tun).Du kannst dies erreichen, indem du den Pseudo-Zufallszahlengenerator mit einer beliebigen Zahl seedest (es gibt natürlich auch das NumPy-Pendant mit dem gleichen Namen). Dadurch startet ein Pseudo-Zufallszahlengenerator bei einem bestimmten Wert, der durch den Seed bestimmt wird (aber nicht gleich diesem ist), sodass wir, wenn wir beide den gleichen Seed verwenden, genau dieselbe zufällige Sequenz erhalten. Wie kann eine Sequenz sowohl zufällig als auch gleich sein? Dies liegt daran, dass von einem Computer erzeugte Sequenzen “pseudo”-zufällig sind: Es gibt keine Korrelation zwischen aufeinanderfolgenden Zahlen, die er generiert, sodass du nicht leicht vorhersagen kannst, welche Zahl als Nächstes kommt, wenn du dir die Sequenz ansiehst, die du bereits hast. Die Zahlen werden jedoch nach einem Algorithmus generiert, sodass du, wenn du den Algorithmus und seinen internen Zustand kennst (oder diesen Zustand über einen Seed bestimmst), genau die gleiche Sequenz erhältst wie ich und scheinbar “zufällig” vorhersagen kannst, ich tue. Diese “pseudo”-zufällige Natur von Computern generierter Zufallszahlen ist für uns hier und vielen anderen Fällen (Probenahme der Bayes-Statistik, Generierung von Anfangsgewichten für neuronale Netzwerke usw.) kein Dealbreaker, ist aber kritisch, wenn das Wissen um deine “zufälligen” Zahlen mir erlaubt, dich auszunutzen. Cybersicherheit ist ein offensichtliches Beispiel für einen Bereich, dem der Unterschied zwischen wirklich zufällig und pseudo-zufällig den Unterschied zwischen sicher und gehackt bedeutet. diesem Fall nutzen Unternehmen sogar tatsächliche physikalische Systeme mit chaotischer Dynamik, um Zufallszahlen zu generieren.Aktualisiere code03.py unter Verwendung des Seeds 42.Sobald wir wissen, welcher Zelle wir arbeiten, müssen wir unsere Optionen kennen: Welche Zahlen sind noch verfügbar (falls überhaupt). Überlege, wie du das lösen würdest, bevor du weiterliest48.Die Antwort sollte ziemlich offensichtlich sein: Sets: Ziehe einfach eine Menge von bereits verwendeten Werten von der Menge aller möglichen Werte ab, und der Unterschied sind die verfügbaren Optionen. Eine leere Menge würde einen ungültigen Pfad bedeuten. Das Generieren eines kompletten Sets ist einfach, da du die SUDOKU_SIZE kennst. Die Menge der bereits verwendeten Werte besteht aus Werten, die der Reihe, der Spalte und dem Block verwendet werden, zu dem die Zelle gehört. Du weißt bereits, wie du eine Menge einzigartiger Werte für Reihe und Spalte/Block extrahieren kannst (das brauchen wir, wenn wir die Matrix im vorherigen Kapitel validiert haben). Sobald du diese drei Arrays hast, kannst du dir die Vereinigung ihrer eindeutigen Werte ansehen. Beachte, dass du drei Arrays und keine zwei hast, also denke darüber nach, wie du das machen kannst. Implementiere den Code und teste ihn, indem du eine \\(4\\times4\\) Matrix per Hand definierst (du kannst die verwenden, die ich unten erstellt habe).Das Finden einzigartiger bereits verwendeter Werte für Zelle #9 unter Verwendung der obigen Matrix sollte dir die folgenden Ergebnisse liefern (2 für die Reihe, 1 und 2 für die Spalte, 2 und 4 für den Block):Jetzt bleibt nur noch, alle möglichen gültigen Zahlen zu generieren, die bereits verwendeten abzuziehen und zu sehen, übrig bleibt.Teste code04.py .","code":"example_matrix = np.zeros((SUDOKU_SIZE, SUDOKU_SIZE))\nexample_matrix[1, 1] = 1\nexample_matrix[2, 2] = 2\nexample_matrix[3, 1] = 2\nexample_matrix[3, 0] = 4\nexample_matrix\n#> array([[0., 0., 0., 0.],\n#>        [0., 1., 0., 0.],\n#>        [0., 0., 2., 0.],\n#>        [4., 2., 0., 0.]])#> array([0., 1., 2., 4.])np.setdiff1d(np.arange(SUDOKU_SIZE + 1), already_used)\n#> array([3])"},{"path":"sudoku-backtracking.html","id":"arrays-umformen","chapter":"Kapitel 12 Sudoku: Backtracking-Algorithmus","heading":"12.11 Arrays umformen","text":"unserer vorherigen Implementierung haben wir zunächst ein 1D-Array von einzigartigen Werten berechnet und dann deren Vereinigung bestimmt. Eine alternative (wenn auch weniger effiziente) Methode wäre, zuerst alle drei Arrays zu (verknüpfen)[https://numpy.org/doc/stable/reference/generated/numpy.concatenate.html] und dann die eindeutigen Werte zu finden. Es gibt allerdings einen Haken, alle deine Arrays haben eine unterschiedliche Form: Reihen- und Spaltenvektoren sind (4, ) (eindimensional), während ein quadratischer Block die Form (2, 2) hat. Du musst entweder beide Reihen-/Spaltenvektoren eine (2, 2) Form umformen oder nur die Blockmatrix auf (4, ). Mache es auf beide Arten, aber stelle sicher, dass du die Form der Blockmatrix zur Umformung der Reihen-/Spaltenvektoren anstelle von hartkodierten Werten verwendest. Ebenso verwende die Form des Reihen-/Spaltenvektors, um die Blockmatrix umzuformen. Mache es ein drittes Mal, indem du die Blockmatrix ein 1D-Array umformst, indem du ihre eigene Größe benutzt. Schließlich gibt es noch eine andere Möglichkeit, jedes Array/Matrix/Tensor ein 1D-Array umzuwandeln, indem man es abflacht.Mache Übung #3.Sobald du herausgefunden hast, wie du Arrays umformen kannst, forme die Blockmatrix einen 1D-Vektor um, verknüpfe alle, finde eindeutige Werte, subtrahiere sie von einer vollständigen Menge und du solltest die gleichen Werte wie zuvor erhalten.Teste code05.py .","code":""},{"path":"sudoku-backtracking.html","id":"funktion-get_available_values","chapter":"Kapitel 12 Sudoku: Backtracking-Algorithmus","heading":"12.12 Funktion get_available_values","text":"Verpacke einfach den Code aus code04 (den effizienteren) eine Funktion. Ihre Eingaben sollten die Matrix selbst, der Zellenindex, die Größe des Sudoku (kein heimlicher Zugriff auf globale Konstanten oder Variablen!) und wahrscheinlich die Größe des Blocks sein. Du könntest es --fly berechnen, aber wir werden diese Funktion sehr oft aufrufen, also ist es besser, es einmal zu berechnen. Sie sollte ein Array von einzigartigen Werten zurückgeben, die du berechnet hast. Schreibe, dokumentiere und teste!Füge get_available_values utils.py ein\nTeste den Code code06.py","code":""},{"path":"sudoku-backtracking.html","id":"nur-eine-zelle","chapter":"Kapitel 12 Sudoku: Backtracking-Algorithmus","heading":"12.13 Nur eine Zelle","text":"Wir haben fast alle Teile, die wir brauchen, um das Programm zu schreiben. Lass uns langsam beginnen, indem wir den Code erstellen, der einen zufälligen Wert nur eine zufällige Zelle setzt. Du musst eine Funktion schreiben (nennen wir sie add_one_cell), die eine erweiterte Version der get_available_values Funktion sein wird. Zusätzlich zum Finden der verfügbaren Werte sollte sie diese mischen und den ersten Wert (aus dem gemischten Array) die Zelle einfügen. Da Arrays veränderbar sind, brauchen wir uns keine Gedanken über Rückgabewerte zu machen. Teste die Funktion, indem du sie mehrmals ausführst (die Zelle sollte dieselbe sein, aber die Werte sollten unterschiedlich sein), aber denke daran, wenn du deinen Zufallszahlengenerator mit 42 seedest, wirst du die gleiche Matrix erhalten wie ich.Füge add_one_cell utils.py ein\nTeste den Code code07.py","code":"#> array([[4., 0., 0., 0.],\n#>        [0., 0., 0., 0.],\n#>        [0., 0., 0., 0.],\n#>        [0., 0., 0., 0.]])"},{"path":"sudoku-backtracking.html","id":"exceptions","chapter":"Kapitel 12 Sudoku: Backtracking-Algorithmus","heading":"12.14 Ausnahmen","text":"Unser Programm wird den Baum erkunden, bis es die erforderliche Lösung findet, und dann sollte die Ausführung zum Hauptskript zurückkehren. Die Frage ist, wie können wir dieses “sobald die gültige Lösung gefunden wurde, Ausführung abbrechen und zur obersten Ebene zurückkehren” Verhalten implementieren? Im Spiel Ratet das Tier hatten wir dieses Problem nicht, weil wir einen Weg durch den Baum verfolgt haben, bis wir das Endknoten (Blatt) erreichten. Sobald die notwendigen Aktualisierungen Blattknoten durchgeführt wurden, kehrte die Funktion einfach zur vorherigen Ebene zurück, die zur vorherigen Ebene zurückkehrte usw., da keine weiteren Maßnahmen erforderlich waren und die Tatsache, dass die Funktion ihre Aktion abgeschlossen hatte, bedeutete, dass wir den Baum vollständig durchforscht hatten. Im Falle von Sudoku bedeutet jedoch die Tatsache, dass die Funktion eine Ebene nach oben zurückkehren muss, entweder 1) dass sie die letzte Zelle erreicht und gefüllt hat oder 2) dass sie keine Möglichkeit hat, sie auf gültige Weise zu vervollständigen und die vorherige Ebene (Funktion) sich anpassen muss. Um dies zu handhaben, könnten wir das Verhalten der Funktion implementieren, dass es von einem Rückgabewert abhängt (.z.B. null bedeutet “kann die Zelle nicht füllen”, nicht null bedeutet “Erfolg”). Es gibt jedoch einen alternativen Ansatz, der zwei verschiedene Mechanismen verwendet, um diese beiden Situationen zu behandeln. Die Funktion wird zurückkehren zur oberen Ebene, wenn sie die Zelle nicht füllen kann, aber sie wird den Mechanismus von Ausnahmen nutzen, um direkt zur obersten Ebene zurückzukehren, sobald die Matrix komplett ist. Dies macht unseren Code einfacher und verständlicher und gibt uns die Möglichkeit, über Ausnahmen zu lernen.Manchmal, wenn du ein Programm ausführst, passieren schlechte Dinge — Fehler. einigen Fällen ist ein abstürzendes Programm einfach nur ärgerlich, aber anderen Fällen kann es bedeuten, dass du verloren hast, welche Daten du gesammelt oder welche Berechnungen du der Zwischenzeit durchgeführt hast. Denke nur unser Spiel Ratet das Tier, das du lange gespielt hast und das abgestürzt ist, ohne den aktualisierten Entscheidungsbaum zu speichern. Gut für uns, dass Python, wie andere Sprachen, spezielle Mechanismen hat, um Ausnahmen zu behandeln, die während der Codeausführung auftreten. Immer wenn ein Fehler zur Laufzeit auftritt, wird eine Ausnahme ausgelöst: Es wird ein Objekt einer speziellen Klasse erstellt, das Informationen enthält, die das Problem beschreiben. Zum Beispiel wird ein ZeroDivisionError ausgelöst, wenn du versuchst, durch Null zu teilen, z.B. 1 / 0 (du kannst dies einem Jupyter-Notebook ausprobieren). Ein KeyError wird ausgelöst, wenn du ein Wörterbuch mit einem falschen Schlüssel benutzt; der folgende Code wird ihn auslösen:Ebenso wird ein IndexError ausgelöst, wenn du versuchst, einen ungültigen Index für eine Liste zu verwenden, ein NameError, wenn du versuchst, auf eine Variable zuzugreifen, die nicht existiert, ein AttributeError, wenn ein Objekt nicht über ein Attribut verfügt, das du zu verwenden versuchst, usw.Python verwendest du die Operatoren try: ... except:...finally:, um Ausnahmen vorherzusehen und zu behandeln:Im einfachsten Fall benötigst du nur die ersten beiden Operatoren: try und except. Schreibe im Jupyter-Notebook einen Code, der einen Division-durch-Null-Fehler erzeugt, der aber mit try...except... abgefangen wird. Gib im except einfach eine Nachricht aus, damit du weißt, dass sie ausgeführt wurde. Erstelle eine weitere Zelle, kopiere den Code und prüfe nun, dass der Code zur Ausnahmebehandlung nicht ausgeführt wird, wenn der Fehler nicht generiert wird (d.h. teile durch eine von Null verschiedene Zahl).Mache Übung #4.Die Verwendung von except: fängt alle Ausnahmen ab. Das wird jedoch als schlechter Stil angesehen (zu allgemein) und ein Linter wird sich beschweren. Stattdessen kannst du spezifischer sein und Ausnahmen basierend auf ihrer Klasse behandeln.Implementiere die Behandlung für KeyError und ZeroDivisionError; sie sollten unterschiedliche Nachrichten ausgeben, um zu überprüfen, ob es funktioniert. Teste es, indem du mit deinem Code diese Laufzeitfehler erzeugst.Mache Übung #5.Bisher hast du Ausnahmen erzeugt, indem du Laufzeitfehler im Code verursacht hast, aber du kannst diese Ausnahmen auch selbst auslösen, indem du den raise-Operator verwendest. Statt beispielsweise durch Null zu dividieren, kannst du raise ZeroDivisionError benutzen. Verwende dies mit deinem vorherigen Code, anstelle einer tatsächlichen Division durch Null. Probiere andere Ausnahmen auszulösen und zu sehen, wie dein Code sie behandelt. Überprüfe auch, passiert, wenn du die ersten beiden spezifischen Ausnahmebehandler hast, aber keinen allgemeinen except:, und löse einen NameError aus?Mache Übung #6.Bisher habe ich von Ausnahmen als einer Möglichkeit gesprochen, über Laufzeitfehler zu informieren. Sie können jedoch auf eine allgemeinere Weise verwendet werden, um den Ausführungsfluss zu steuern. Stelle dir zum Beispiel eine Situation mit geschachtelten Schleifen vor, ähnlich den “Spiel wiederholen - Runde mit Spiel wiederholen” Schleifen, die du zuvor implementiert hast. Bisher gab es keine Möglichkeit für einen Spieler, das Spiel vorzeitig zu beenden, aber wäre, wenn wir ihnen diese Option geben würden?Dies ist eine sehr ähnliche Situation wie verschachtelte rekursive Aufrufe für unseren Sudoku-Algorithmus. Hier reicht es nicht einfach aus, mit einem einfachen break aus der inneren Schleife auszusteigen oder game_over = True einzustellen, da du auch die äußere Schleife berücksichtigen musst. Du könntest eine zusätzliche Variable erstellen oder eine flexiblere game_over-Variable mit verschiedenen “Game ”-Zuständen (Erfolg, Misserfolg, Benutzerabbruch usw.) und dann überprüfen, ob du den Benutzer fragen musst, ob er noch einmal spielen möchte. Sonst könntest du direkt nach einem “willst du noch mal spielen?” fragen, gleich nachdem er “aufhören” gesagt hat. Diese zusätzlichen Zustände und Überprüfungen machen den Code jedoch schwerer lesbar, besonders wenn du weitere Verschachtelungen hast, Funktionsaufrufe Funktionsaufrufen usw. Ein alternativer Weg ist die Implementierung einer benutzerdefinierten Ausnahme, die signalisiert, dass der Benutzer beschlossen hat, das Spiel zu beenden.Du definierst eine benutzerdefinierte Ausnahme, indem du von einer Basis-Klasse Exception erbst. Da du noch nichts über objektorientierte Programmierung gelernt hast, klingt das jetzt vielleicht wie Kauderwelsch, aber hier ist der einzige Code, den du benötigst49(https://docs.python.org/3/reference/simple_stmts.html#-pass-statement) bedeutet “nichts tun” und wird Fällen verwendet, denen du aufgrund der Syntax eine Anweisung benötigst, aber nichts zu tun hast.]:Als Übung implementiere den Code mit einer einfachen endlosen -Schleife, der du fragst, ob weitergefahren oder aufgehört werden soll (entscheide selbst, wie du die Eingabe behandeln willst). Sobald du dich schließlich dafür entscheidest, das Spiel zu beenden, wirf eine QuitTheGame-Ausnahme, die vom try except-Code, der um die Schleife gewickelt ist, behandelt werden soll. Verwende Code, um die QuitTheGame-Ausnahme spezifisch zu behandeln und gib eine Nachricht aus, um zu zeigen, wie traurig du bist, dass der Spieler geht.Mache Übung #7.","code":"a_dict = {\"a_key\" : 1}\na_dict[\"b_key\"]\n#> 'b_key'try:\n    # einige Codezeilen, die einen Laufzeitfehler erzeugen könnten\nexcept:  \n    # Code, der ausgeführt wird, wenn etwas Schlechtes passiert\nfinally:\n    # Code, der sowohl mit als auch ohne Ausnahme ausgeführt wird\n    \nCode, der NUR ausgeführt wird, wenn keine Ausnahmen auftraten oder wenn eine Ausnahme behandelt wurdetry:\n    #  einige Codezeilen, die einen Laufzeitfehler erzeugen könnten\nexcept KeyError as key_error:\n# Code, der nur ausgeführt wird, wenn die KeyError-Ausnahme ausgelöst wurde, \n    # wobei die Ausnahmeinformationen im key_error-Objekt gespeichert werden\nexcept ZeroDivisionError as zero_division_error:  \n   # Code, der nur ausgeführt wird, wenn die ZeroDivisionError-Ausnahme ausgelöst wurde,\n    # wobei die Ausnahmeinformationen im zero_division_error-Objekt gespeichert werden\nexcept:\n   # Code, der ausgeführt wird, wenn irgendeine ANDERE Ausnahme ausgelöst wird.# Spiel wiederholen\nwhile want_to_play:\n    ...\n    \n    # Runden des Spiels wiederholen\n    while not game_over:\n      ...\n      \n      → Benutzer möchte das Spiel hier abbrechen ←class QuitTheGame(Exception):\n    pass"},{"path":"sudoku-backtracking.html","id":"das-rätsel-ist-gelöst-sobald-keine-zellen-mehr-zum-überprüfen-vorhanden-sind","chapter":"Kapitel 12 Sudoku: Backtracking-Algorithmus","heading":"12.15 Das Rätsel ist gelöst, sobald keine Zellen mehr zum Überprüfen vorhanden sind","text":"Unsere Funktion add_one_cell hat nur eine Zelle hinzugefügt und konnte nicht weitermachen, selbst wenn sie wollte, da sie keinen Index der nächsten Zelle hatte. Lassen Sie uns diese Funktion erweitern und die neue Version add_few_cells nennen, sodass sie anstelle eines einzelnen Zellenindex eine Liste dieser nimmt (ich habe den Parameter remaining_cells umbenannt). Wenn die Liste leer ist, sollte sie die Ausnahme GridComplete auslösen, die im Hauptskript behandelt wird (das Gitter wird ausgegeben). Wenn die Liste noch Elemente enthält, sollte die Funktion das erste als Index der aktuellen Zelle verwenden. Nachdem sie die aktuelle Zelle mit dem ersten zufällig verfügbaren Wert gefüllt hat (Code, den Sie bereits implementiert haben), ruft sie sich selbst auf (Rekursion!) und übergibt die verbleibende Liste (ohne das erste Element).Erstelle GridComplete mit dem Code für die QuitTheGame-Ausnahme, aber denke über wo du den Code platzieren sollst, da du beide der Funktion, die sich utils.py befindet, und im Hauptskript verwendest. Überlege, welcher Datei du sie definieren solltest und welcher du sie importieren solltest (Hinweis: Das Vorhandensein von kreisförmigen Abhängigkeiten ist keine gute Idee). Du importierst eine Ausnahmeklasse ähnlich wie das Verwenden einer Funktion: <file--decided-> import GridComplete.Es gibt noch keinen Backtracking-Mechanismus, daher wird unsere Funktion abstürzen (warum?), wenn wir ihr eine vollständige Liste von Zellen geben. Testen Sie sie also nur mit den ersten vier Zellen. Diese sind garantiert ausgefüllt (wiederum, warum?) und unser Code sollte eine Matrix wie unten ausgeben (Seed immer noch 42). Unsere Matrix ist nicht vollständig, aber das ist einfach, um unsere Testmechanismen für den Abschluss zu überprüfen. Hier ist die Verwendung eines Debuggers zum Nachverfolgen der Aufrufebenen sehr hilfreich, um den Mechanismus der Rekursion zu verstehen.Füge add_few_cells utils.py ein.\nTeste den Code code08.py","code":"#> array([[4., 1., 0., 0.],\n#>        [0., 2., 0., 0.],\n#>        [0., 0., 0., 0.],\n#>        [0., 0., 2., 0.]])"},{"path":"sudoku-backtracking.html","id":"hinzufügen-des-backtracking-mechanismus","chapter":"Kapitel 12 Sudoku: Backtracking-Algorithmus","heading":"12.16 Hinzufügen des Backtracking-Mechanismus","text":"Das letzte Puzzleteil, das wir brauchen, ist der Backtracking-Mechanismus. Derzeit verwendet unsere Funktion nur den ersten Wert aus der zufällig sortierten Liste verfügbarer Werte. Dieser erste Wert kann jedoch nicht zu einem gültigen Raster führen, also muss die Funktion diese Werte durchlaufen und sich selbst aufrufen. Hier bedeutet es, wenn der innere Funktionsaufruf einen Rückgabewert liefert, dass der aktuelle Zellenwert eine Sackgasse führt und wir den nächsten Wert ausprobieren müssen – daher die Schleife (denke daran, wenn der Pfad ein vollständiges Raster erzeugt, springt er direkt zur obersten Ebene, ohne jemals return zu verwenden). Wenn du jedoch die -Schleife vollständig durchlaufen hast, bedeutet das, dass die innere Funktion jedes Mal einen Rückgabewert geliefert hat und es keinen möglichen Wert für die aktuelle Zelle gibt, der die Sackgasse auflösen kann, und du musst den Wert auf null zurücksetzen (zurück zum ursprünglichen leeren Zustand!), und zurück zur übergeordneten Ebene gehen, um zu versuchen, die vorherige Zelle zu korrigieren.Rufe die Funktion add_cell auf und verwende sie anstelle von add_few_cells, sowohl im Hauptskript als auch der Funktion selbst. Verwende zuerst nur die ersten vier Indizes als einen Realitätscheck: Die Ausgabe sollte genau die gleiche sein wie für den Code, der add_few_cells verwendet hat. Verwende dann alle Indizes und wenn du den Seed auf 42 einstellst, solltest du genau die gleiche Sudoku-Lösung erhalten.Füge add_cell utils.py ein.\nTeste den Code code09.py.","code":"#> array([[4, 1, 3, 2],\n#>        [3, 2, 4, 1],\n#>        [2, 4, 1, 3],\n#>        [1, 3, 2, 4]])"},{"path":"sudoku-backtracking.html","id":"zusammenfassung-2","chapter":"Kapitel 12 Sudoku: Backtracking-Algorithmus","heading":"12.17 Zusammenfassung","text":"Nun hast du eine alternative, effizientere Version des Algorithmus, der ein Sudoku generieren kann. Beim nächsten Mal werden wir fortfahren, indem wir eine vollständige Sudoku-Lösung ein Rätsel verwandeln und lernen, wie man es mithilfe von Dateiein- und -ausgabe für die Nachwelt speichert.","code":""},{"path":"minesweeper.html","id":"minesweeper","chapter":"Kapitel 13 Minesweeper","heading":"Kapitel 13 Minesweeper","text":"Du hast viel gelernt, also lass uns dieses Wissen nutzen. Du wirst immer noch ein paar neue nützliche Funktionen auf dem Weg lernen. Schnapp dir das Übungsnotebook, bevor wir anfangen.","code":""},{"path":"minesweeper.html","id":"kapitelkonzepte-1","chapter":"Kapitel 13 Minesweeper","heading":"13.1 Kapitelkonzepte","text":"Mehrmals drucken auf derselben ZeileVerketten einer Liste von Zeichenketten zu einer einzigen ZeichenketteUmwandeln von Zeichen ihren Code und zurückErstellen einer Matrix, gefüllt mit einem beliebigen Wert oder Zeichen","code":""},{"path":"minesweeper.html","id":"minesweeper-1","chapter":"Kapitel 13 Minesweeper","heading":"13.2 Minesweeper","text":"Heute werden wir eine vereinfachte textbasierte Version des Minesweeper-Spiels programmieren. diesem Spiel musst du ein rechteckiges Feld räumen, dabei aber keine Mine treffen. Jedes Mal, wenn du eine Zelle öffnest, wird entweder eine Explosion ausgelöst, falls dort eine Mine war, oder dir wird die Anzahl der Minen den umliegenden Zellen angezeigt. Das Spiel ist zu Ende, sobald du alle Felder, die keine Minen sind, geöffnet hast. Das klassische Spiel verwendet Grafiken und die Maus, aber wir werden es nur mit Text nachbilden. Daher wird der Spieler statt auf eine Zelle zu klicken ihre Koordinaten eingeben müssen, und zwar mittels Zeile (Buchstabe) und Spalte (Ziffer). Unten ist ein Beispiel dafür, wie ein 5×5-Spielfeld der Ausgabe aussehen würde, wenn alle Felder noch ungeöffnet sind.Und sollte es aussehen, wenn alle Zellen außer den Minen geöffnet sind.Wie üblich werden wir das Spiel Schritt für Schritt aufbauen.","code":"#>   12345\n#>   -----\n#> A|•••••\n#> B|•••••\n#> C|•••••\n#> D|•••••\n#> E|•••••#>   12345\n#>   -----\n#> A|00000\n#> B|01121\n#> C|02•4•\n#> D|13•4•\n#> E|1•221"},{"path":"minesweeper.html","id":"print-end","chapter":"Kapitel 13 Minesweeper","heading":"13.3 Spaltenindizes mit einer for-Schleife drucken","text":"Um dem Spieler visuell zu helfen, die Spalten zu identifizieren, müssen wir deren Indizes ausdrucken, wie der oben gezeigten Ausgabe. Du könntest einen String \"  12345\" von Hand definieren und diesen ausdrucken, aber wir möchten flexibler sein und diesen String basierend auf der Größe des Spielfelds, die einer Konstanten FIELD_SIZE gespeichert ist, generieren. Es gibt mehrere Wege, dasselbe Ziel zu erreichen, und wir werden sie alle implementieren (denn es geht ja um Übung und darum, deine Fähigkeiten auf die Probe zu stellen, erinnerst du dich?)Unser erster Ansatz ist konzeptionell der einfachste: Schleife einfach über die Zahlen bis FIELD_SIZE und drucke sie eine nach der anderen aus. Denke daran, dass range von 0 bis stop - 1 geht, also überlege, wie du dies für die Ausgabe anpassen willst oder welche start- und stop-Parameter du verwenden solltest. Das einzige Problem, das wir haben, ist, dass jede Zahl ihrer eigenen Zeile gedruckt wird. Dies ist jedoch leicht über den end-Parameter der print-Funktion zu beheben. Standardmäßig entspricht er '\\n' (neue Zeile), aber du kannst ihn auf jede andere Zeichenkette umdefinieren, einschließlich einer leeren ''. Verwende eine -Schleife, um eine Ziffer nach der anderen derselben Zeile zu drucken. Vergiss nicht, zwei zusätzliche Leerzeichen voranzustellen, um später den Zeilenindex zu berücksichtigen.Implementiere Code Übung 1.","code":""},{"path":"minesweeper.html","id":"str.join","chapter":"Kapitel 13 Minesweeper","heading":"13.4 Alle Spaltenindizes zu einer einzigen Zeichenkette verbinden","text":"Ein anderer Weg, dasselbe Ziel zu erreichen, besteht darin:Eine Liste von Zahlen erstellen.Jedes Element der Liste mit List comprehensions einen String umwandeln.Sie mit join zu einem String zusammenfügen.Der erste Schritt ist einfach: Du benutzt denselben range, um die Folge von Zahlen zu erstellen. Der zweite Schritt ist auch einfach (zumindest hast du es schon einmal gemacht!): Verwende List Comprehension, um über die von range erzeugten Werte zu iterieren und sie nacheinander einen String umzuwandeln. Vergiss nicht, die Zahlen anzupassen, wie du es der vorherigen Version getan hast, bevor du sie Strings umwandelst. Der letzte Teil ist neu, aber konzeptionell sehr einfach. join ist eine Methode eines Strings, die eine Liste von Strings (und nur Strings, deshalb brauchten wir List Comprehension zur Umwandlung) mit einem “ursprünglichen” String als Separator verbindet. Hier sind ein paar Beispiele, wie es funktioniert:Implementiere diese Lösung für unseren Spaltenindex. Vergiss nicht, ihm zwei zusätzliche Leerzeichen voranzustellen. Verwende anstelle eines zusätzlichen Prints wie zuvor, um die beiden Strings mit + zu verbinden. Zum Beispiel:Implementiere Code Übung 2.","code":"a_list = [\"cat\", \"dog\", \"duck\"]\nprint(' - '.join(a_list))\n#> cat - dog - duck\nprint(''.join(a_list))\n#> catdogduckprint('a cat and' + ' a dog')\n#> a cat and a dog"},{"path":"minesweeper.html","id":"ein-numpy-array-von-strings-zu-einer-einzigen-zeichenkette-verbinden","chapter":"Kapitel 13 Minesweeper","heading":"13.5 Ein numpy-Array von Strings zu einer einzigen Zeichenkette verbinden","text":"Du kennst bereits NumPy, und natürlich hat es auch für solche Probleme eine Lösung parat. Hier werden wirEin geordnetes Array von Zahlen unter Verwendung von arange erstellen.Mit der Methode astype alles ein Array umwandeln.Werte verbinden, genau wie du es zuvor getan hast.Wieder einmal ist der erste Schritt einfach, da du arange bereits verwendet hast, denke nur über die start- und stop-Werte nach, um das Array von 1 bis FIELD_SIZE, das du benötigst, zu erhalten. Der zweite Schritt ist neu, aber konzeptionell einfach. Du kannst den Typ aller Elemente des Arrays ändern, indem du seine Methode astype aufrufst und einen neuen Typ angibst. Hier ist zum Beispiel, wie du ein Array von Ganzzahlen ein Array von logischen Werten umwandelst (denke daran, 0 ist False, alles andere ist True):Du musst denselben Code verwenden, aber für den Typ, den du benötigst: str. Der letzte Schritt —- das Verbinden einzelner Elemente zu einer einzigen Zeichenkette und das Voranstellen von zwei zusätzlichen Leerzeichen —- ist genau wie der vorherigen Lösung.Implementiere Code Übung 3.","code":"an_array_of_integers = np.array([0, 1, 0, 2, 3, 0])\nan_array_of_integers.astype(bool)\n#> array([False,  True, False,  True,  True, False])"},{"path":"minesweeper.html","id":"eine-horizontale-linie-zeichnen","chapter":"Kapitel 13 Minesweeper","heading":"13.6 Eine horizontale Linie zeichnen","text":"Der nächste Teil der Ausgabe ist eine horizontale Linie, die FIELD_SIZE lang ist (plus zwei zusätzliche Leerzeichen vorne!). Das sollte einfach sein, verwende einfach Listenreplikation, um eine FIELD_SIZE lange Liste von --Elementen zu erstellen, und verbinde sie auf dieselbe Art und Weise, wie du es für Ziffern getan hast.Implementiere Code Übung 4.","code":""},{"path":"minesweeper.html","id":"chr-ord","chapter":"Kapitel 13 Minesweeper","heading":"13.7 Zeichen in Code umwandeln und zurück","text":"Die Zeilen sind mit Buchstaben markiert, daher brauchen wir eine einfache Methode zur Umwandlung zwischen Buchstaben und Zahlen. Der einfachste Ansatz hierbei ist, Zeichen über die ord-Funktion ihren Code umzuwandeln und vom Code zurück zum Zeichen über die chr-Funktion. Hier ist die Funktionsweise:Erstelle eine Liste von Buchstaben, beginnend mit \"\", die FIELD_SIZE Buchstaben lang ist. Denke daran, dass die Codes für Buchstaben aufeinanderfolgend sind, also ist der Code für \"B\" um eins größer als der Code für \"\", der Code für \"C\" ist um zwei größer als der Code für \"\" usw. der Übung drucke einfach diese Buchstaben jeweils einzeln jeder separaten Zeile mit einer -Schleife aus.Implementiere Code Übung 5.","code":"# Code aus Symbol\na_symbol = 'G'\nprint(ord(a_symbol))\n#> 71\n\n\n# Symbol aus Code\na_code = 72\nprint(chr(a_code))\n#> H"},{"path":"minesweeper.html","id":"koordinaten-eingeben","chapter":"Kapitel 13 Minesweeper","heading":"13.8 Koordinaten eingeben","text":"Jetzt, da wir ein Koordinatensystem haben, lassen uns eine Eingabefunktion (input_coords) erstellen, die den Benutzer auffordert, die Koordinaten der nächsten Zelle, die sie öffnen möchten, einzugeben, bis sie eine gültige Eingabe gemacht haben. Zum Beispiel sollte bei einem 5×5-Spielfeld A3 oder e5 eine gültige Eingabe sein, aber f1, a6 oder huh wären ungültig. Die Funktion sollte field_size als Parameter akzeptieren und eine Liste von zwei Zahlen zurückgeben, d.h., sie sollte sowohl die Spalte (ursprünglich Ziffer) als auch die Reihe (ursprünglich Buchstabe) einen entsprechenden nullbasierten Zeilen- und Spaltenindex umwandeln. Also würde A3 zu (0, 2) werden und e5 wäre (4, 4).Du hast bereits Erfahrung darin, Funktionen zu schreiben, die den Benutzer lange ärgern, bis sie eine gültige Eingabe machen, daher sollte dies ziemlich unkompliziert sein. Der Hauptunterschied ist, dass dieses Mal mehrere Dinge zu überprüfen sind:Der String hat eine Länge von \\(2\\) (ein Symbol für die Reihe, eines für die Spalte)Das erste Zeichen des Strings ist ein Buchstabe im gültigen BereichDas zweite Zeichen des Strings ist eine Ziffer im gültigen Bereich.Hier sind die Informationen, die du benötigst, um dies zu vervollständigen. Du kannst auf einzelne Zeichen des Strings genauso zugreifen, wie du es bei Listen tust:Um zu überprüfen, ob ein Buchstabe einem gültigen Bereich ist, musst du 1) eine Liste gültiger Buchstaben erstellen und 2) überprüfen, dass das erste Symbol dieser Liste ist. der vorherigen Übung hast du diese gültigen Buchstaben einzeln ausgedruckt, also musst du sie hier alle mithilfe von List-Comprehensions eine Liste setzen. Deine Liste wird entweder aus Groß- oder Kleinbuchstaben bestehen, also stelle sicher, dass du die Groß-/Kleinschreibung des Symbols über upper oder lower festlegst.Mache Übung 6.Um zu überprüfen, ob das zweite Symbol eine Ziffer im richtigen Bereich ist, kannst du entweder den gleichen Trick anwenden indem du 1) eine Liste von Strings mit gültigen Ziffern erstellst und 2) überprüfst, ob das zweite Symbol darin enthalten ist. Stattdessen verwende jedoch die isdigit-Methode Kombination mit int, wie du es beim Jagen des Wumpus getan hast.Mache Übung 7.Jetzt, da du weißt, wie du alle Prüfungen durchführen kannst, kannst du die Funktion input_coords schreiben. Fordere den Spieler wie zuvor einer -Schleife auf, bis alle drei Prüfungen bestanden sind. Konvertiere dann jedes Symbol einen Index. Das zweite Symbol ist einfach, da du es bereits eine Ganzzahl umgewandelt hast, korrigiere es nur für den nullbasierten Index (\\(1\\) sollte \\(0\\) sein, \\(2\\) sollte \\(1\\) sein usw.). Das erste Symbol ist ein wenig kniffliger, aber du weißt bereits, wie du einen Buchstaben eine Zahl umwandelst, indem du ord verwendest, und das Einzige, woran du denken musst, ist, dass \"\" \\(0\\) ist (überlege, wie das nützlich ist).Implementiere input_coords utils.py \nTeste es code01.py.","code":"a_string = \"cat\"\na_string[2]\n#> 't'"},{"path":"minesweeper.html","id":"np.fill","chapter":"Kapitel 13 Minesweeper","heading":"13.9 Ein leeres Minenfeld mit NumPy erstellen","text":"Unser Minenfeld wird ein 2D-NumPy-Array sein, genau wie bei unserem Sudoku-Rätsel. Der einzige Unterschied besteht darin, dass wir anstelle von Zahlen Zeichen (Strings) verwenden, um den Inhalt der Zelle anzugeben. Eine Zelle mit einer Mine darin wird als \"*\" gekennzeichnet. Eine Zelle ohne Mine wird zunächst als \" \" (Leerzeichen) angegeben, aber sobald der Spieler sie öffnet, wird dies durch die Anzahl der Minen ihrer Umgebung ersetzt (zum Beispiel \"1\" oder \"0\"). Wir kümmern uns später darum, leere Räume Zahlen umzuwandeln, da unsere erste Aufgabe darin besteht, das Minenfeld selbst zu generieren.Du beginnst mit einem leeren Feld der Größe FIELD_SIZE × FIELD_SIZE, also einem NumPy-Array von \" \" mit der Größe (FIELD_SIZE, FIELD_SIZE). Wie üblich gibt es mehrere Wege, dies zu erstellen. Erstelle zunächst eine Liste von Listen über Listenreplikation und konvertiere sie dann ein NumPy-Array. Denke daran, dass du eine Liste von Zeichen erstellen kannst, indem du ein einzelnes Zeichen eine Liste setzt und dann diese Liste FIELD_SIZE-mal wiederholst. Und dann kannst du diese Liste noch einmal FIELD_SIZE wiederholen.Implementiere Code Übung 8.Alternativ kannst du dir das Leben leichter machen, indem du ein Array mit dem full-Befehl erzeugst, das mit diesem Symbol gefüllt ist.Implementiere Code Übung 9.","code":""},{"path":"minesweeper.html","id":"minen-platzieren","chapter":"Kapitel 13 Minesweeper","heading":"13.10 Minen platzieren","text":"Jetzt, da du ein leeres Feld hast, solltest du einige Minen darin platzieren! Definiere eine Konstante MINES_NUMBER und setze sie auf eine vernünftige Anzahl von Minen (denke daran, je mehr du hast, desto schwieriger ist das Spiel). Danach platziere MINES_NUMBER Minen zufälligen Stellen. Dafür benötigst du wahrscheinlich eine - und/oder -Schleife:Generiere ein Paar gültiger Zeilen- und Spaltenindizes.Überprüfe, ob diese Zelle leer ist (keine Mine darin).Platziere die Mine, wenn die Zelle leer ist, und gehe andernfalls zu Schritt 1 zurück.Verbinde deinen Code mit dem aus Übung 9, um ein Minenfeld zu generieren.Implementiere Code Übung 10.","code":""},{"path":"minesweeper.html","id":"das-minenfeld-ausdrucken","chapter":"Kapitel 13 Minesweeper","heading":"13.11 Das Minenfeld ausdrucken","text":"Du hast das Minenfeld und du weißt, wie man die Zeilen- und Spaltenindizes ausdruckt. Kombiniere alles einer Funktion print_minefield, die das Minenfeldarray als einzigen Eingabewert nimmt und \"•\" ausdruckt, wenn das Feld leer, aber noch nicht geöffnet (\" \") ist oder eine Mine enthält (\"*\", denke daran, wenn der Spieler die Mine geöffnet hat, ist das Spiel vorbei). Die einzige andere Möglichkeit ist eine bereits geöffnete Zelle, und diese wird eine Ziffer mit der Anzahl der umgebenden Minen enthalten (wird Kürze behandelt!). Du benötigst definitiv verschachtelte -Schleifen und bedingte Anweisungen. Denke daran, dass die Ausgabe aussehen sollte (alle Felder sind entweder leer oder haben uneröffnete Minen):Implementiere print_minefield utils.py \nTeste es code02.py.","code":"#>   12345\n#>   -----\n#> A|•••••\n#> B|•••••\n#> C|•••••\n#> D|•••••\n#> E|•••••"},{"path":"minesweeper.html","id":"die-umliegenden-minen-zählen","chapter":"Kapitel 13 Minesweeper","heading":"13.12 Die umliegenden Minen zählen","text":"Wir sind fast fertig, da wir ein Feld voller Minen haben, können wir es ausdrucken und wir können den Spieler fragen, welches Feld er öffnen möchte. Wenn der Spieler jedoch das Feld öffnet und es keine Mine ist, müssen wir die Anzahl der Minen den umliegenden Zellen zählen. Dies kann von $0$ (überhaupt keine Minen) bis zu $8$ reichen (du hast ein Feld betreten, das komplett von Minen umgeben ist).Die Implementierung davon ist ziemlich unkompliziert (obwohl es einen Haken gibt):Extrahiere eine 3×3-Matrix, die die Zelle umgibt.Berechne ein logisches Array, das angibt, ob diese Zellen gleich \"*\" sind.Berechne die Gesamtanzahl der Minen mit numpy.sum.Erinnerst du dich, dass ich dich vor dem Haken gewarnt habe? Nun, wenn unsere Zelle Rand des Feldes liegt, können wir keinen 3×3-Ausschnitt haben:Es gibt zwei Möglichkeiten, das Problem zu lösen. Die erste Möglichkeit besteht darin, das Array mit \" \"-Symbolen zu erweitern und mit einem (FIELD_SIZE + 2, FIELD_SIZE + 2)-Array zu arbeiten. diesem Fall musst du dir keine Gedanken über Randfälle machen, da sie immer benachbarte Zellen haben. Und du musst die Indizes nicht nullbasierte Indizes umwandeln, da dein tatsächliches Minenfeld nun von 1 bis FIELD_SIZE verläuft und nicht von 0 bis FIELD_SIZE - 1 wie bei nullbasierten Indizes. Jedoch werden wir aus didaktischen Gründen stattdessen eine kompliziertere Lösung implementieren, die die Grenzen des Ausschnittbereichs automatisch anpasst.Du hast bereits einen rechteckigen Teil eines Numpy-Arrays ausgeschnitten, als du die Gültigkeit der Sudoku-Blöcke überprüft hast. Hier ist die Logik dieselbe, da du 1) die Startzeile, 2) die Endzeile, 3) die Startspalte und 4) die Endspalte berechnen musst. Bevor du diese Zahlen jedoch verwendest, musst du darauf achten, dass sowohl die Startzeile als auch die Startspalte nicht niedriger als \\(0\\) sind und die Endzeile und Endspalte nicht höher als FIELD_SIZE. Du kannst bedingte -Else-Aussagen verwenden, aber lass uns dies als Gelegenheit nutzen, um Grenzüberprüfungen über die Funktionen min und max zu erstellen. Hier ist die Logik: Ein Zellenspaltenindex (der, für den du Minen zählst) kann von \\(0\\) bis \\(4\\) variieren, bedeutet, dass der Index für die Zellen links davon von \\(-1\\) bis \\(3\\) geht. Der niedrigste gültige Spaltenindex ist \\(0\\), also überlege, wie du mithilfe von min oder max (welche Funktion benötigst du dafür?) eine korrekte Zahl aus 1) dem Index der Zelle links und 2) dem niedrigstmöglichen Index von \\(0\\) wählen kannst.Implementiere Code Übung 11.Die Logik für den rechten Rand ist ähnlich, aber weil das Slicing den Stop-Wert ausschließt, liegt der rechte Rand unseres rechteckigen Ausschnitts bei Spalte + 2 (also geht von \\(2\\) bis \\(6\\)), anstatt bei Spalte + 1. Der größte gültige Index ist jedoch FIELD_SIZE. Auch hier verwende entweder min oder max um die korrekte Grenze zu wählen.Implementiere Code Übung 12.Die Logik für die Zeilengrenzen ist dieselbe. Sobald du die rechteckigen Grenzen hast, vergleiche alle Elemente mit \"*\" (Mine). Denk daran, dies ist ein vektorisiertes NumPy-Array, sodass du das gesamte Array mit \"*\" vergleichen kannst und NumPy wird es elementweise für dich durchführen. Zähle dann die Anzahl der Minen mit numpy.sum.Schreibe eine Funktion count_mines, die die Matrix und Koordinaten als zwei Parameter nimmt und die Anzahl der Minen als Ergebnis zurückgibt. Beachte, dass du die Konstante FIELD_SIZE nicht explizit übergeben musst, da du sie aus der Form des Minenfelds selbst berechnen kannst. Wie üblich, dokumentiere sie (das gilt auch für alle oben genannten Funktionen!)! Hier ist ein Beispiel-Array, dem du es testen kannst:Implementiere count_mines utils.py \nTeste es code03.py mit einem fest codierten \nMinenfeld und Koordinaten.","code":"a_minefield = np.array(\n  [[' ', ' ', ' ', ' ', ' '],\n   [' ', ' ', ' ', ' ', ' '],\n   [' ', ' ', '*', ' ', '*'],\n   [' ', ' ', '*', ' ', '*'],\n   [' ', '*', ' ', ' ', ' ']], dtype='<U1')"},{"path":"minesweeper.html","id":"alles-zusammenfügen-1","chapter":"Kapitel 13 Minesweeper","heading":"13.13 Alles zusammenfügen","text":"Jetzt hast du alles, du brauchst! Schreibe ein Programm, das ein Minenfeld generiert und dann den Spieler nach Koordinaten fragt. Wenn der Spieler die Koordinaten einer Mine eingibt, ist das Spiel vorbei. Andernfalls wird die Anzahl der umliegenden Minen berechnet und diese Zelle eingetragen. Als Nächstes wird das aktualisierte Minenfeld ausgedruckt und der Spieler wird erneut nach Koordinaten gefragt.Das Spiel ist vorbei, sobald der Spieler auf eine Mine tritt oder alle leeren Felder öffnet. Im letzteren Fall werden alle leeren Felder von \" \" eine Zahl umgewandelt, sodass keine \" \"-Symbole mehr im Array übrig bleiben. Mit anderen Worten, wenn du die Anzahl der \" \" im Minenfeld-Matrix zählst und es null ist, hat der Spieler gewonnen! Hier denke über deine -Schleifen-Variable nach. Du kannst die logische verwenden, aber du kannst auch eine game_state-Variable implementieren, die zunächst auf \"playing\" gesetzt ist und das Spiel lange fortgesetzt wird, wie der game_state \"playing\" ist. Wenn der Spieler explodiert, wird es zu \"exploded\" geändert und sobald der Spieler alle Felder geöffnet hat, sollte es zu \"victory\" wechseln. Dann nach der Spielschleife, überprüfe den game_state und drucke eine entsprechende (glückliche oder traurige) Nachricht aus.Teste den Code mit einem kleineren 2×2-Feld mit einer oder zwei Minen. Du kannst (heimlich) die rohe Minenfeld-Matrix ausdrucken, um dir selbst zu helfen zu gewinnen und alle Szenarien zu testen.Implementiere das Spiel code04.py.","code":""},{"path":"minesweeper.html","id":"ausbreitung-durch-den-leeren-raum","chapter":"Kapitel 13 Minesweeper","heading":"13.14 Ausbreitung durch den leeren Raum","text":"Unser Spiel ist funktionsfähig, aber es ist mühsam, da wir die Koordinaten jeder einzelnen Zelle eingeben müssen, von der wir denken, dass sie keine Mine enthält. Das Originalspiel hat jedoch ein cooles Feature, das “triviale” Fälle für den Spieler öffnet. Wenn die Zelle, die du öffnest, keine Minen um sich hat, breiten sich die leeren Felder automatisch bis die Grenzen der Nicht-Null-Zählung aus. Hier ist ein Beispiel für dasselbe Minenfeld, das ich zuvor verwendet habe, und der Spieler entscheidet, die obere linke Ecke zu öffnen. Da dies Teil des leeren Feldes ist, öffnet der Computer alle seine Nachbarn und macht dasselbe für jeden Nachbarn mit einer Null-Zählung, bis ihm die Zellen zum Öffnen ausgehen. Wenn sich das Aufrufen einer Funktion zum Öffnen von Feldern für einen Nachbarn innerhalb der Funktion, die Felder für die Zelle öffnet, wie eine Rekursion anhört, dann ist es das auch!Der Algorithmus selbst ist sehr einfach, aber wir werden zuerst eine modifizierte Version unserer Funktion count_mines erstellen. Statt die Anzahl der Minen das Hauptskript zurückzugeben, wird diese Zahl direkt die Zelle eingetragen. Mit anderen Worten, es modifiziert die veränderbare Matrix direkt ohne etwas zurückzugeben (brauchen wir auch im Hauptcode keine Zuweisung).Nenne die Funktion count_mines_and_fill und lasse sie count_mines für die Hauptaufgabe aufrufen. Gleiche Eingaben, keine Ausgabe, keine Zuweisung im Hauptskript. Ansonsten ist der Code gleich und sollte auf dieselbe Weise funktionieren. Beachte, dass wir eigentlich die ursprüngliche Funktion count_mines aus der neuen Funktion aufrufen könnten, und für einen Moment würde es auch gut funktionieren. Aber count_mines_and_fill ist nur ein Vorläufer für count_mines_and_spread, die die Koordinaten des rechteckigen Ausschnitts kennen muss, daher benötigen wir die interne Berechnung, die von count_mines durchgeführt wird, und müssen diesen Code wiederverwenden.Implementiere count_mines_and_fill utils.py \nImplementiere das Spiel code05.pyNun zur Rekursion. Die Funktion count_mines_and_spread übernimmt den Code von count_mines_and_fill und erweitert ihn für den Fall, dass die Minenzahl null ist. Dann sollte die Funktion (verschachtelte Schleifen?) über alle benachbarten Zellen iterieren und sich selbst auf diesen aufrufen, um die Minen zu zählen, die Zählungen einzugeben und, falls auch die benachbarten Zählungen zu Null werden, die Ausbreitung sogar noch weiter voranzutreiben.Beachte, dass die Funktion für dieselbe Zelle mehrmals aufgerufen werden könnte, und das könnte ein Problem sein. Schauen wir uns die obige Illustration . Wir starten bei der Zelle oben links (0, 0). Weil ihre Minenzahl Null ist, rufen wir dieselbe Funktion für alle ihre Nachbarn auf. Aber für (1, 0) ist die Minenzahl auch Null, bedeutet, dass sie die Funktion für alle seine Nachbarn aufruft, einschließlich natürlich (0, 0)! Da die Minenzählungen für (0, 0) Null sind, löst es einen weiteren Aufruf nach (1, 0) aus, welcher dann wieder auf (0, 0) aufruft ad infinitum. Um dies zu verhindern, müssen wir nur überprüfen, ob wir diese Zelle bereits bearbeitet haben, bevor wir irgendetwas anderes tun. Mit anderen Worten, das Erste, du tun musst, ist zu überprüfen, ob der Wert der Zelle \" \" ist (wir haben sie noch nicht bearbeitet). Wenn dies nicht der Fall ist (wir haben bereits Minen dafür gezählt), sollte die Funktion einfach nur zurückkehren (buchstäblich nur return ohne Ausgabe, da unsere Funktion keine Ausgabe liefert).Und das sind die einzigen zusätzlichen Teile: 1) Anfang überprüfen, ob die Zelle bereits bearbeitet wurde, 2) sich selbst auf alle Nachbarn aufrufen, wenn die Minenzahl der Zelle Null ist. Entweder verwende ein fest codiertes Minenfeld, das wir oben definiert haben, oder verwende ein größeres (5×5) Feld mit nur einer Mine, um die Ausbreitung zu sehen. Muss im Hauptskript etwas anderes als der Funktionsname geändert werden?Implementiere count_mines_and_spread utils.py \nImplementiere das Spiel code06.py","code":""},{"path":"minesweeper.html","id":"zusammenfassung-3","chapter":"Kapitel 13 Minesweeper","heading":"13.15 Zusammenfassung","text":"Großartig, packe deinen Code ein Archiv und reiche ihn ein!","code":""}]
