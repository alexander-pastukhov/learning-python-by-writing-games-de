<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Kapitel 11 Sudoku: Brute-Force-Algorithmus | Lerne Python, indem du Textspiele entwickels</title>
<meta name="author" content="Alexander (Sasha) Pastukhov">
<meta name="description" content="In diesem Kapitel werden wir ein Programm schreiben, das ein Sudoku-Rätsel generiert. In einem typischen Sudoku-Rätsel musst du ein \(9\times9\) Gitter mit den Zahlen 1 bis 9 so vervollständigen,...">
<meta name="generator" content="bookdown 0.35 with bs4_book()">
<meta property="og:title" content="Kapitel 11 Sudoku: Brute-Force-Algorithmus | Lerne Python, indem du Textspiele entwickels">
<meta property="og:type" content="book">
<meta property="og:url" content="https://alexander-pastukhov.github.io/writing-games-with-python-and-psychopy/sudoku-brute-force.html">
<meta property="og:description" content="In diesem Kapitel werden wir ein Programm schreiben, das ein Sudoku-Rätsel generiert. In einem typischen Sudoku-Rätsel musst du ein \(9\times9\) Gitter mit den Zahlen 1 bis 9 so vervollständigen,...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kapitel 11 Sudoku: Brute-Force-Algorithmus | Lerne Python, indem du Textspiele entwickels">
<meta name="twitter:site" content="@PastukhovSasha">
<meta name="twitter:description" content="In diesem Kapitel werden wir ein Programm schreiben, das ein Sudoku-Rätsel generiert. In einem typischen Sudoku-Rätsel musst du ein \(9\times9\) Gitter mit den Zahlen 1 bis 9 so vervollständigen,...">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><script src="libs/bs3compat-0.5.1/transition.js"></script><script src="libs/bs3compat-0.5.1/tabs.js"></script><script src="libs/bs3compat-0.5.1/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><link rel="shortcut icon" href="images/python-text-favicon.svg">
<!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=G-NBXRG6YB3R"></script><script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-TMHDLSM1CE');
      </script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><style type="text/css">
    
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  </style>
<link rel="stylesheet" href="bs4_style.css">
<link rel="stylesheet" href="style.css">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">Lerne Python, indem du Textspiele entwickels</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html"><span class="header-section-number">1</span> Einleitung</a></li>
<li><a class="" href="Software.html"><span class="header-section-number">2</span> Software</a></li>
<li><a class="" href="programming-tips.html"><span class="header-section-number">3</span> Programmier-Tipps und -Tricks</a></li>
<li><a class="" href="python-grundlagen.html"><span class="header-section-number">4</span> Python Grundlagen</a></li>
<li><a class="" href="guess-the-number-single-round.html"><span class="header-section-number">5</span> Errate die Zahl: eine einzelne Runden Edition</a></li>
<li><a class="" href="guess-the-number-multi-round.html"><span class="header-section-number">6</span> Errate die Zahl: Eine Mehr-Runden-Ausgabe</a></li>
<li><a class="" href="guess-the-number-ai.html"><span class="header-section-number">7</span> Guess the Number: KI ist dran</a></li>
<li><a class="" href="One-armed-bandit.html"><span class="header-section-number">8</span> Einarmiger Bandit, aber mit Listen und Schleifen</a></li>
<li><a class="" href="hunt-the-wumpus.html"><span class="header-section-number">9</span> Jagd auf den Wumpus</a></li>
<li><a class="" href="guess-the-animal.html"><span class="header-section-number">10</span> Rate das Tier</a></li>
<li><a class="active" href="sudoku-brute-force.html"><span class="header-section-number">11</span> Sudoku: Brute-Force-Algorithmus</a></li>
</ul>

        <div class="book-extra">
          <p><a id="book-repo" href="https://github.com/alexander-pastukhov/learning-python-by-writing-games-de">View book source <i class="fab fa-github"></i></a></p>
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="sudoku-brute-force" class="section level1" number="11">
<h1>
<span class="header-section-number">Kapitel 11</span> Sudoku: Brute-Force-Algorithmus<a class="anchor" aria-label="anchor" href="#sudoku-brute-force"><i class="fas fa-link"></i></a>
</h1>
<p>In diesem Kapitel werden wir ein Programm schreiben, das ein <a href="https://de.wikipedia.org/wiki/Sudoku">Sudoku-Rätsel</a> generiert. In einem typischen Sudoku-Rätsel musst du ein <span class="math inline">\(9\times9\)</span> Gitter mit den Zahlen 1 bis 9 so vervollständigen, dass sich die Zahlen in jeder Reihe, jeder Spalte und jedem <span class="math inline">\(3\times3\)</span> Quadratblock nicht wiederholen. Wenn du das Spiel spielst, hast du ein unvollständiges Puzzle und je mehr Lücken es hat, desto schwieriger tendiert das Rätsel zu sein. Aber bevor du das Spiel spielen kannst, muss jemand (das bist du heute) 1) ein komplettes Rätsel generieren (woran wir uns heute konzentrieren werden), 2) einige Zahlen entfernen, während sichergestellt wird, dass die Lösung des Rätsels eindeutig bleibt. Heute werden wir uns auf die erste Aufgabe konzentrieren: Das Generieren eines vollständigen Bretts.</p>
<div class="float">
<img src="images/sudoku.png" style="display: block; margin: 0 auto;width:100.0%" alt="Ein Beispiel-Sudoku-Rätsel und die Lösung"><div class="figcaption">Ein Beispiel-Sudoku-Rätsel und die Lösung</div>
</div>
<p><br>
Das Rätsel basiert auf einem 2D-Gitter und prinzipiell könntest du <a href="One-armed-bandit.html#lists">Listen</a> von Zeilen (die selbst Listen sind) verwenden, um dieses Gitter zu erstellen. Das wäre ähnlich der Liste von Listen, die Informationen über verbundene Höhlen im Spiel <a href="hunt-the-wumpus.html#hunt-the-wumpus">Hunt the Wumpus</a> enthielten. Allerdings macht eine geschachtelte Listenstruktur das Arbeiten mit Spalten und Blöcken schwierig, da ihre Elemente verschiedenen Listen angehören und du anstelle von einfacherem Listen-Slicing (was nur für Zeilen funktioniert) Schleifen verwenden musst.</p>
<p>Stattdessen werden wir es als Gelegenheit nutzen, um etwas über die <a href="https://numpy.org/">NumPy</a> Bibliothek zu lernen, die eines der Schlüsselpakete für wissenschaftliches Rechnen in Python ist und die Grundlage für viele Bibliotheken zur Datenanalyse bildet. Beachte, dass das untenstehende Material keinesfalls vollständig ist. Es kratzt, wenn überhaupt, nur an der Oberfläche von NumPy. Wenn du NumPy für deine Projekte benötigst, empfehle ich dringend, einen Blick in den offiziellen <a href="https://numpy.org/doc/stable/user/absolute_beginners.html">Getting Started für absolute Anfänger</a> Leitfaden und das offizielle <a href="https://numpy.org/doc/stable/user/index.html">Benutzerhandbuch</a> zu werfen.</p>
<p>Nimm dir das <a href="notebooks/sudoku-brute-force.ipynb">Übungs-Notebook</a> und lass uns loslegen.</p>
<div id="numpy-importieren" class="section level2" number="11.1">
<h2>
<span class="header-section-number">11.1</span> NumPy importieren<a class="anchor" aria-label="anchor" href="#numpy-importieren"><i class="fas fa-link"></i></a>
</h2>
<p>NumPy ist keine Standardbibliothek von Python, daher musst du sie eventuell <a href="https://numpy.org/install/">installieren</a>. Wie bei allen Bibliotheken, musst du NumPy importieren, bevor du es in deinem Skript verwenden kannst. Dies ist jedoch einer der seltenen Fälle, bei denen das Umbenennen der Bibliothek beim Importieren der Standard und der empfohlene Weg ist:</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb99-1"><a href="sudoku-brute-force.html#cb99-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span></code></pre></div>
</div>
<div id="d-numpy-arrays-versus-python-listen" class="section level2" number="11.2">
<h2>
<span class="header-section-number">11.2</span> 1D-NumPy-Arrays versus Python-Listen<a class="anchor" aria-label="anchor" href="#d-numpy-arrays-versus-python-listen"><i class="fas fa-link"></i></a>
</h2>
<p>Die Schlüsseldatenstruktur, die NumPy einführt, ist ein NumPy-Array, das beliebig viele Dimensionen haben kann. Ein eindimensionales Array, typischerweise “Vektor” genannt, ist am direktsten mit einer Python-<a href="One-armed-bandit.html#lists">Liste</a> verwandt, hat aber sowohl einige Einschränkungen als auch zusätzliche Funktionalität. Im Gegensatz zu Python-Listen, die alles enthalten können, einschließlich anderer Listen, müssen alle Elemente eines Arrays vom gleichen Typ sein. Der Vorteil dieser Einschränkung besteht darin, dass, da alle Elemente vom gleichen Typ sind, du eine Funktion auf alle Elemente anwenden kannst. Beachte, dass dies keine Garantie dafür bietet, dass es bei intrinsisch heterogenen Python-Listen funktioniert, was der Grund ist, warum du Operationen auf jedes Element einzeln ausführen musst.</p>
<p>Du kannst aus einer Liste ein NumPy-Array über die <a href="https://numpy.org/doc/stable/reference/generated/numpy.array.html">array</a>-Funktion erstellen:</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb100-1"><a href="sudoku-brute-force.html#cb100-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb100-2"><a href="sudoku-brute-force.html#cb100-2" tabindex="-1"></a></span>
<span id="cb100-3"><a href="sudoku-brute-force.html#cb100-3" tabindex="-1"></a><span class="co"># Eine Python-Liste von Zahlen</span></span>
<span id="cb100-4"><a href="sudoku-brute-force.html#cb100-4" tabindex="-1"></a>a_list <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">7</span>]</span>
<span id="cb100-5"><a href="sudoku-brute-force.html#cb100-5" tabindex="-1"></a><span class="bu">print</span>(a_list)</span>
<span id="cb100-6"><a href="sudoku-brute-force.html#cb100-6" tabindex="-1"></a><span class="co">#&gt; [1, 5, 7]</span></span>
<span id="cb100-7"><a href="sudoku-brute-force.html#cb100-7" tabindex="-1"></a></span>
<span id="cb100-8"><a href="sudoku-brute-force.html#cb100-8" tabindex="-1"></a><span class="co"># Ein aus der Liste erstelltes NumPy-Array</span></span>
<span id="cb100-9"><a href="sudoku-brute-force.html#cb100-9" tabindex="-1"></a>an_array <span class="op">=</span> np.array(a_list)</span>
<span id="cb100-10"><a href="sudoku-brute-force.html#cb100-10" tabindex="-1"></a><span class="bu">print</span>(an_array)</span>
<span id="cb100-11"><a href="sudoku-brute-force.html#cb100-11" tabindex="-1"></a><span class="co">#&gt; [1 5 7]</span></span></code></pre></div>
<p>Beachte, dass aufgrund der Einschränkung “alle Werte müssen vom gleichen Typ sein”, wenn die ursprüngliche Python-Liste Daten verschiedener Typen enthielt, alle Werte in den flexibelsten Typ umgewandelt werden. Zum Beispiel wird eine Mischung aus logischen Werten und Ganzzahlen dir Ganzzahlen geben, eine Mischung aus Ganzzahlen und Fließkommazahlen wird dir Fließkommazahlen geben, eine Mischung aus irgendetwas mit Zeichenketten wird dir Zeichenketten geben usw.</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb101-1"><a href="sudoku-brute-force.html#cb101-1" tabindex="-1"></a><span class="co"># Logische Werte und Ganzzahlen -&gt; alle Ganzzahlen</span></span>
<span id="cb101-2"><a href="sudoku-brute-force.html#cb101-2" tabindex="-1"></a><span class="bu">print</span>(np.array([<span class="va">True</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="va">False</span>]))</span>
<span id="cb101-3"><a href="sudoku-brute-force.html#cb101-3" tabindex="-1"></a><span class="co">#&gt; [1 2 3 0]</span></span>
<span id="cb101-4"><a href="sudoku-brute-force.html#cb101-4" tabindex="-1"></a></span>
<span id="cb101-5"><a href="sudoku-brute-force.html#cb101-5" tabindex="-1"></a><span class="co"># Ganzzahlen und Fließkommazahlen -&gt; alle Fließkommazahlen</span></span>
<span id="cb101-6"><a href="sudoku-brute-force.html#cb101-6" tabindex="-1"></a><span class="bu">print</span>(np.array([<span class="fl">1.0</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="fl">0.0</span>]))</span>
<span id="cb101-7"><a href="sudoku-brute-force.html#cb101-7" tabindex="-1"></a><span class="co">#&gt; [1. 2. 3. 0.]</span></span>
<span id="cb101-8"><a href="sudoku-brute-force.html#cb101-8" tabindex="-1"></a></span>
<span id="cb101-9"><a href="sudoku-brute-force.html#cb101-9" tabindex="-1"></a><span class="co"># Logische Werte, Ganzzahlen, Fließkommazahlen und Zeichenketten -&gt; alle Zeichenketten</span></span>
<span id="cb101-10"><a href="sudoku-brute-force.html#cb101-10" tabindex="-1"></a><span class="bu">print</span>(np.array([<span class="va">False</span>, <span class="dv">1</span>, <span class="fl">2.0</span>, <span class="st">"a"</span>]))</span>
<span id="cb101-11"><a href="sudoku-brute-force.html#cb101-11" tabindex="-1"></a><span class="co">#&gt; ['False' '1' '2.0' 'a']</span></span></code></pre></div>
<p>Der Typ eines Arrays wird bei der Erstellung festgelegt, und wenn du einen Wert eines anderen Typs einfügst, wird dieser entweder in diesen Typ umgewandelt oder, falls eine Umwandlung nicht möglich ist, wird NumPy einen Fehler ausgeben.</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb102-1"><a href="sudoku-brute-force.html#cb102-1" tabindex="-1"></a><span class="co"># Array von Booleschen Werten</span></span>
<span id="cb102-2"><a href="sudoku-brute-force.html#cb102-2" tabindex="-1"></a>array_of_bool <span class="op">=</span> np.array([<span class="va">True</span>, <span class="va">False</span>, <span class="va">True</span>])</span>
<span id="cb102-3"><a href="sudoku-brute-force.html#cb102-3" tabindex="-1"></a></span>
<span id="cb102-4"><a href="sudoku-brute-force.html#cb102-4" tabindex="-1"></a><span class="co"># Ein Fließkommawert wird automatisch in einen logischen Wert umgewandelt.</span></span>
<span id="cb102-5"><a href="sudoku-brute-force.html#cb102-5" tabindex="-1"></a><span class="co"># es ergibt 'True', weil nur 0.0 'False' ist</span></span>
<span id="cb102-6"><a href="sudoku-brute-force.html#cb102-6" tabindex="-1"></a>array_of_bool[<span class="dv">1</span>] <span class="op">=</span> <span class="fl">2.0</span></span>
<span id="cb102-7"><a href="sudoku-brute-force.html#cb102-7" tabindex="-1"></a><span class="bu">print</span>(array_of_bool)</span>
<span id="cb102-8"><a href="sudoku-brute-force.html#cb102-8" tabindex="-1"></a><span class="co">#&gt; [ True  True  True]</span></span>
<span id="cb102-9"><a href="sudoku-brute-force.html#cb102-9" tabindex="-1"></a></span>
<span id="cb102-10"><a href="sudoku-brute-force.html#cb102-10" tabindex="-1"></a><span class="co"># Ein beliebiger Zeichenkettenwert, der nicht automatisch in eine Ganzzahl umgewandelt werden kann</span></span>
<span id="cb102-11"><a href="sudoku-brute-force.html#cb102-11" tabindex="-1"></a>array_of_int <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])</span>
<span id="cb102-12"><a href="sudoku-brute-force.html#cb102-12" tabindex="-1"></a>array_of_int[<span class="dv">1</span>] <span class="op">=</span> <span class="st">"A text"</span></span>
<span id="cb102-13"><a href="sudoku-brute-force.html#cb102-13" tabindex="-1"></a><span class="co">#&gt; invalid literal for int() with base 10: 'A text'</span></span></code></pre></div>
<div class="practice">
<p>Mache Übung #1.</p>
</div>
<p>Im Allgemeinen kannst du mit einem 1D-NumPy-Array das Gleiche tun wie mit einer Liste. Zum Beispiel funktioniert das Slicing auf die gleiche Weise, du kannst genauso über Elemente eines Arrays iterieren usw.</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb103-1"><a href="sudoku-brute-force.html#cb103-1" tabindex="-1"></a>a_list <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">7</span>]</span>
<span id="cb103-2"><a href="sudoku-brute-force.html#cb103-2" tabindex="-1"></a>an_array <span class="op">=</span> np.array(a_list)</span>
<span id="cb103-3"><a href="sudoku-brute-force.html#cb103-3" tabindex="-1"></a></span>
<span id="cb103-4"><a href="sudoku-brute-force.html#cb103-4" tabindex="-1"></a><span class="co"># Slicing (Teilauswahl)</span></span>
<span id="cb103-5"><a href="sudoku-brute-force.html#cb103-5" tabindex="-1"></a><span class="bu">print</span>(a_list[:<span class="dv">2</span>])</span>
<span id="cb103-6"><a href="sudoku-brute-force.html#cb103-6" tabindex="-1"></a><span class="co">#&gt; [1, 5]</span></span>
<span id="cb103-7"><a href="sudoku-brute-force.html#cb103-7" tabindex="-1"></a><span class="bu">print</span>(an_array[<span class="dv">1</span>:])</span>
<span id="cb103-8"><a href="sudoku-brute-force.html#cb103-8" tabindex="-1"></a><span class="co">#&gt; [5 7]</span></span>
<span id="cb103-9"><a href="sudoku-brute-force.html#cb103-9" tabindex="-1"></a></span>
<span id="cb103-10"><a href="sudoku-brute-force.html#cb103-10" tabindex="-1"></a><span class="co"># for-Schleife</span></span>
<span id="cb103-11"><a href="sudoku-brute-force.html#cb103-11" tabindex="-1"></a><span class="cf">for</span> value <span class="kw">in</span> an_array:</span>
<span id="cb103-12"><a href="sudoku-brute-force.html#cb103-12" tabindex="-1"></a>  <span class="bu">print</span>(value)</span>
<span id="cb103-13"><a href="sudoku-brute-force.html#cb103-13" tabindex="-1"></a><span class="co">#&gt; 1</span></span>
<span id="cb103-14"><a href="sudoku-brute-force.html#cb103-14" tabindex="-1"></a><span class="co">#&gt; 5</span></span>
<span id="cb103-15"><a href="sudoku-brute-force.html#cb103-15" tabindex="-1"></a><span class="co">#&gt; 7</span></span></code></pre></div>
<p>Allerdings wird bestimmte Funktionalität anders implementiert, wie das <a href="https://numpy.org/doc/stable/reference/generated/numpy.append.html#numpy-append">Anhängen</a> im folgenden Beispiel. Andere Funktionalitäten, wie ein <a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists">Entfernen</a> (pop), fehlen, können aber durch Slicing emuliert werden.</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb104-1"><a href="sudoku-brute-force.html#cb104-1" tabindex="-1"></a><span class="co"># Werte anhängen</span></span>
<span id="cb104-2"><a href="sudoku-brute-force.html#cb104-2" tabindex="-1"></a>an_array <span class="op">=</span> np.append(an_array, <span class="dv">4</span>)</span>
<span id="cb104-3"><a href="sudoku-brute-force.html#cb104-3" tabindex="-1"></a><span class="bu">print</span>(an_array)</span>
<span id="cb104-4"><a href="sudoku-brute-force.html#cb104-4" tabindex="-1"></a><span class="co">#&gt; [1 5 7 4]</span></span></code></pre></div>
<p>Der wichtigste praktische Unterschied zwischen Listen und NumPy-Arrays liegt darin, dass Letztere homogen sind und Operationen an ihnen vektorisiert werden. Das bedeutet, dass du eine Funktion auf das gesamte Array auf einmal anwenden kannst, was es sowohl einfacher in der Handhabung macht als auch schneller, da die meisten Operationen an Arrays stark optimiert sind. Hier ist ein Beispiel dafür, wie du den gleichen Wert mit jedem Element eines Arrays multiplizierst und dann diesen Wert zu jedem Element hinzufügst, etwas, das bei einer normalen Liste eine for-Schleife erfordert.</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb105-1"><a href="sudoku-brute-force.html#cb105-1" tabindex="-1"></a>a_list <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb105-2"><a href="sudoku-brute-force.html#cb105-2" tabindex="-1"></a>an_array <span class="op">=</span> np.array(a_list)</span>
<span id="cb105-3"><a href="sudoku-brute-force.html#cb105-3" tabindex="-1"></a><span class="dv">2</span> <span class="op">*</span> an_array <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb105-4"><a href="sudoku-brute-force.html#cb105-4" tabindex="-1"></a><span class="co">#&gt; array([3, 5, 7])</span></span></code></pre></div>
<p>Du kannst auch elementweise Operationen auf zwei (oder mehr) Arrays gleichzeitig ausführen. Zum Beispiel, hier ist ein Beispiel für elementweises Addieren von zwei Arrays.</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb106-1"><a href="sudoku-brute-force.html#cb106-1" tabindex="-1"></a>array1 <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>])</span>
<span id="cb106-2"><a href="sudoku-brute-force.html#cb106-2" tabindex="-1"></a>array2 <span class="op">=</span> np.array([<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">3</span>, <span class="dv">5</span>])</span>
<span id="cb106-3"><a href="sudoku-brute-force.html#cb106-3" tabindex="-1"></a>array1 <span class="op">+</span> array2</span>
<span id="cb106-4"><a href="sudoku-brute-force.html#cb106-4" tabindex="-1"></a><span class="co">#&gt; array([ 0, -1,  9])</span></span></code></pre></div>
<p>Beachte, dass dies nur funktioniert, wenn die <a href="https://numpy.org/doc/stable/reference/generated/numpy.shape.html">Formen</a> (shapes) der Arrays gleich sind. Im Falle von 1D-Arrays (auch Vektoren genannt), bedeutet das, dass ihre Länge gleich sein muss.</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb107-1"><a href="sudoku-brute-force.html#cb107-1" tabindex="-1"></a>array1 <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>])</span>
<span id="cb107-2"><a href="sudoku-brute-force.html#cb107-2" tabindex="-1"></a>array2 <span class="op">=</span> np.array([<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>])</span>
<span id="cb107-3"><a href="sudoku-brute-force.html#cb107-3" tabindex="-1"></a>array1 <span class="op">+</span> array2</span>
<span id="cb107-4"><a href="sudoku-brute-force.html#cb107-4" tabindex="-1"></a><span class="co">#&gt; operands could not be broadcast together with shapes (3,)</span></span>
<span id="cb107-5"><a href="sudoku-brute-force.html#cb107-5" tabindex="-1"></a><span class="co">#&gt; (4,)</span></span></code></pre></div>
<p>Gleichzeitig kannst du immer Vektoren mit einem einzelnen Element verwenden, die “Skalare” genannt werden, und dieser einzelne Wert wird für jedes Element im anderen Vektor verwendet.</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb108-1"><a href="sudoku-brute-force.html#cb108-1" tabindex="-1"></a>a_vector <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">2</span>, <span class="op">-</span><span class="dv">4</span>])</span>
<span id="cb108-2"><a href="sudoku-brute-force.html#cb108-2" tabindex="-1"></a>a_scalar <span class="op">=</span> np.array([<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb108-3"><a href="sudoku-brute-force.html#cb108-3" tabindex="-1"></a>a_vector <span class="op">*</span> a_scalar</span>
<span id="cb108-4"><a href="sudoku-brute-force.html#cb108-4" tabindex="-1"></a><span class="co">#&gt; array([-1, -2,  4])</span></span></code></pre></div>
<div class="practice">
<p>Mache Übung #2.</p>
</div>
<p>Vektorisierung bedeutet auch, dass du aggregierende Funktionen – <a href="https://numpy.org/doc/stable/reference/generated/numpy.mean.html">Mittelwert</a> (mean), <a href="https://numpy.org/doc/stable/reference/generated/numpy.median.html">Median</a>, <a href="https://numpy.org/doc/stable/reference/generated/numpy.min.html">Minimum</a> (min) usw. – auf das Array anwenden kannst, anstatt diese von Hand zu berechnen.</p>
<div class="practice">
<p>Mache Übung #3.</p>
</div>
</div>
<div id="d-numpy-arrays-auch-matrizen-genannt" class="section level2" number="11.3">
<h2>
<span class="header-section-number">11.3</span> 2D-NumPy-Arrays, auch Matrizen genannt<a class="anchor" aria-label="anchor" href="#d-numpy-arrays-auch-matrizen-genannt"><i class="fas fa-link"></i></a>
</h2>
<p>Die wahre Stärke von NumPy entfaltet sich, sobald dein Array zwei oder mehr Dimensionen hat. 2D-Arrays werden als Matrizen bezeichnet, während Arrays mit drei oder mehr Dimensionen als Tensoren bekannt sind. Erstere spielen eine Schlüsselrolle in der klassischen linearen Algebra in Python, während letztere für künstliche neuronale Netzwerke erforderlich sind (deshalb auch “Tensor” in <a href="https://www.tensorflow.org/">TensorFlow</a>).</p>
<p>Wie bei Vektoren (1D-Arrays) im Vergleich zu Python-Listen, ergibt sich der Vorteil aus Einschränkungen. Matrizen sind rechteckig, d.h., sie bestehen aus mehreren Reihen, aber jede Reihe hat die gleiche Anzahl von Elementen. Im Gegensatz dazu <em>kannst</em> du eine rechteckige Matrix als Liste von Listen erstellen (auch hier war unser <code>CONNECTED_CAVES</code> eine <span class="math inline">\(20\times3\)</span> rechteckige Matrix), aber dies ist nicht garantiert. Darüber hinaus bedeutet die Homogenität der Matrix (alle Werte müssen vom gleichen Typ sein), dass du einen rechteckigen Teil der Matrix extrahieren kannst und es garantiert eine weitere Matrix des gleichen Typs ist. Und Slicing macht das Arbeiten mit 2D-Arrays viel einfacher. Zum Beispiel, hier ist der Code, um eine Spalte aus einer Liste von Listen im Vergleich zu einer NumPy-Matrix zu extrahieren.</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb109-1"><a href="sudoku-brute-force.html#cb109-1" tabindex="-1"></a>matrix_as_list <span class="op">=</span> [[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>],</span>
<span id="cb109-2"><a href="sudoku-brute-force.html#cb109-2" tabindex="-1"></a>                  [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>],</span>
<span id="cb109-3"><a href="sudoku-brute-force.html#cb109-3" tabindex="-1"></a>                  [<span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>]]</span>
<span id="cb109-4"><a href="sudoku-brute-force.html#cb109-4" tabindex="-1"></a>matrix_as_array <span class="op">=</span> np.array(matrix_as_list)</span>
<span id="cb109-5"><a href="sudoku-brute-force.html#cb109-5" tabindex="-1"></a></span>
<span id="cb109-6"><a href="sudoku-brute-force.html#cb109-6" tabindex="-1"></a>icolumn <span class="op">=</span> <span class="dv">1</span> <span class="co"># der Spaltenindex, den wir extrahieren möchten</span></span>
<span id="cb109-7"><a href="sudoku-brute-force.html#cb109-7" tabindex="-1"></a></span>
<span id="cb109-8"><a href="sudoku-brute-force.html#cb109-8" tabindex="-1"></a><span class="co"># Extrahieren einer Spalte mittels List Comprehension</span></span>
<span id="cb109-9"><a href="sudoku-brute-force.html#cb109-9" tabindex="-1"></a>column_as_list <span class="op">=</span> [row[icolumn] <span class="cf">for</span> row <span class="kw">in</span> matrix_as_list]</span>
<span id="cb109-10"><a href="sudoku-brute-force.html#cb109-10" tabindex="-1"></a><span class="bu">print</span>(column_as_list)</span>
<span id="cb109-11"><a href="sudoku-brute-force.html#cb109-11" tabindex="-1"></a><span class="co">#&gt; [2, 5, 8]</span></span>
<span id="cb109-12"><a href="sudoku-brute-force.html#cb109-12" tabindex="-1"></a></span>
<span id="cb109-13"><a href="sudoku-brute-force.html#cb109-13" tabindex="-1"></a><span class="co"># Extrahieren einer Spalte aus einer Matrix</span></span>
<span id="cb109-14"><a href="sudoku-brute-force.html#cb109-14" tabindex="-1"></a><span class="bu">print</span>(matrix_as_array[:, <span class="dv">1</span>])</span>
<span id="cb109-15"><a href="sudoku-brute-force.html#cb109-15" tabindex="-1"></a><span class="co">#&gt; [2 5 8]</span></span></code></pre></div>
<p>Das Extrahieren von Zeilen, Spalten und quadratischen Blöcken aus einer Matrix wird entscheidend sein, um den Code für Sudoku zu schreiben, also lass uns üben!</p>
<div class="practice">
<p>Mache Übung #4.</p>
</div>
</div>
<div id="arrays-einer-bestimmten-form-erstellen" class="section level2" number="11.4">
<h2>
<span class="header-section-number">11.4</span> Arrays einer bestimmten Form erstellen<a class="anchor" aria-label="anchor" href="#arrays-einer-bestimmten-form-erstellen"><i class="fas fa-link"></i></a>
</h2>
<p>Es gibt verschiedene Möglichkeiten, NumPy-Arrays zu erstellen. Oben haben wir Listen oder Listen von Listen verwendet, um sie zu erstellen. Aber manchmal musst du ein Array einer bestimmten <a href="https://numpy.org/doc/stable/reference/generated/numpy.shape.html">Form</a> anlegen, das mit <a href="https://numpy.org/doc/stable/reference/generated/numpy.zeros.html">Nullen</a> oder <a href="https://numpy.org/doc/stable/reference/generated/numpy.ones.html">Einsen</a> gefüllt ist. Der Schlüsselparameter in diesen Funktionen ist die <em>Form</em> des Arrays: eine Liste mit den Dimensionen des Arrays. Für ein 1D-Array kann dies entweder <code>&lt;Anzahl der Elemente&gt;</code> oder <code>(&lt;Anzahl der Elemente&gt;, )</code> sein. Für ein 2D-Array bedeutet dies <code>(&lt;Anzahl der Zeilen&gt;, &lt;Anzahl der Spalten&gt;)</code>.</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb110-1"><a href="sudoku-brute-force.html#cb110-1" tabindex="-1"></a>zeros_matrix_3_by_2 <span class="op">=</span> np.zeros((<span class="dv">3</span>, <span class="dv">2</span>))</span>
<span id="cb110-2"><a href="sudoku-brute-force.html#cb110-2" tabindex="-1"></a><span class="bu">print</span>(zeros_matrix_3_by_2)</span>
<span id="cb110-3"><a href="sudoku-brute-force.html#cb110-3" tabindex="-1"></a><span class="co">#&gt; [[0. 0.]</span></span>
<span id="cb110-4"><a href="sudoku-brute-force.html#cb110-4" tabindex="-1"></a><span class="co">#&gt;  [0. 0.]</span></span>
<span id="cb110-5"><a href="sudoku-brute-force.html#cb110-5" tabindex="-1"></a><span class="co">#&gt;  [0. 0.]]</span></span></code></pre></div>
<div class="practice">
<p>Mache Übung #5.</p>
</div>
</div>
<div id="zufällige-arrays-einer-bestimmten-größe-erstellen" class="section level2" number="11.5">
<h2>
<span class="header-section-number">11.5</span> Zufällige Arrays einer bestimmten Größe erstellen<a class="anchor" aria-label="anchor" href="#zuf%C3%A4llige-arrays-einer-bestimmten-gr%C3%B6%C3%9Fe-erstellen"><i class="fas fa-link"></i></a>
</h2>
<p>NumPy hat ein Modul zur Generierung von Zufallszahlen — <a href="https://numpy.org/doc/stable/reference/random/index.html#module-numpy.random">numpy.random</a> — das konzeptuell ähnlich zur Python-standardmäßigen <a href="https://docs.python.org/3/library/random.html">random</a> Bibliothek ist, aber es ermöglicht dir die Erstellung von Arrays von Werten anstatt eines einzigen Wertes. Aus Bequemlichkeit sind die Namen gleich geblieben. Zum Beispiel hat die Funktion <a href="https://docs.python.org/3/library/random.html#random.randint">random.randint</a>, die eine einzige zufällige Ganzzahl generiert, einen Zwillingsbruder <a href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.randint.html">numpy.random.randint</a>, der dieselben Parameter akzeptiert und standardmäßig ebenfalls einen einzigen Wert generiert. Du kannst jedoch das ganze Vektor-/Matrix-/Tensor-Array von Zufallszahlen auf einen Schlag generieren, indem du seine <code>Größe</code> angibst. Verwirrenderweise wird der Parameter <code>size</code> genannt, obwohl er sich auf die “Ausgabeform” bezieht (nicht sicher, warum sie es nicht “Form” genannt haben).</p>
<div class="practice">
<p>Mache Übung #6.</p>
</div>
</div>
<div id="erstellen-von-arrays-mit-sequenzen" class="section level2" number="11.6">
<h2>
<span class="header-section-number">11.6</span> Erstellen von Arrays mit Sequenzen<a class="anchor" aria-label="anchor" href="#erstellen-von-arrays-mit-sequenzen"><i class="fas fa-link"></i></a>
</h2>
<p>Ähnlich wie man eine Folge von Ganzzahlen mit <a href="https://docs.python.org/3/library/functions.html#func-range">range</a> erstellen kann, kann man einen Vektor von Ganzzahlen mit <a href="https://numpy.org/doc/stable/reference/generated/numpy.arange.html">arange</a><a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;Der Name ist verwirrend, aber anscheinend steht dies als Abkürzung für “array range”&lt;/p&gt;"><sup>45</sup></a> erstellen und dies ist gleichwertig mit <code>np.array(range(...))</code>:</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb111-1"><a href="sudoku-brute-force.html#cb111-1" tabindex="-1"></a><span class="bu">print</span>(np.arange(<span class="dv">5</span>))</span>
<span id="cb111-2"><a href="sudoku-brute-force.html#cb111-2" tabindex="-1"></a><span class="co">#&gt; [0 1 2 3 4]</span></span>
<span id="cb111-3"><a href="sudoku-brute-force.html#cb111-3" tabindex="-1"></a><span class="bu">print</span>(np.array(<span class="bu">range</span>(<span class="dv">5</span>)))</span>
<span id="cb111-4"><a href="sudoku-brute-force.html#cb111-4" tabindex="-1"></a><span class="co">#&gt; [0 1 2 3 4]</span></span></code></pre></div>
<p>NumPy hat auch eine praktische Funktion namens <a href="https://numpy.org/doc/stable/reference/generated/numpy.linspace.html">linspace</a>, mit der du eine Sequenz von <em>Fließkommazahlen</em> mit einer beliebigen Fließkommazahl-Schrittweite erzeugen kannst.</p>
<div class="practice">
<p>Mache Übung #7.</p>
</div>
</div>
<div id="stack" class="section level2" number="11.7">
<h2>
<span class="header-section-number">11.7</span> Arrays zu einer Matrix stapeln<a class="anchor" aria-label="anchor" href="#stack"><i class="fas fa-link"></i></a>
</h2>
<p>Die Funktion <a href="https://numpy.org/doc/stable/reference/generated/numpy.arange.html">arange</a> wird für uns nützlich sein, um eine Sequenz von Ganzzahlen von 1 bis 9 (oder 1 bis 4, wenn wir an einer kleineren Version von Sudoku arbeiten) zu erzeugen. Beachte jedoch, dass du in beiden Fällen nur einen Vektor, aber nicht die Matrix erzeugen kannst, die wir brauchen! Die Lösung in diesem Fall ist, einzelne Vektoren zu <a href="https://numpy.org/doc/stable/reference/generated/numpy.stack.html">stapeln</a> (stack). Beim Stapeln spielen die <a href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.shape.html">Formen</a> (shapes) der einzelnen Vektoren eine wichtige Rolle, da sie kompatibel sein müssen. Dies ist ein Schlüsselpunkt im Unterschied zu Python-Listen, die nur eine <a href="https://docs.python.org/3/library/functions.html#len">Länge</a> haben.</p>
<p>Für wirklich eindimensionale Arrays ist es einfach. Dies sind Arrays, die aus Listen oder über Funktionen wie <a href="https://numpy.org/doc/stable/reference/generated/numpy.zeros.html">zeros</a> oder <a href="https://numpy.org/doc/stable/reference/generated/numpy.linspace.html">linspace</a> erstellt wurden. Wenn du dir ihre <a href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.shape.html">Form</a> ansiehst, wirst du nur eine Dimension sehen.</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb112-1"><a href="sudoku-brute-force.html#cb112-1" tabindex="-1"></a><span class="bu">print</span>(np.array([<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span>]).shape)</span>
<span id="cb112-2"><a href="sudoku-brute-force.html#cb112-2" tabindex="-1"></a><span class="co">#&gt; (3,)</span></span>
<span id="cb112-3"><a href="sudoku-brute-force.html#cb112-3" tabindex="-1"></a><span class="bu">print</span>(np.zeros(<span class="dv">5</span>).shape)</span>
<span id="cb112-4"><a href="sudoku-brute-force.html#cb112-4" tabindex="-1"></a><span class="co">#&gt; (5,)</span></span></code></pre></div>
<p>Diese Vektoren haben keine “Orientierung” (wenn du dich mit linearer Algebra auskennst, würdest du entweder Spalten- oder Zeilenvektoren erwarten), daher kannst du beim Kombinieren dieser Arrays zu einer Matrix sie als Zeilen verwenden (stapeln entlang <code>axis=0</code>, das ist der Standard, siehe auch <a href="https://numpy.org/doc/stable/reference/generated/numpy.vstack.html">vstack</a>) oder als Spalten (stapeln entlang <code>axis=1</code>, siehe auch <a href="https://numpy.org/doc/stable/reference/generated/numpy.hstack.html">hstack</a>).</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb113-1"><a href="sudoku-brute-force.html#cb113-1" tabindex="-1"></a>one_d_vector <span class="op">=</span> np.arange(<span class="dv">5</span>)</span>
<span id="cb113-2"><a href="sudoku-brute-force.html#cb113-2" tabindex="-1"></a></span>
<span id="cb113-3"><a href="sudoku-brute-force.html#cb113-3" tabindex="-1"></a><span class="co"># Vertikal stapeln: Vektoren werden als Zeilen verwendet</span></span>
<span id="cb113-4"><a href="sudoku-brute-force.html#cb113-4" tabindex="-1"></a><span class="bu">print</span>(np.stack([one_d_vector, one_d_vector]))</span>
<span id="cb113-5"><a href="sudoku-brute-force.html#cb113-5" tabindex="-1"></a><span class="co">#&gt; [[0 1 2 3 4]</span></span>
<span id="cb113-6"><a href="sudoku-brute-force.html#cb113-6" tabindex="-1"></a><span class="co">#&gt;  [0 1 2 3 4]]</span></span>
<span id="cb113-7"><a href="sudoku-brute-force.html#cb113-7" tabindex="-1"></a><span class="bu">print</span>(np.stack([one_d_vector, one_d_vector]).shape)</span>
<span id="cb113-8"><a href="sudoku-brute-force.html#cb113-8" tabindex="-1"></a><span class="co">#&gt; (2, 5)</span></span>
<span id="cb113-9"><a href="sudoku-brute-force.html#cb113-9" tabindex="-1"></a></span>
<span id="cb113-10"><a href="sudoku-brute-force.html#cb113-10" tabindex="-1"></a><span class="co"># Horizontal stapeln: Vektoren werden als Spalten verwendet</span></span>
<span id="cb113-11"><a href="sudoku-brute-force.html#cb113-11" tabindex="-1"></a><span class="bu">print</span>(np.stack([one_d_vector, one_d_vector], axis<span class="op">=</span><span class="dv">1</span>))</span>
<span id="cb113-12"><a href="sudoku-brute-force.html#cb113-12" tabindex="-1"></a><span class="co">#&gt; [[0 0]</span></span>
<span id="cb113-13"><a href="sudoku-brute-force.html#cb113-13" tabindex="-1"></a><span class="co">#&gt;  [1 1]</span></span>
<span id="cb113-14"><a href="sudoku-brute-force.html#cb113-14" tabindex="-1"></a><span class="co">#&gt;  [2 2]</span></span>
<span id="cb113-15"><a href="sudoku-brute-force.html#cb113-15" tabindex="-1"></a><span class="co">#&gt;  [3 3]</span></span>
<span id="cb113-16"><a href="sudoku-brute-force.html#cb113-16" tabindex="-1"></a><span class="co">#&gt;  [4 4]]</span></span>
<span id="cb113-17"><a href="sudoku-brute-force.html#cb113-17" tabindex="-1"></a><span class="bu">print</span>(np.stack([one_d_vector, one_d_vector], axis<span class="op">=</span><span class="dv">1</span>).shape)</span>
<span id="cb113-18"><a href="sudoku-brute-force.html#cb113-18" tabindex="-1"></a><span class="co">#&gt; (5, 2)</span></span></code></pre></div>
<p>Übe das Stapeln. Das Ergebnis für eine durch Zeilen gestapelte Matrix sieht so aus:</p>
<pre><code>#&gt; array([[1, 2, 3, 4],
#&gt;        [1, 2, 3, 4],
#&gt;        [1, 2, 3, 4],
#&gt;        [1, 2, 3, 4]])</code></pre>
<p>und für eine durch Spalten gestapelte Matrix sieht es so aus:</p>
<pre><code>#&gt; array([[1, 1, 1, 1],
#&gt;        [2, 2, 2, 2],
#&gt;        [3, 3, 3, 3],
#&gt;        [4, 4, 4, 4]])</code></pre>
<div class="practice">
<p>Mache Übung #8.</p>
</div>
</div>
<div id="zeilen--und-spaltenvektoren-versus-1d-arrays-row-col-vectors" class="section level2" number="11.8">
<h2>
<span class="header-section-number">11.8</span> Zeilen- und Spaltenvektoren versus 1D-Arrays (#row-col-vectors)<a class="anchor" aria-label="anchor" href="#zeilen--und-spaltenvektoren-versus-1d-arrays-row-col-vectors"><i class="fas fa-link"></i></a>
</h2>
<p>Wie oben erwähnt, sind 1D-Arrays wirklich eindimensional, da ihre Form <code>(N, )</code> ist (beachte die leere Stelle nach dem Komma). Jedoch benötigst du oft denselben Vektor in einer 2D-Form entweder als Zeilenvektor <code>(1, N)</code> oder als Spaltenvektor <code>(N, 1)</code>. Der Unterschied zwischen einem 1D-Array und einem 2D-Zeilen-/Spaltenvektor ist, dass Letztere eine “Orientierung” haben<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;Dies ist besonders wichtig für die lineare Algebra.&lt;/p&gt;"><sup>46</sup></a> und trotz der gleichen Anzahl von Elementen unterschiedlich gestapelte Arrays erzeugen werden.</p>
<p>Du kannst ein 1D-Array <code>(N, )</code> in einen Zeilenvektor <code>(1, N)</code> umwandeln, indem du es in eine weitere Liste packst: <code>np.array([&lt;original Liste oder 1D-Array&gt;])</code>. Wie du unten sehen kannst, obwohl die <a href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.shape.html">Formen</a> der beiden Arrays unterschiedlich sind, ist ihre <a href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.size.html">Größe</a> (Gesamtanzahl der Elemente) gleich.</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb116-1"><a href="sudoku-brute-force.html#cb116-1" tabindex="-1"></a><span class="co"># Ein 1D-Array</span></span>
<span id="cb116-2"><a href="sudoku-brute-force.html#cb116-2" tabindex="-1"></a>oned_array <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])</span>
<span id="cb116-3"><a href="sudoku-brute-force.html#cb116-3" tabindex="-1"></a>(oned_array.shape, oned_array.size)</span>
<span id="cb116-4"><a href="sudoku-brute-force.html#cb116-4" tabindex="-1"></a><span class="co">#&gt; ((3,), 3)</span></span>
<span id="cb116-5"><a href="sudoku-brute-force.html#cb116-5" tabindex="-1"></a></span>
<span id="cb116-6"><a href="sudoku-brute-force.html#cb116-6" tabindex="-1"></a><span class="co"># Ein 2D-Array, jedoch mit der gleichen Anzahl von Elementen und der gleichen größten Dimension</span></span>
<span id="cb116-7"><a href="sudoku-brute-force.html#cb116-7" tabindex="-1"></a>row_vector <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]])</span>
<span id="cb116-8"><a href="sudoku-brute-force.html#cb116-8" tabindex="-1"></a>(row_vector.shape, row_vector.size)</span>
<span id="cb116-9"><a href="sudoku-brute-force.html#cb116-9" tabindex="-1"></a><span class="co">#&gt; ((1, 3), 3)</span></span></code></pre></div>
<p>Es gibt zwei Möglichkeiten, einen Spaltenvektor mit der Form <code>(N, 1)</code> zu erstellen. Erstens kannst du ihn als Liste von Listen mit einem Wert pro Zeile (innere Liste) angeben. Alternativ kannst du einen Zeilenvektor erstellen und dann <a href="https://numpy.org/doc/stable/reference/generated/numpy.transpose.html">transponieren</a>.</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb117-1"><a href="sudoku-brute-force.html#cb117-1" tabindex="-1"></a><span class="co"># Spaltenvektor aus Liste von Listen</span></span>
<span id="cb117-2"><a href="sudoku-brute-force.html#cb117-2" tabindex="-1"></a>np.array([[<span class="dv">1</span>], [<span class="dv">2</span>], [<span class="dv">3</span>]])</span>
<span id="cb117-3"><a href="sudoku-brute-force.html#cb117-3" tabindex="-1"></a><span class="co">#&gt; array([[1],</span></span>
<span id="cb117-4"><a href="sudoku-brute-force.html#cb117-4" tabindex="-1"></a><span class="co">#&gt;        [2],</span></span>
<span id="cb117-5"><a href="sudoku-brute-force.html#cb117-5" tabindex="-1"></a><span class="co">#&gt;        [3]])</span></span>
<span id="cb117-6"><a href="sudoku-brute-force.html#cb117-6" tabindex="-1"></a></span>
<span id="cb117-7"><a href="sudoku-brute-force.html#cb117-7" tabindex="-1"></a><span class="co"># Spaltenvektor durch Transposition eines Zeilenvektors</span></span>
<span id="cb117-8"><a href="sudoku-brute-force.html#cb117-8" tabindex="-1"></a>np.transpose(np.array([[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]]))</span>
<span id="cb117-9"><a href="sudoku-brute-force.html#cb117-9" tabindex="-1"></a><span class="co">#&gt; array([[1],</span></span>
<span id="cb117-10"><a href="sudoku-brute-force.html#cb117-10" tabindex="-1"></a><span class="co">#&gt;        [2],</span></span>
<span id="cb117-11"><a href="sudoku-brute-force.html#cb117-11" tabindex="-1"></a><span class="co">#&gt;        [3]])</span></span></code></pre></div>
<p>Wie oben erwähnt, macht die “Orientierung” von Vektoren einen Unterschied beim Stapeln. Erkunde diese Unterschiede in der Übung 9.</p>
<div class="practice">
<p>Mache Übung #9.</p>
</div>
</div>
<div id="wiederholen-und-kacheln" class="section level2" number="11.9">
<h2>
<span class="header-section-number">11.9</span> Wiederholen und Kacheln<a class="anchor" aria-label="anchor" href="#wiederholen-und-kacheln"><i class="fas fa-link"></i></a>
</h2>
<p>In der oben genannten Übung hast du vier Zeilen- oder Spaltenvektoren gestapelt, aber sie waren alle identisch. NumPy kann solche wiederholten Sequenzen über die Funktionen <a href="https://numpy.org/doc/stable/reference/generated/numpy.repeat.html">repeat</a> und <a href="https://numpy.org/doc/stable/reference/generated/numpy.tile.html">tile</a> generieren. Beide wiederholen die angeforderten Werte eine bestimmte Anzahl von Malen, aber es gibt ein paar wichtige Unterschiede. Erstens wiederholt <a href="https://numpy.org/doc/stable/reference/generated/numpy.repeat.html">repeat</a> jeden Wert N Mal, bevor es zum nächsten Wert übergeht, während <a href="https://numpy.org/doc/stable/reference/generated/numpy.tile.html">tile</a> die gesamte Sequenz in Reihenfolge N Mal wiederholt.</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb118-1"><a href="sudoku-brute-force.html#cb118-1" tabindex="-1"></a><span class="bu">print</span>(np.repeat(np.arange(<span class="dv">5</span>), <span class="dv">2</span>))</span>
<span id="cb118-2"><a href="sudoku-brute-force.html#cb118-2" tabindex="-1"></a><span class="co">#&gt; [0 0 1 1 2 2 3 3 4 4]</span></span>
<span id="cb118-3"><a href="sudoku-brute-force.html#cb118-3" tabindex="-1"></a><span class="bu">print</span>(np.tile(np.arange(<span class="dv">5</span>), <span class="dv">2</span>))</span>
<span id="cb118-4"><a href="sudoku-brute-force.html#cb118-4" tabindex="-1"></a><span class="co">#&gt; [0 1 2 3 4 0 1 2 3 4]</span></span></code></pre></div>
<p>Der zweite Unterschied besteht darin, wie du die Wiederholung beim Erstellen von 2D-Matrizen spezifizierst. Im Falle von <a href="https://numpy.org/doc/stable/reference/generated/numpy.repeat.html">repeat</a> gibst du an, entlang welcher <code>Achse</code> (axis) du die Sequenz wiederholst (gleich wie der <code>Achse</code>-Parameter beim <a href="sudoku-brute-force.html#stack">Stapeln</a>).</p>
<div class="practice">
<p>Mache Übung #10.</p>
</div>
<p>Für <a href="https://numpy.org/doc/stable/reference/generated/numpy.tile.html">tile</a> gibt man die Wiederholungen (<code>reps</code>-Parameter) an, und man kann die Wiederholungen <em>pro Achse</em> spezifizieren.</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb119-1"><a href="sudoku-brute-force.html#cb119-1" tabindex="-1"></a><span class="co"># Ein Array zweimal zeilenweise und dreimal spaltenweise kacheln (tile)</span></span>
<span id="cb119-2"><a href="sudoku-brute-force.html#cb119-2" tabindex="-1"></a>np.tile(np.array([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]), (<span class="dv">2</span>, <span class="dv">3</span>))</span>
<span id="cb119-3"><a href="sudoku-brute-force.html#cb119-3" tabindex="-1"></a><span class="co">#&gt; array([[1, 2, 3, 1, 2, 3, 1, 2, 3],</span></span>
<span id="cb119-4"><a href="sudoku-brute-force.html#cb119-4" tabindex="-1"></a><span class="co">#&gt;        [1, 2, 3, 1, 2, 3, 1, 2, 3]])</span></span></code></pre></div>
<div class="practice">
<p>Mache Übung #11.</p>
</div>
</div>
<div id="sudoku-erzeugung-mittels-brute-force-ordnung-und-chaos" class="section level2" number="11.10">
<h2>
<span class="header-section-number">11.10</span> Sudoku-Erzeugung mittels Brute-Force: Ordnung und Chaos<a class="anchor" aria-label="anchor" href="#sudoku-erzeugung-mittels-brute-force-ordnung-und-chaos"><i class="fas fa-link"></i></a>
</h2>
<p>Unser Ansatz zur Erzeugung von Sudoku wird konzeptionell einfach, aber sehr ineffizient sein: Wir werden eine geordnete Matrix erstellen (nach Zeile oder Spalte; keine gültige Ausgangslösung), diese mischen (zeilen- oder spaltenweise), und dann prüfen, ob wir zufällig eine gültige Sudoku-Matrix erhalten haben. Wenn nicht, weiter mischen, bis wir eine haben.</p>
<p>Du weißt bereits, wie man eine geordnete Matrix erstellt, die vier oder neun Zeilen und Spalten hat. Um sie zu randomisieren, verwende <a href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.shuffle.html">np.random.shuffle</a>, das ein Array oder einen <em>Teil eines</em> Arrays <em>am Ort</em> mischt. Der letzte Teil bedeutet, dass die Funktion keinen Wert zurückgibt und das von dir gelieferte Array (es wird per Referenz übergeben, erinnere dich an <a href="guess-the-animal.html#mutable-objects">veränderliche Objekte und Funktionen</a>).</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb120-1"><a href="sudoku-brute-force.html#cb120-1" tabindex="-1"></a><span class="co">#Das gesamte Array mischen</span></span>
<span id="cb120-2"><a href="sudoku-brute-force.html#cb120-2" tabindex="-1"></a>an_array <span class="op">=</span> np.arange(<span class="dv">5</span>)</span>
<span id="cb120-3"><a href="sudoku-brute-force.html#cb120-3" tabindex="-1"></a>np.random.shuffle(an_array)</span>
<span id="cb120-4"><a href="sudoku-brute-force.html#cb120-4" tabindex="-1"></a><span class="bu">print</span>(an_array)</span>
<span id="cb120-5"><a href="sudoku-brute-force.html#cb120-5" tabindex="-1"></a><span class="co">#&gt; [4 2 3 1 0]</span></span>
<span id="cb120-6"><a href="sudoku-brute-force.html#cb120-6" tabindex="-1"></a></span>
<span id="cb120-7"><a href="sudoku-brute-force.html#cb120-7" tabindex="-1"></a><span class="co"># Einen Teil eines Arrays mischen</span></span>
<span id="cb120-8"><a href="sudoku-brute-force.html#cb120-8" tabindex="-1"></a>an_array <span class="op">=</span> np.arange(<span class="dv">5</span>)</span>
<span id="cb120-9"><a href="sudoku-brute-force.html#cb120-9" tabindex="-1"></a>np.random.shuffle(an_array[:<span class="dv">3</span>])</span>
<span id="cb120-10"><a href="sudoku-brute-force.html#cb120-10" tabindex="-1"></a><span class="bu">print</span>(an_array)</span>
<span id="cb120-11"><a href="sudoku-brute-force.html#cb120-11" tabindex="-1"></a><span class="co">#&gt; [0 1 2 3 4]</span></span></code></pre></div>
<p>Schreibe den Code, der eine <span class="math inline">\(4\times4\)</span>-Matrix erstellt (definiere die Größe der Matrix über die Konstante <code>SUDOKU_SIZE</code>), die nach Zeilen geordnet ist
(also jede Zeile geht von 1 bis <code>SUDOKU_SIZE</code>, aber jede Spalte hat die gleiche Zahl darin), und schreibe den Code, der genau eine Zeile mischt (lege ihren Index in der Variablen <code>irow</code> fest). Ändere den Wert von <code>irow</code>, um zu testen, ob dein Code funktioniert. Beispielsweise könnte dein Output für eine zufällig gemischte Zeile #2 so aussehen.</p>
<pre><code>#&gt; array([[1, 2, 3, 4],
#&gt;        [2, 4, 1, 3],
#&gt;        [1, 2, 3, 4],
#&gt;        [1, 2, 3, 4]])</code></pre>
<div class="program">
<p>Schreibe Code für das Erstellen einer Matrix<br>
und das Mischen einer Zeile in Übung #12.</p>
</div>
<p>Sobald der Code für das Mischen einer einzelnen Zeile funktioniert, modifiziere ihn so, dass alle Zeilen einzeln gemischt werden (du kannst das gesamte Matrix mischen, aber dann werden die Zeilen höchstwahrscheinlich ungültig sein). Sobald der Misch-Code funktioniert, verwandle ihn in eine Funktion <code>shuffle_by_row</code>. Wie bei <a href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.shuffle.html">np.random.shuffle</a> muss sie nichts zurückgeben, da das Mischen direkt im übergebenen Array erfolgt. Schreibe den Code, der eine nach Zeilen geordnete Matrix der Größe <code>SUDOKU_SIZE</code> generiert, diese zeilenweise mischt und ausgibt. Du musst definitiv die <a href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.shape.html">Form</a> der Matrix kennen und über den <a href="https://docs.python.org/3/library/functions.html#func-range">Bereich</a> der Zeilen iterieren.</p>
<div class="program">
<p>Füge <code>shuffle_by_row</code> in <em>utils.py</em> ein<br>
Schreibe das Programm in <em>code01.py</em></p>
</div>
<p>Wir sind hier, um zu lernen, also um deine Fähigkeiten zu festigen, programmiere dieselbe Routine sowohl durch das Stapeln als auch durch das Mischen der Matrix <em>spaltenweise</em> (erstelle hierfür eine separate Funktion <code>shuffle_by_column</code>).</p>
<div class="program">
<p>Füge <code>shuffle_by_column</code> in <em>utils.py</em> ein<br>
Schreibe das Programm in <em>code02.py</em></p>
</div>
</div>
<div id="beispiele-für-validierungen" class="section level2" number="11.11">
<h2>
<span class="header-section-number">11.11</span> Beispiele für Validierungen<a class="anchor" aria-label="anchor" href="#beispiele-f%C3%BCr-validierungen"><i class="fas fa-link"></i></a>
</h2>
<p>Im folgenden Abschnitt wirst du Funktionen schreiben, die die Gültigkeit von Zeilen, Spalten und Blöcken überprüfen. Dafür benötigen wir Beispiele, die für alle oder einige Überprüfungen gültig sind. Verwende die Zelle unten, um später die Überprüfung durchzuführen.</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb122-1"><a href="sudoku-brute-force.html#cb122-1" tabindex="-1"></a>all_valid <span class="op">=</span> np.array([[<span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>],</span>
<span id="cb122-2"><a href="sudoku-brute-force.html#cb122-2" tabindex="-1"></a>                      [<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">1</span>],</span>
<span id="cb122-3"><a href="sudoku-brute-force.html#cb122-3" tabindex="-1"></a>                      [<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">3</span>],</span>
<span id="cb122-4"><a href="sudoku-brute-force.html#cb122-4" tabindex="-1"></a>                      [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">4</span>]])</span>
<span id="cb122-5"><a href="sudoku-brute-force.html#cb122-5" tabindex="-1"></a></span>
<span id="cb122-6"><a href="sudoku-brute-force.html#cb122-6" tabindex="-1"></a>invalid_row <span class="op">=</span> np.array([[<span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">1</span>],</span>
<span id="cb122-7"><a href="sudoku-brute-force.html#cb122-7" tabindex="-1"></a>                        [<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">2</span>],</span>
<span id="cb122-8"><a href="sudoku-brute-force.html#cb122-8" tabindex="-1"></a>                        [<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">3</span>],</span>
<span id="cb122-9"><a href="sudoku-brute-force.html#cb122-9" tabindex="-1"></a>                        [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">4</span>]])</span>
<span id="cb122-10"><a href="sudoku-brute-force.html#cb122-10" tabindex="-1"></a></span>
<span id="cb122-11"><a href="sudoku-brute-force.html#cb122-11" tabindex="-1"></a>invalid_column <span class="op">=</span> np.array([[<span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>],</span>
<span id="cb122-12"><a href="sudoku-brute-force.html#cb122-12" tabindex="-1"></a>                           [<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">4</span>],</span>
<span id="cb122-13"><a href="sudoku-brute-force.html#cb122-13" tabindex="-1"></a>                           [<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">3</span>],</span>
<span id="cb122-14"><a href="sudoku-brute-force.html#cb122-14" tabindex="-1"></a>                           [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">4</span>]])</span>
<span id="cb122-15"><a href="sudoku-brute-force.html#cb122-15" tabindex="-1"></a></span>
<span id="cb122-16"><a href="sudoku-brute-force.html#cb122-16" tabindex="-1"></a>invalid_block_and_column <span class="op">=</span> np.array([[<span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">2</span>],</span>
<span id="cb122-17"><a href="sudoku-brute-force.html#cb122-17" tabindex="-1"></a>                                     [<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">1</span>],</span>
<span id="cb122-18"><a href="sudoku-brute-force.html#cb122-18" tabindex="-1"></a>                                     [<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">3</span>],</span>
<span id="cb122-19"><a href="sudoku-brute-force.html#cb122-19" tabindex="-1"></a>                                     [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]])</span>
<span id="cb122-20"><a href="sudoku-brute-force.html#cb122-20" tabindex="-1"></a></span>
<span id="cb122-21"><a href="sudoku-brute-force.html#cb122-21" tabindex="-1"></a>invalid_block_and_row <span class="op">=</span> np.array([[<span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>],</span>
<span id="cb122-22"><a href="sudoku-brute-force.html#cb122-22" tabindex="-1"></a>                                  [<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">1</span>],</span>
<span id="cb122-23"><a href="sudoku-brute-force.html#cb122-23" tabindex="-1"></a>                                  [<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>],</span>
<span id="cb122-24"><a href="sudoku-brute-force.html#cb122-24" tabindex="-1"></a>                                  [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">4</span>]])</span>
<span id="cb122-25"><a href="sudoku-brute-force.html#cb122-25" tabindex="-1"></a></span>
<span id="cb122-26"><a href="sudoku-brute-force.html#cb122-26" tabindex="-1"></a>all_invalid <span class="op">=</span> np.array([[<span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>],</span>
<span id="cb122-27"><a href="sudoku-brute-force.html#cb122-27" tabindex="-1"></a>                        [<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">4</span>],</span>
<span id="cb122-28"><a href="sudoku-brute-force.html#cb122-28" tabindex="-1"></a>                        [<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>],</span>
<span id="cb122-29"><a href="sudoku-brute-force.html#cb122-29" tabindex="-1"></a>                        [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">4</span>]])</span></code></pre></div>
</div>
<div id="ist-diese-zeile-überhaupt-gültig" class="section level2" number="11.12">
<h2>
<span class="header-section-number">11.12</span> Ist diese Zeile überhaupt gültig?<a class="anchor" aria-label="anchor" href="#ist-diese-zeile-%C3%BCberhaupt-g%C3%BCltig"><i class="fas fa-link"></i></a>
</h2>
<p>Damit eine Matrix ein Sudoku ist, muss sie der Regel “nur eindeutige Zahlen in jeder Zeile, jeder Spalte und jedem Block” folgen. Lass uns einen Code implementieren, um die Zeilen zu überprüfen (ihn in eine Spaltenüberprüfung umzusetzen, wird trivial sein).</p>
<p>Damit eine Zeile gültig ist, muss sie <code>SUDOKU_SIZE</code> verschiedene, d.h. <a href="https://numpy.org/doc/stable/reference/generated/numpy.unique.html">einzigartige</a> Zahlen enthalten. Verwende die Funktion <a href="https://numpy.org/doc/stable/reference/generated/numpy.unique.html">unique</a>, um einen Vergleich für die Zeile <code>irow</code> zu schreiben (setze sie von Hand auf einen gültigen Index), dass sie tatsächlich <code>SUDOKU_SIZE</code> einzigartige Zahlen hat, d.h. die <a href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.size.html">Größe</a> des Arrays einzigartiger Zahlen ist gleich <code>SUDOKU_SIZE</code>. Gib jedoch nicht die Konstante <code>SUDOKU_SIZE</code> an die Funktion weiter, sondern leite die Anzahl der erforderlichen einzigartigen Elemente aus der <a href="https://numpy.org/doc/stable/reference/generated/numpy.shape.html">Form</a> der Matrix selbst ab.</p>
<p>Verwende Beispielmatrizen (siehe oben), um zu überprüfen, ob es korrekt funktioniert.</p>
<div class="program">
<p>Schreibe und teste die Überprüfung einer einzelnen Zeile<br>
in Übung #12.</p>
</div>
<p>Sobald der Code für eine einzelne Zeile funktioniert, können wir eine <a href="One-armed-bandit.html#list-comprehension">List Comprehension</a> verwenden, um eine Liste von Gültigkeitswerten zu generieren, einen für jede Zeile. Eine Matrix ist gültig (zumindest was die Zeilen angeht), nur wenn <em>alle</em> Zeilen gültig sind. Praktischerweise hat NumPy eine Funktion <a href="https://numpy.org/doc/stable/reference/generated/numpy.all.html">all</a>, die testet, ob <em>alle</em> Elemente des Arrays oder der Liste <code>True</code> sind. Verpacke diesen Code in die Funktion <code>validate_rows</code>, überlege dir ihre Eingaben und Ausgaben, dokumentiere sie.</p>
<div class="program">
<p>Füge <code>validate_rows</code> in <em>utils.py</em> ein<br>
Erweitere das Programm aus <em>code01.py</em> in <em>code03.py</em><br>
Teste den Code mit Beispielmatrizen.</p>
</div>
<p>Mache nun dasselbe für Spalten und verwende beide Überprüfungen, um zu sehen, ob die Matrix ein gültiges Sudoku ist (Zeilen sollten in Ordnung sein, aber Spalten sollten den Test nicht bestehen).
::: {.program}
Füge <code>validate_columns</code> in <em>utils.py</em> ein<br>
Erweitere das Programm aus <em>code03.py</em> in <em>code04.py</em><br>
Teste den Code mit Beispielmatrizen.
:::</p>
</div>
<div id="blöcke" class="section level2" number="11.13">
<h2>
<span class="header-section-number">11.13</span> Blöcke<a class="anchor" aria-label="anchor" href="#bl%C3%B6cke"><i class="fas fa-link"></i></a>
</h2>
<p>Blöcke zu bearbeiten ist etwas kniffliger, da wir keine einfache einzelne Achse zum Schneiden (Slicing) verwenden können. Wir können jedoch jeden Block so betrachten, als hätte er einen Zeilen- und einen Spaltenindex, die beide von 0 bis 2 für ein <span class="math inline">\(9\times9\)</span> Sudoku gehen, weil wir <span class="math inline">\(3\times3\)</span> Blöcke haben, oder von 0 bis 1 für ein <span class="math inline">\(4\times4\)</span> Sudoku, wo wir <span class="math inline">\(2\times2\)</span> Blöcke haben.</p>
<div class="float">
<img src="images/sudoku-blocks.png" style="display: block; margin: 0 auto;width:50.0%" alt="Sudoku-Block-Indizierung"><div class="figcaption">Sudoku-Block-Indizierung</div>
</div>
<p><br><br>
Schreibe den Code, der <a href="https://numpy.org/doc/stable/user/basics.indexing.html#slicing-and-striding">Slicing</a> verwendet, um einen einzelnen Block zu extrahieren, der durch <code>i_block_row</code> und <code>i_block_col</code> definiert ist. Berechne die Matrixzeile für die obere linke Ecke des Blocks und nimm dann einen vertikalen Ausschnitt bezüglich dieser. Das Gleiche gilt für den horizontalen Ausschnitt in Bezug auf die linke obere Blockspalte in der Matrix. Um das Debuggen zu erleichtern, erzeuge eine <span class="math inline">\(9\times9\)</span> Matrix aus ganzen Zahlen, gestapelt entweder nach Zeilen oder Spalten, damit leichter zu sehen ist, ob dein Code funktioniert. Teste ihn für alle Kombinationen von <code>i_block_row</code> und <code>i_block_col</code>. Du musst auch die Blockgröße berechnen oder definieren. Tue letzteres, da es sehr einfach ist, aus der Matrixform zu berechnen. In einem quadratischen Sudoku ist die Blockgröße eine <a href="https://docs.python.org/3/library/math.html#math.sqrt">Quadratwurzel</a> der Brettgröße (Bretter der Größe <span class="math inline">\(4\times4\)</span> haben Blöcke der Größe <span class="math inline">\(2\times2\)</span>, Bretter der Größe <span class="math inline">\(9\times9\)</span> haben Blöcke der Größe <span class="math inline">\(3\times3\)</span> usw.). Deine Größe sollte jedoch eine ganze Zahl sein, also musst du dich selbst um die <a href="https://docs.python.org/3/library/functions.html#int">Typumwandlung</a> kümmern.</p>
<p>So sollte die Ausgabe aussehen, wenn <code>i_block_row = 1</code> und <code>i_block_col = 0</code> sind, wenn du die Matrix zeilenweise stapelst.</p>
<pre><code>#&gt; array([[1, 2, 3],
#&gt;        [1, 2, 3],
#&gt;        [1, 2, 3]])</code></pre>
<p>und wenn sie spaltenweise gestapelt ist</p>
<pre><code>#&gt; array([[4, 4, 4],
#&gt;        [5, 5, 5],
#&gt;        [6, 6, 6]])</code></pre>
<div class="program">
<p>Schreibe und teste den Code für die Extraktion eines einzelnen Blocks<br>
in Übung #13.</p>
</div>
<p>Sobald du den Code hast, um Blockwerte zu extrahieren, ist die Logik zur Überprüfung der Gültigkeit sehr ähnlich wie bei der Überprüfung von Zeilen und Spalten. Beachte, dass du <a href="https://numpy.org/doc/stable/reference/generated/numpy.unique.html">unique</a> direkt auf das extrahierte 2D-Array anwenden kannst oder optional kannst du es zuerst mit <a href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.flatten.html">flatten</a> in ein 1D-Array umwandeln. Sobald du eine Liste von neun logischen Werten (einer pro Block) hast, kannst du überprüfen, ob diese <a href="https://numpy.org/doc/stable/reference/generated/numpy.all.html">alle</a> <code>True</code> sind. Der Hauptunterschied hier ist, dass du verschachtelte Schleifen benötigst, um über das 2D-Netz der Blöcke zu iterieren. Meine Lösung besteht darin, eine leere Liste für die Validierungswerte zu erstellen und dann über die Blockzeile und Blockspalte zu iterieren, <a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists">indem ich</a> Werte der Liste hinzufüge.</p>
<div class="program">
<p>Füge <code>validate_blocks</code> in <em>utils.py</em> ein<br>
Teste alle drei Validierungsfunktionen mithilfe von<br>
Beispielmatrizen in <em>code05.py</em></p>
</div>
</div>
<div id="brute-force-in-aktion" class="section level2" number="11.14">
<h2>
<span class="header-section-number">11.14</span> Brute-Force in Aktion<a class="anchor" aria-label="anchor" href="#brute-force-in-aktion"><i class="fas fa-link"></i></a>
</h2>
<p>Wir haben alle Bausteine, um den Versuch zu starten, Sudoku mittels Brute-Force zu generieren. Fasse die drei Validierungsfunktionen, die du erstellt hast, in einer einzelnen Funktion <code>validate_matrix</code> zusammen, die nur dann <code>True</code> zurückgibt, wenn alle Zeilen, alle Spalten und alle Blöcke gültig sind. Dann generiere eine geordnete Matrix zeilenweise und mische in einer Schleife (ich würde eine for-Schleife nutzen und sie auf zum Beispiel 1000 Iterationen beschränken) diese Matrix zeilenweise und prüfe, ob sie gültig ist. Wenn sie es ist, brich aus der Schleife aus und drucke das Sudoku aus. Schreibe eine traurige Nachricht (ohne Ausdruck einer Matrix), sobald du die Versuche aufgebraucht hast (aber ansonsten keine traurige Nachricht!). Alternativ kannst du die Matrix auch spaltenweise ordnen und dann ebenso spaltenweise mischen (warum funktioniert es nicht, sie zeilenweise zu ordnen und spaltenweise zu mischen?). Setze die Matrixgröße auf 4, aber beachte, dass unser Code mit jeder korrekten Matrixgröße funktionieren wird (<span class="math inline">\(9\times9\)</span>, <span class="math inline">\(16\times16\)</span> usw.).</p>
<div class="program">
<p>Füge <code>validate_matrix</code> in <em>utils.py</em> ein<br>
Schreibe das Programm in <em>code06.py</em></p>
</div>
</div>
<div id="zusammenfassung-1" class="section level2" number="11.15">
<h2>
<span class="header-section-number">11.15</span> Zusammenfassung<a class="anchor" aria-label="anchor" href="#zusammenfassung-1"><i class="fas fa-link"></i></a>
</h2>
<p>Ausgezeichnet, wir haben ein funktionierendes Programm, das (sehr selten) eine vollständige Sudoku-Matrix erzeugt. Zippe und reiche ein, und nächstes Mal werden wir eine andere, effizientere Implementierung des Algorithmus schreiben.</p>

</div>
</div>




















































  <div class="chapter-nav">
<div class="prev"><a href="guess-the-animal.html"><span class="header-section-number">10</span> Rate das Tier</a></div>
<div class="empty"></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#sudoku-brute-force"><span class="header-section-number">11</span> Sudoku: Brute-Force-Algorithmus</a></li>
<li><a class="nav-link" href="#numpy-importieren"><span class="header-section-number">11.1</span> NumPy importieren</a></li>
<li><a class="nav-link" href="#d-numpy-arrays-versus-python-listen"><span class="header-section-number">11.2</span> 1D-NumPy-Arrays versus Python-Listen</a></li>
<li><a class="nav-link" href="#d-numpy-arrays-auch-matrizen-genannt"><span class="header-section-number">11.3</span> 2D-NumPy-Arrays, auch Matrizen genannt</a></li>
<li><a class="nav-link" href="#arrays-einer-bestimmten-form-erstellen"><span class="header-section-number">11.4</span> Arrays einer bestimmten Form erstellen</a></li>
<li><a class="nav-link" href="#zuf%C3%A4llige-arrays-einer-bestimmten-gr%C3%B6%C3%9Fe-erstellen"><span class="header-section-number">11.5</span> Zufällige Arrays einer bestimmten Größe erstellen</a></li>
<li><a class="nav-link" href="#erstellen-von-arrays-mit-sequenzen"><span class="header-section-number">11.6</span> Erstellen von Arrays mit Sequenzen</a></li>
<li><a class="nav-link" href="#stack"><span class="header-section-number">11.7</span> Arrays zu einer Matrix stapeln</a></li>
<li><a class="nav-link" href="#zeilen--und-spaltenvektoren-versus-1d-arrays-row-col-vectors"><span class="header-section-number">11.8</span> Zeilen- und Spaltenvektoren versus 1D-Arrays (#row-col-vectors)</a></li>
<li><a class="nav-link" href="#wiederholen-und-kacheln"><span class="header-section-number">11.9</span> Wiederholen und Kacheln</a></li>
<li><a class="nav-link" href="#sudoku-erzeugung-mittels-brute-force-ordnung-und-chaos"><span class="header-section-number">11.10</span> Sudoku-Erzeugung mittels Brute-Force: Ordnung und Chaos</a></li>
<li><a class="nav-link" href="#beispiele-f%C3%BCr-validierungen"><span class="header-section-number">11.11</span> Beispiele für Validierungen</a></li>
<li><a class="nav-link" href="#ist-diese-zeile-%C3%BCberhaupt-g%C3%BCltig"><span class="header-section-number">11.12</span> Ist diese Zeile überhaupt gültig?</a></li>
<li><a class="nav-link" href="#bl%C3%B6cke"><span class="header-section-number">11.13</span> Blöcke</a></li>
<li><a class="nav-link" href="#brute-force-in-aktion"><span class="header-section-number">11.14</span> Brute-Force in Aktion</a></li>
<li><a class="nav-link" href="#zusammenfassung-1"><span class="header-section-number">11.15</span> Zusammenfassung</a></li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
<li><a id="book-source" href="https://github.com/alexander-pastukhov/learning-python-by-writing-games-de/blob/master/09-sudoku-brute-force.Rmd">View source <i class="fab fa-github"></i></a></li>
          <li><a id="book-edit" href="https://github.com/alexander-pastukhov/learning-python-by-writing-games-de/edit/master/09-sudoku-brute-force.Rmd">Edit this page <i class="fab fa-github"></i></a></li>
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Lerne Python, indem du Textspiele entwickels</strong>" was written by Alexander (Sasha) Pastukhov. It was last built on 2023-11-13.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>Please note that this website collects anonymized data via Google analytics. This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
