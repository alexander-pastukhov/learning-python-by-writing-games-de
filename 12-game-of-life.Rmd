# Game of Life {#game-of-life}

Practice makes perfect, so today we will implement a text version of the _Game of Life_ game. There will be little if any new material, as we will concentrate on using the skills and knowledge that you already have. Rather, the main focus will be on implementing the same functionality using different approaches, to make it easier to see both common and solution-specific aspects of the code. So be 

# Game of life
The [Game of Life](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life) was created by the British mathematician John Horton Conway. This is not really a game but rather a simulation where you set initial conditions up and observe how the population evolves. The rules, [as described on Wikipedia](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life), are very simple:

1. Any live cell with two or three live neighbors survives.
2. Any dead cell with three live neighbors becomes a live cell.
3. All other live cells die in the next generation. Similarly, all other dead cells stay dead.

Despite rules simplicity they produce remarkable evolution of a cell culture and give rise to many dynamic or static configurations. Here is an example simulation with a random starting state.

```{r, eval=knitr::is_html_output(excludes = "epub"), results = 'asis', echo = F}
cat(
'<div style="text-align:center;"><video controls>
    <source src="videos/game-of-life.m4v" type="video/mp4"> 
  </video></div>'
)
```

Our version will be less dynamic, as we will stick to the text-based output but will exhibit the same behavior as in the video above. This is more of a simulation than a game, so we need just three functions that

* generate the initial state of the world
* compute its state in the text time instance
* print it out.

The latter helps us see what the first two are doing, so we will start with it.

## Printing out the world
Before we go to creating the world and let it evolve, we need some means of seeing it, a `print_world` function. As this chapter is primarily about practice, we will produce with functionality three different ways:

* using nested for loops
* printing rows one by one, joining elements into a string
* joining all elements into a single string and printing just once.

Here is the practice matrix with a [glider spaceship](https://conwaylife.com/wiki/Glider) pattern that you can use

```{python}
import numpy as np

the_world = np.array([[" ", " ", "*", " "],
                      ["*", " ", "*", " "],
                      [" ", "*", "*", " "],
                      [" ", " ", " ", " "]])
```

here is dictionary we will use to translate between boring but simpler to type characters and better looking in out output

```{python}
OUTPUT_MAP = {" ": "⬜", "*" : "⬛"}
```

and here is how it should look like when you print it out:

```{python echo=FALSE}
def print_world_via_nested_loop(a_world):
  """Print out world via nested loops.
  
  Parameters
  ----------
  a_world : numpy.array
  """
  for irow in range(a_world.shape[0]):
    for icol in range(a_world.shape[1]):
      print(OUTPUT_MAP[a_world[irow, icol]], end="")
    print("")


def print_world_joining_rows(a_world):
  """
  Print out world by joining each row into a string.
  
  Parameters
  ----------
  a_world : numpy.array
  """
  for irow in range(a_world.shape[0]):
    row_string = "".join([OUTPUT_MAP[cell] for cell in a_world[irow, :]])
    print(row_string)

  
def print_world_as_a_single_string(a_world):
  """Print out world by first creating a single string
  
  Parameters
  ----------
  a_world : numpy.array
  """
  row_strings = ["".join([OUTPUT_MAP[cell] for cell in a_world[irow, :]]) 
                 for irow in range(a_world.shape[0])]
  world_string = "\n".join(row_strings)
  print(world_string)
    
print_world_via_nested_loop(the_world)
# print()
# print_world_joining_rows(the_world)
# print()
# print_world_as_a_single_string(the_world)
```

## Printing out via nested for loops
The first approach is print one element at a time by looping over rows and then looping over each element of the row. You know how to [loop over items](#for-loop), so you just need to think which value `end` parameter of the [print](https://docs.python.org/3/library/functions.html#print) do you use and when. Also, you need to translate the symbol from internal representation to the output using the `OUTPUT_MAP` dictionary (no if-elses are necessary!). Put the code into function `print_world_via_nested_loop`, which takes a single parameter (should be pretty obvious what it is). Document the function!

::: {.program}
Implement `print_world_via_nested_loop` in _utils.py_ <br/>
Test it in _code01.py_.
:::

## Print each row as a single string


## Creating the world
In the Game of Life, the world is a rectangular grid, whose size we will define via `WORLD_SIZE = (<W>, <H>)` where `<W>` and `<H>` are dimensions of your choice (e.g., 10 by 5?). 


